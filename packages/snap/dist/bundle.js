(() => {
  var __webpack_modules__ = {
    7452: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AwsCrc32 = void 0;
      var tslib_1 = __webpack_require__(2895);
      var util_1 = __webpack_require__(4959);
      var index_1 = __webpack_require__(2492);
      var AwsCrc32 = function () {
        function AwsCrc32() {
          this.crc32 = new index_1.Crc32();
        }
        AwsCrc32.prototype.update = function (toHash) {
          if ((0, util_1.isEmptyData)(toHash)) return;
          this.crc32.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc32.prototype.digest = function () {
          return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
              return [2, (0, util_1.numToUint8)(this.crc32.digest())];
            });
          });
        };
        AwsCrc32.prototype.reset = function () {
          this.crc32 = new index_1.Crc32();
        };
        return AwsCrc32;
      }();
      exports.AwsCrc32 = AwsCrc32;
    },
    2492: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
      var tslib_1 = __webpack_require__(2895);
      var util_1 = __webpack_require__(4959);
      function crc32(data) {
        return new Crc32().update(data).digest();
      }
      exports.crc32 = crc32;
      var Crc32 = function () {
        function Crc32() {
          this.checksum = 0xffffffff;
        }
        Crc32.prototype.update = function (data) {
          var e_1, _a;
          try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 0xff];
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return this;
        };
        Crc32.prototype.digest = function () {
          return (this.checksum ^ 0xffffffff) >>> 0;
        };
        return Crc32;
      }();
      exports.Crc32 = Crc32;
      var a_lookUpTable = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
      var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
      var aws_crc32_1 = __webpack_require__(7452);
      Object.defineProperty(exports, "AwsCrc32", {
        enumerable: true,
        get: function () {
          return aws_crc32_1.AwsCrc32;
        }
      });
    },
    2895: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        __assign: () => __assign,
        __asyncDelegator: () => __asyncDelegator,
        __asyncGenerator: () => __asyncGenerator,
        __asyncValues: () => __asyncValues,
        __await: () => __await,
        __awaiter: () => __awaiter,
        __classPrivateFieldGet: () => __classPrivateFieldGet,
        __classPrivateFieldSet: () => __classPrivateFieldSet,
        __createBinding: () => __createBinding,
        __decorate: () => __decorate,
        __exportStar: () => __exportStar,
        __extends: () => __extends,
        __generator: () => __generator,
        __importDefault: () => __importDefault,
        __importStar: () => __importStar,
        __makeTemplateObject: () => __makeTemplateObject,
        __metadata: () => __metadata,
        __param: () => __param,
        __read: () => __read,
        __rest: () => __rest,
        __spread: () => __spread,
        __spreadArrays: () => __spreadArrays,
        __values: () => __values
      });
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var __assign = function () {
        __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
      }
      function __decorate(decorators, target, key, desc) {
        var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      }
      function __param(paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      }
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function () {
              if (t[0] & 1) throw t[1];
              return t[1];
            },
            trys: [],
            ops: []
          },
          f,
          y,
          t,
          g;
        return g = {
          next: verb(0),
          "throw": verb(1),
          "return": verb(2)
        }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
          return this;
        }), g;
        function verb(n) {
          return function (v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return {
            value: op[0] ? op[1] : void 0,
            done: true
          };
        }
      }
      function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }
      function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
      }
      function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function () {
            if (o && i >= o.length) o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = {
            error: error
          };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      }
      function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
      }
      function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
        return r;
      }
      ;
      function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      }
      function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i;
        function verb(n) {
          if (g[n]) i[n] = function (v) {
            return new Promise(function (a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
      }
      function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function () {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function (v) {
            return (p = !p) ? {
              value: __await(o[n](v)),
              done: n === "return"
            } : f ? f(v) : v;
          } : f;
        }
      }
      function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator],
          i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function (v) {
            resolve({
              value: v,
              done: d
            });
          }, reject);
        }
      }
      function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", {
            value: raw
          });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }
      ;
      function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
      }
      function __importDefault(mod) {
        return mod && mod.__esModule ? mod : {
          default: mod
        };
      }
      function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      }
      function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      }
    },
    893: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    },
    4532: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    },
    5039: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    },
    6177: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    },
    9693: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isMsWindow = void 0;
      var msSubtleCryptoMethods = ["decrypt", "digest", "encrypt", "exportKey", "generateKey", "importKey", "sign", "verify"];
      function quacksLikeAnMsWindow(window) {
        return "MSInputMethodContext" in window && "msCrypto" in window;
      }
      function isMsWindow(window) {
        if (quacksLikeAnMsWindow(window) && window.msCrypto.subtle !== undefined) {
          var _a = window.msCrypto,
            getRandomValues = _a.getRandomValues,
            subtle_1 = _a.subtle;
          return msSubtleCryptoMethods.map(function (methodName) {
            return subtle_1[methodName];
          }).concat(getRandomValues).every(function (method) {
            return typeof method === "function";
          });
        }
        return false;
      }
      exports.isMsWindow = isMsWindow;
    },
    2860: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var tslib_1 = __webpack_require__(8967);
      tslib_1.__exportStar(__webpack_require__(893), exports);
      tslib_1.__exportStar(__webpack_require__(4532), exports);
      tslib_1.__exportStar(__webpack_require__(5039), exports);
      tslib_1.__exportStar(__webpack_require__(6177), exports);
      tslib_1.__exportStar(__webpack_require__(9693), exports);
    },
    8967: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        __assign: () => __assign,
        __asyncDelegator: () => __asyncDelegator,
        __asyncGenerator: () => __asyncGenerator,
        __asyncValues: () => __asyncValues,
        __await: () => __await,
        __awaiter: () => __awaiter,
        __classPrivateFieldGet: () => __classPrivateFieldGet,
        __classPrivateFieldSet: () => __classPrivateFieldSet,
        __createBinding: () => __createBinding,
        __decorate: () => __decorate,
        __exportStar: () => __exportStar,
        __extends: () => __extends,
        __generator: () => __generator,
        __importDefault: () => __importDefault,
        __importStar: () => __importStar,
        __makeTemplateObject: () => __makeTemplateObject,
        __metadata: () => __metadata,
        __param: () => __param,
        __read: () => __read,
        __rest: () => __rest,
        __spread: () => __spread,
        __spreadArrays: () => __spreadArrays,
        __values: () => __values
      });
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var __assign = function () {
        __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
      }
      function __decorate(decorators, target, key, desc) {
        var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      }
      function __param(paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      }
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function () {
              if (t[0] & 1) throw t[1];
              return t[1];
            },
            trys: [],
            ops: []
          },
          f,
          y,
          t,
          g;
        return g = {
          next: verb(0),
          "throw": verb(1),
          "return": verb(2)
        }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
          return this;
        }), g;
        function verb(n) {
          return function (v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return {
            value: op[0] ? op[1] : void 0,
            done: true
          };
        }
      }
      function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }
      function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
      }
      function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function () {
            if (o && i >= o.length) o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = {
            error: error
          };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      }
      function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
      }
      function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
        return r;
      }
      ;
      function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      }
      function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i;
        function verb(n) {
          if (g[n]) i[n] = function (v) {
            return new Promise(function (a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
      }
      function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function () {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function (v) {
            return (p = !p) ? {
              value: __await(o[n](v)),
              done: n === "return"
            } : f ? f(v) : v;
          } : f;
        }
      }
      function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator],
          i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function (v) {
            resolve({
              value: v,
              done: d
            });
          }, reject);
        }
      }
      function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", {
            value: raw
          });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }
      ;
      function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
      }
      function __importDefault(mod) {
        return mod && mod.__esModule ? mod : {
          default: mod
        };
      }
      function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      }
      function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      }
    },
    3497: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.EMPTY_DATA_SHA_256 = exports.SHA_256_HMAC_ALGO = exports.SHA_256_HASH = void 0;
      exports.SHA_256_HASH = {
        name: "SHA-256"
      };
      exports.SHA_256_HMAC_ALGO = {
        name: "HMAC",
        hash: exports.SHA_256_HASH
      };
      exports.EMPTY_DATA_SHA_256 = new Uint8Array([227, 176, 196, 66, 152, 252, 28, 20, 154, 251, 244, 200, 153, 111, 185, 36, 39, 174, 65, 228, 100, 155, 147, 76, 164, 149, 153, 27, 120, 82, 184, 85]);
    },
    2401: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Sha256 = void 0;
      var ie11Sha256_1 = __webpack_require__(8479);
      var webCryptoSha256_1 = __webpack_require__(214);
      var sha256_js_1 = __webpack_require__(9387);
      var supports_web_crypto_1 = __webpack_require__(2942);
      var ie11_detection_1 = __webpack_require__(2860);
      var util_locate_window_1 = __webpack_require__(8281);
      var util_1 = __webpack_require__(4959);
      var Sha256 = function () {
        function Sha256(secret) {
          if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new webCryptoSha256_1.Sha256(secret);
          } else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new ie11Sha256_1.Sha256(secret);
          } else {
            this.hash = new sha256_js_1.Sha256(secret);
          }
        }
        Sha256.prototype.update = function (data, encoding) {
          this.hash.update((0, util_1.convertToBuffer)(data));
        };
        Sha256.prototype.digest = function () {
          return this.hash.digest();
        };
        Sha256.prototype.reset = function () {
          this.hash.reset();
        };
        return Sha256;
      }();
      exports.Sha256 = Sha256;
    },
    8479: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Sha256 = void 0;
      var isEmptyData_1 = __webpack_require__(5780);
      var constants_1 = __webpack_require__(3497);
      var util_utf8_browser_1 = __webpack_require__(6778);
      var util_locate_window_1 = __webpack_require__(8281);
      var Sha256 = function () {
        function Sha256(secret) {
          this.secret = secret;
          this.reset();
        }
        Sha256.prototype.update = function (toHash) {
          var _this = this;
          if ((0, isEmptyData_1.isEmptyData)(toHash)) {
            return;
          }
          this.operation = this.operation.then(function (operation) {
            operation.onerror = function () {
              _this.operation = Promise.reject(new Error("Error encountered updating hash"));
            };
            operation.process(toArrayBufferView(toHash));
            return operation;
          });
          this.operation.catch(function () {});
        };
        Sha256.prototype.digest = function () {
          return this.operation.then(function (operation) {
            return new Promise(function (resolve, reject) {
              operation.onerror = function () {
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.oncomplete = function () {
                if (operation.result) {
                  resolve(new Uint8Array(operation.result));
                }
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.finish();
            });
          });
        };
        Sha256.prototype.reset = function () {
          if (this.secret) {
            this.operation = getKeyPromise(this.secret).then(function (keyData) {
              return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, keyData);
            });
            this.operation.catch(function () {});
          } else {
            this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-256"));
          }
        };
        return Sha256;
      }();
      exports.Sha256 = Sha256;
      function getKeyPromise(secret) {
        return new Promise(function (resolve, reject) {
          var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]);
          keyOperation.oncomplete = function () {
            if (keyOperation.result) {
              resolve(keyOperation.result);
            }
            reject(new Error("ImportKey completed without importing key."));
          };
          keyOperation.onerror = function () {
            reject(new Error("ImportKey failed to import key."));
          };
        });
      }
      function toArrayBufferView(data) {
        if (typeof data === "string") {
          return (0, util_utf8_browser_1.fromUtf8)(data);
        }
        if (ArrayBuffer.isView(data)) {
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
      }
    },
    8322: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.WebCryptoSha256 = exports.Ie11Sha256 = void 0;
      var tslib_1 = __webpack_require__(2505);
      tslib_1.__exportStar(__webpack_require__(2401), exports);
      var ie11Sha256_1 = __webpack_require__(8479);
      Object.defineProperty(exports, "Ie11Sha256", {
        enumerable: true,
        get: function () {
          return ie11Sha256_1.Sha256;
        }
      });
      var webCryptoSha256_1 = __webpack_require__(214);
      Object.defineProperty(exports, "WebCryptoSha256", {
        enumerable: true,
        get: function () {
          return webCryptoSha256_1.Sha256;
        }
      });
    },
    5780: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isEmptyData = void 0;
      function isEmptyData(data) {
        if (typeof data === "string") {
          return data.length === 0;
        }
        return data.byteLength === 0;
      }
      exports.isEmptyData = isEmptyData;
    },
    214: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Sha256 = void 0;
      var util_1 = __webpack_require__(4959);
      var constants_1 = __webpack_require__(3497);
      var util_locate_window_1 = __webpack_require__(8281);
      var Sha256 = function () {
        function Sha256(secret) {
          this.toHash = new Uint8Array(0);
          this.secret = secret;
          this.reset();
        }
        Sha256.prototype.update = function (data) {
          if ((0, util_1.isEmptyData)(data)) {
            return;
          }
          var update = (0, util_1.convertToBuffer)(data);
          var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
          typedArray.set(this.toHash, 0);
          typedArray.set(update, this.toHash.byteLength);
          this.toHash = typedArray;
        };
        Sha256.prototype.digest = function () {
          var _this = this;
          if (this.key) {
            return this.key.then(function (key) {
              return (0, util_locate_window_1.locateWindow)().crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key, _this.toHash).then(function (data) {
                return new Uint8Array(data);
              });
            });
          }
          if ((0, util_1.isEmptyData)(this.toHash)) {
            return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);
          }
          return Promise.resolve().then(function () {
            return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);
          }).then(function (data) {
            return Promise.resolve(new Uint8Array(data));
          });
        };
        Sha256.prototype.reset = function () {
          var _this = this;
          this.toHash = new Uint8Array(0);
          if (this.secret && this.secret !== void 0) {
            this.key = new Promise(function (resolve, reject) {
              (0, util_locate_window_1.locateWindow)().crypto.subtle.importKey("raw", (0, util_1.convertToBuffer)(_this.secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
            });
            this.key.catch(function () {});
          }
        };
        return Sha256;
      }();
      exports.Sha256 = Sha256;
    },
    2505: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        __assign: () => __assign,
        __asyncDelegator: () => __asyncDelegator,
        __asyncGenerator: () => __asyncGenerator,
        __asyncValues: () => __asyncValues,
        __await: () => __await,
        __awaiter: () => __awaiter,
        __classPrivateFieldGet: () => __classPrivateFieldGet,
        __classPrivateFieldSet: () => __classPrivateFieldSet,
        __createBinding: () => __createBinding,
        __decorate: () => __decorate,
        __exportStar: () => __exportStar,
        __extends: () => __extends,
        __generator: () => __generator,
        __importDefault: () => __importDefault,
        __importStar: () => __importStar,
        __makeTemplateObject: () => __makeTemplateObject,
        __metadata: () => __metadata,
        __param: () => __param,
        __read: () => __read,
        __rest: () => __rest,
        __spread: () => __spread,
        __spreadArrays: () => __spreadArrays,
        __values: () => __values
      });
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var __assign = function () {
        __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
      }
      function __decorate(decorators, target, key, desc) {
        var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      }
      function __param(paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      }
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function () {
              if (t[0] & 1) throw t[1];
              return t[1];
            },
            trys: [],
            ops: []
          },
          f,
          y,
          t,
          g;
        return g = {
          next: verb(0),
          "throw": verb(1),
          "return": verb(2)
        }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
          return this;
        }), g;
        function verb(n) {
          return function (v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return {
            value: op[0] ? op[1] : void 0,
            done: true
          };
        }
      }
      function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }
      function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
      }
      function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function () {
            if (o && i >= o.length) o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = {
            error: error
          };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      }
      function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
      }
      function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
        return r;
      }
      ;
      function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      }
      function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i;
        function verb(n) {
          if (g[n]) i[n] = function (v) {
            return new Promise(function (a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
      }
      function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function () {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function (v) {
            return (p = !p) ? {
              value: __await(o[n](v)),
              done: n === "return"
            } : f ? f(v) : v;
          } : f;
        }
      }
      function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator],
          i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function (v) {
            resolve({
              value: v,
              done: d
            });
          }, reject);
        }
      }
      function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", {
            value: raw
          });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }
      ;
      function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
      }
      function __importDefault(mod) {
        return mod && mod.__esModule ? mod : {
          default: mod
        };
      }
      function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      }
      function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      }
    },
    4002: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.RawSha256 = void 0;
      var constants_1 = __webpack_require__(149);
      var RawSha256 = function () {
        function RawSha256() {
          this.state = Int32Array.from(constants_1.INIT);
          this.temp = new Int32Array(64);
          this.buffer = new Uint8Array(64);
          this.bufferLength = 0;
          this.bytesHashed = 0;
          this.finished = false;
        }
        RawSha256.prototype.update = function (data) {
          if (this.finished) {
            throw new Error("Attempted to update an already finished hash.");
          }
          var position = 0;
          var byteLength = data.byteLength;
          this.bytesHashed += byteLength;
          if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
            throw new Error("Cannot hash more than 2^53 - 1 bits");
          }
          while (byteLength > 0) {
            this.buffer[this.bufferLength++] = data[position++];
            byteLength--;
            if (this.bufferLength === constants_1.BLOCK_SIZE) {
              this.hashBuffer();
              this.bufferLength = 0;
            }
          }
        };
        RawSha256.prototype.digest = function () {
          if (!this.finished) {
            var bitsHashed = this.bytesHashed * 8;
            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
            var undecoratedLength = this.bufferLength;
            bufferView.setUint8(this.bufferLength++, 0x80);
            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
              for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {
                bufferView.setUint8(i, 0);
              }
              this.hashBuffer();
              this.bufferLength = 0;
            }
            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {
              bufferView.setUint8(i, 0);
            }
            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);
            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
            this.hashBuffer();
            this.finished = true;
          }
          var out = new Uint8Array(constants_1.DIGEST_LENGTH);
          for (var i = 0; i < 8; i++) {
            out[i * 4] = this.state[i] >>> 24 & 0xff;
            out[i * 4 + 1] = this.state[i] >>> 16 & 0xff;
            out[i * 4 + 2] = this.state[i] >>> 8 & 0xff;
            out[i * 4 + 3] = this.state[i] >>> 0 & 0xff;
          }
          return out;
        };
        RawSha256.prototype.hashBuffer = function () {
          var _a = this,
            buffer = _a.buffer,
            state = _a.state;
          var state0 = state[0],
            state1 = state[1],
            state2 = state[2],
            state3 = state[3],
            state4 = state[4],
            state5 = state[5],
            state6 = state[6],
            state7 = state[7];
          for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
            if (i < 16) {
              this.temp[i] = (buffer[i * 4] & 0xff) << 24 | (buffer[i * 4 + 1] & 0xff) << 16 | (buffer[i * 4 + 2] & 0xff) << 8 | buffer[i * 4 + 3] & 0xff;
            } else {
              var u = this.temp[i - 2];
              var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
              u = this.temp[i - 15];
              var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
              this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);
            }
            var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i] + this.temp[i] | 0) | 0) | 0;
            var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
            state7 = state6;
            state6 = state5;
            state5 = state4;
            state4 = state3 + t1 | 0;
            state3 = state2;
            state2 = state1;
            state1 = state0;
            state0 = t1 + t2 | 0;
          }
          state[0] += state0;
          state[1] += state1;
          state[2] += state2;
          state[3] += state3;
          state[4] += state4;
          state[5] += state5;
          state[6] += state6;
          state[7] += state7;
        };
        return RawSha256;
      }();
      exports.RawSha256 = RawSha256;
    },
    149: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MAX_HASHABLE_LENGTH = exports.INIT = exports.KEY = exports.DIGEST_LENGTH = exports.BLOCK_SIZE = void 0;
      exports.BLOCK_SIZE = 64;
      exports.DIGEST_LENGTH = 32;
      exports.KEY = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
      exports.INIT = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
      exports.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    },
    9387: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var tslib_1 = __webpack_require__(791);
      tslib_1.__exportStar(__webpack_require__(3572), exports);
    },
    3572: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Sha256 = void 0;
      var tslib_1 = __webpack_require__(791);
      var constants_1 = __webpack_require__(149);
      var RawSha256_1 = __webpack_require__(4002);
      var util_1 = __webpack_require__(4959);
      var Sha256 = function () {
        function Sha256(secret) {
          this.secret = secret;
          this.hash = new RawSha256_1.RawSha256();
          this.reset();
        }
        Sha256.prototype.update = function (toHash) {
          if ((0, util_1.isEmptyData)(toHash) || this.error) {
            return;
          }
          try {
            this.hash.update((0, util_1.convertToBuffer)(toHash));
          } catch (e) {
            this.error = e;
          }
        };
        Sha256.prototype.digestSync = function () {
          if (this.error) {
            throw this.error;
          }
          if (this.outer) {
            if (!this.outer.finished) {
              this.outer.update(this.hash.digest());
            }
            return this.outer.digest();
          }
          return this.hash.digest();
        };
        Sha256.prototype.digest = function () {
          return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
              return [2, this.digestSync()];
            });
          });
        };
        Sha256.prototype.reset = function () {
          this.hash = new RawSha256_1.RawSha256();
          if (this.secret) {
            this.outer = new RawSha256_1.RawSha256();
            var inner = bufferFromSecret(this.secret);
            var outer = new Uint8Array(constants_1.BLOCK_SIZE);
            outer.set(inner);
            for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
              inner[i] ^= 0x36;
              outer[i] ^= 0x5c;
            }
            this.hash.update(inner);
            this.outer.update(outer);
            for (var i = 0; i < inner.byteLength; i++) {
              inner[i] = 0;
            }
          }
        };
        return Sha256;
      }();
      exports.Sha256 = Sha256;
      function bufferFromSecret(secret) {
        var input = (0, util_1.convertToBuffer)(secret);
        if (input.byteLength > constants_1.BLOCK_SIZE) {
          var bufferHash = new RawSha256_1.RawSha256();
          bufferHash.update(input);
          input = bufferHash.digest();
        }
        var buffer = new Uint8Array(constants_1.BLOCK_SIZE);
        buffer.set(input);
        return buffer;
      }
    },
    791: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        __assign: () => __assign,
        __asyncDelegator: () => __asyncDelegator,
        __asyncGenerator: () => __asyncGenerator,
        __asyncValues: () => __asyncValues,
        __await: () => __await,
        __awaiter: () => __awaiter,
        __classPrivateFieldGet: () => __classPrivateFieldGet,
        __classPrivateFieldSet: () => __classPrivateFieldSet,
        __createBinding: () => __createBinding,
        __decorate: () => __decorate,
        __exportStar: () => __exportStar,
        __extends: () => __extends,
        __generator: () => __generator,
        __importDefault: () => __importDefault,
        __importStar: () => __importStar,
        __makeTemplateObject: () => __makeTemplateObject,
        __metadata: () => __metadata,
        __param: () => __param,
        __read: () => __read,
        __rest: () => __rest,
        __spread: () => __spread,
        __spreadArrays: () => __spreadArrays,
        __values: () => __values
      });
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var __assign = function () {
        __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
      }
      function __decorate(decorators, target, key, desc) {
        var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      }
      function __param(paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      }
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function () {
              if (t[0] & 1) throw t[1];
              return t[1];
            },
            trys: [],
            ops: []
          },
          f,
          y,
          t,
          g;
        return g = {
          next: verb(0),
          "throw": verb(1),
          "return": verb(2)
        }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
          return this;
        }), g;
        function verb(n) {
          return function (v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return {
            value: op[0] ? op[1] : void 0,
            done: true
          };
        }
      }
      function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }
      function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
      }
      function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function () {
            if (o && i >= o.length) o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = {
            error: error
          };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      }
      function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
      }
      function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
        return r;
      }
      ;
      function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      }
      function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i;
        function verb(n) {
          if (g[n]) i[n] = function (v) {
            return new Promise(function (a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
      }
      function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function () {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function (v) {
            return (p = !p) ? {
              value: __await(o[n](v)),
              done: n === "return"
            } : f ? f(v) : v;
          } : f;
        }
      }
      function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator],
          i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function (v) {
            resolve({
              value: v,
              done: d
            });
          }, reject);
        }
      }
      function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", {
            value: raw
          });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }
      ;
      function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
      }
      function __importDefault(mod) {
        return mod && mod.__esModule ? mod : {
          default: mod
        };
      }
      function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      }
      function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      }
    },
    2942: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var tslib_1 = __webpack_require__(8428);
      tslib_1.__exportStar(__webpack_require__(2445), exports);
    },
    2445: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.supportsZeroByteGCM = exports.supportsSubtleCrypto = exports.supportsSecureRandom = exports.supportsWebCrypto = void 0;
      var tslib_1 = __webpack_require__(8428);
      var subtleCryptoMethods = ["decrypt", "digest", "encrypt", "exportKey", "generateKey", "importKey", "sign", "verify"];
      function supportsWebCrypto(window) {
        if (supportsSecureRandom(window) && typeof window.crypto.subtle === "object") {
          var subtle = window.crypto.subtle;
          return supportsSubtleCrypto(subtle);
        }
        return false;
      }
      exports.supportsWebCrypto = supportsWebCrypto;
      function supportsSecureRandom(window) {
        if (typeof window === "object" && typeof window.crypto === "object") {
          var getRandomValues = window.crypto.getRandomValues;
          return typeof getRandomValues === "function";
        }
        return false;
      }
      exports.supportsSecureRandom = supportsSecureRandom;
      function supportsSubtleCrypto(subtle) {
        return subtle && subtleCryptoMethods.every(function (methodName) {
          return typeof subtle[methodName] === "function";
        });
      }
      exports.supportsSubtleCrypto = supportsSubtleCrypto;
      function supportsZeroByteGCM(subtle) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
          var key, zeroByteAuthTag, _a;
          return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
              case 0:
                if (!supportsSubtleCrypto(subtle)) return [2, false];
                _b.label = 1;
              case 1:
                _b.trys.push([1, 4,, 5]);
                return [4, subtle.generateKey({
                  name: "AES-GCM",
                  length: 128
                }, false, ["encrypt"])];
              case 2:
                key = _b.sent();
                return [4, subtle.encrypt({
                  name: "AES-GCM",
                  iv: new Uint8Array(Array(12)),
                  additionalData: new Uint8Array(Array(16)),
                  tagLength: 128
                }, key, new Uint8Array(0))];
              case 3:
                zeroByteAuthTag = _b.sent();
                return [2, zeroByteAuthTag.byteLength === 16];
              case 4:
                _a = _b.sent();
                return [2, false];
              case 5:
                return [2];
            }
          });
        });
      }
      exports.supportsZeroByteGCM = supportsZeroByteGCM;
    },
    8428: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        __assign: () => __assign,
        __asyncDelegator: () => __asyncDelegator,
        __asyncGenerator: () => __asyncGenerator,
        __asyncValues: () => __asyncValues,
        __await: () => __await,
        __awaiter: () => __awaiter,
        __classPrivateFieldGet: () => __classPrivateFieldGet,
        __classPrivateFieldSet: () => __classPrivateFieldSet,
        __createBinding: () => __createBinding,
        __decorate: () => __decorate,
        __exportStar: () => __exportStar,
        __extends: () => __extends,
        __generator: () => __generator,
        __importDefault: () => __importDefault,
        __importStar: () => __importStar,
        __makeTemplateObject: () => __makeTemplateObject,
        __metadata: () => __metadata,
        __param: () => __param,
        __read: () => __read,
        __rest: () => __rest,
        __spread: () => __spread,
        __spreadArrays: () => __spreadArrays,
        __values: () => __values
      });
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var __assign = function () {
        __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
      }
      function __decorate(decorators, target, key, desc) {
        var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      }
      function __param(paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      }
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function () {
              if (t[0] & 1) throw t[1];
              return t[1];
            },
            trys: [],
            ops: []
          },
          f,
          y,
          t,
          g;
        return g = {
          next: verb(0),
          "throw": verb(1),
          "return": verb(2)
        }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
          return this;
        }), g;
        function verb(n) {
          return function (v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return {
            value: op[0] ? op[1] : void 0,
            done: true
          };
        }
      }
      function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }
      function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
      }
      function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function () {
            if (o && i >= o.length) o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = {
            error: error
          };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      }
      function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
      }
      function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
        return r;
      }
      ;
      function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      }
      function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i;
        function verb(n) {
          if (g[n]) i[n] = function (v) {
            return new Promise(function (a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
      }
      function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function () {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function (v) {
            return (p = !p) ? {
              value: __await(o[n](v)),
              done: n === "return"
            } : f ? f(v) : v;
          } : f;
        }
      }
      function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator],
          i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function (v) {
            resolve({
              value: v,
              done: d
            });
          }, reject);
        }
      }
      function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", {
            value: raw
          });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }
      ;
      function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
      }
      function __importDefault(mod) {
        return mod && mod.__esModule ? mod : {
          default: mod
        };
      }
      function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      }
      function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      }
    },
    3376: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      var Buffer = __webpack_require__(8834)["lW"];
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.convertToBuffer = void 0;
      var util_utf8_browser_1 = __webpack_require__(6778);
      var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from ? function (input) {
        return Buffer.from(input, "utf8");
      } : util_utf8_browser_1.fromUtf8;
      function convertToBuffer(data) {
        if (data instanceof Uint8Array) return data;
        if (typeof data === "string") {
          return fromUtf8(data);
        }
        if (ArrayBuffer.isView(data)) {
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
      }
      exports.convertToBuffer = convertToBuffer;
    },
    4959: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
      var convertToBuffer_1 = __webpack_require__(3376);
      Object.defineProperty(exports, "convertToBuffer", {
        enumerable: true,
        get: function () {
          return convertToBuffer_1.convertToBuffer;
        }
      });
      var isEmptyData_1 = __webpack_require__(1205);
      Object.defineProperty(exports, "isEmptyData", {
        enumerable: true,
        get: function () {
          return isEmptyData_1.isEmptyData;
        }
      });
      var numToUint8_1 = __webpack_require__(1443);
      Object.defineProperty(exports, "numToUint8", {
        enumerable: true,
        get: function () {
          return numToUint8_1.numToUint8;
        }
      });
      var uint32ArrayFrom_1 = __webpack_require__(1650);
      Object.defineProperty(exports, "uint32ArrayFrom", {
        enumerable: true,
        get: function () {
          return uint32ArrayFrom_1.uint32ArrayFrom;
        }
      });
    },
    1205: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isEmptyData = void 0;
      function isEmptyData(data) {
        if (typeof data === "string") {
          return data.length === 0;
        }
        return data.byteLength === 0;
      }
      exports.isEmptyData = isEmptyData;
    },
    1443: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.numToUint8 = void 0;
      function numToUint8(num) {
        return new Uint8Array([(num & 0xff000000) >> 24, (num & 0x00ff0000) >> 16, (num & 0x0000ff00) >> 8, num & 0x000000ff]);
      }
      exports.numToUint8 = numToUint8;
    },
    1650: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.uint32ArrayFrom = void 0;
      function uint32ArrayFrom(a_lookUpTable) {
        if (!Uint32Array.from) {
          var return_array = new Uint32Array(a_lookUpTable.length);
          var a_index = 0;
          while (a_index < a_lookUpTable.length) {
            return_array[a_index] = a_lookUpTable[a_index];
            a_index += 1;
          }
          return return_array;
        }
        return Uint32Array.from(a_lookUpTable);
      }
      exports.uint32ArrayFrom = uint32ArrayFrom;
    },
    3123: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        $Command: () => Command,
        AccountTakeoverEventActionType: () => AccountTakeoverEventActionType,
        AddCustomAttributesCommand: () => AddCustomAttributesCommand,
        AdminAddUserToGroupCommand: () => AdminAddUserToGroupCommand,
        AdminAddUserToGroupRequestFilterSensitiveLog: () => AdminAddUserToGroupRequestFilterSensitiveLog,
        AdminConfirmSignUpCommand: () => AdminConfirmSignUpCommand,
        AdminConfirmSignUpRequestFilterSensitiveLog: () => AdminConfirmSignUpRequestFilterSensitiveLog,
        AdminCreateUserCommand: () => AdminCreateUserCommand,
        AdminCreateUserRequestFilterSensitiveLog: () => AdminCreateUserRequestFilterSensitiveLog,
        AdminCreateUserResponseFilterSensitiveLog: () => AdminCreateUserResponseFilterSensitiveLog,
        AdminDeleteUserAttributesCommand: () => AdminDeleteUserAttributesCommand,
        AdminDeleteUserAttributesRequestFilterSensitiveLog: () => AdminDeleteUserAttributesRequestFilterSensitiveLog,
        AdminDeleteUserCommand: () => AdminDeleteUserCommand,
        AdminDeleteUserRequestFilterSensitiveLog: () => AdminDeleteUserRequestFilterSensitiveLog,
        AdminDisableProviderForUserCommand: () => AdminDisableProviderForUserCommand,
        AdminDisableUserCommand: () => AdminDisableUserCommand,
        AdminDisableUserRequestFilterSensitiveLog: () => AdminDisableUserRequestFilterSensitiveLog,
        AdminEnableUserCommand: () => AdminEnableUserCommand,
        AdminEnableUserRequestFilterSensitiveLog: () => AdminEnableUserRequestFilterSensitiveLog,
        AdminForgetDeviceCommand: () => AdminForgetDeviceCommand,
        AdminForgetDeviceRequestFilterSensitiveLog: () => AdminForgetDeviceRequestFilterSensitiveLog,
        AdminGetDeviceCommand: () => AdminGetDeviceCommand,
        AdminGetDeviceRequestFilterSensitiveLog: () => AdminGetDeviceRequestFilterSensitiveLog,
        AdminGetDeviceResponseFilterSensitiveLog: () => AdminGetDeviceResponseFilterSensitiveLog,
        AdminGetUserCommand: () => AdminGetUserCommand,
        AdminGetUserRequestFilterSensitiveLog: () => AdminGetUserRequestFilterSensitiveLog,
        AdminGetUserResponseFilterSensitiveLog: () => AdminGetUserResponseFilterSensitiveLog,
        AdminInitiateAuthCommand: () => AdminInitiateAuthCommand,
        AdminInitiateAuthRequestFilterSensitiveLog: () => AdminInitiateAuthRequestFilterSensitiveLog,
        AdminInitiateAuthResponseFilterSensitiveLog: () => AdminInitiateAuthResponseFilterSensitiveLog,
        AdminLinkProviderForUserCommand: () => AdminLinkProviderForUserCommand,
        AdminListDevicesCommand: () => AdminListDevicesCommand,
        AdminListDevicesRequestFilterSensitiveLog: () => AdminListDevicesRequestFilterSensitiveLog,
        AdminListDevicesResponseFilterSensitiveLog: () => AdminListDevicesResponseFilterSensitiveLog,
        AdminListGroupsForUserCommand: () => AdminListGroupsForUserCommand,
        AdminListGroupsForUserRequestFilterSensitiveLog: () => AdminListGroupsForUserRequestFilterSensitiveLog,
        AdminListUserAuthEventsCommand: () => AdminListUserAuthEventsCommand,
        AdminListUserAuthEventsRequestFilterSensitiveLog: () => AdminListUserAuthEventsRequestFilterSensitiveLog,
        AdminRemoveUserFromGroupCommand: () => AdminRemoveUserFromGroupCommand,
        AdminRemoveUserFromGroupRequestFilterSensitiveLog: () => AdminRemoveUserFromGroupRequestFilterSensitiveLog,
        AdminResetUserPasswordCommand: () => AdminResetUserPasswordCommand,
        AdminResetUserPasswordRequestFilterSensitiveLog: () => AdminResetUserPasswordRequestFilterSensitiveLog,
        AdminRespondToAuthChallengeCommand: () => AdminRespondToAuthChallengeCommand,
        AdminRespondToAuthChallengeRequestFilterSensitiveLog: () => AdminRespondToAuthChallengeRequestFilterSensitiveLog,
        AdminRespondToAuthChallengeResponseFilterSensitiveLog: () => AdminRespondToAuthChallengeResponseFilterSensitiveLog,
        AdminSetUserMFAPreferenceCommand: () => AdminSetUserMFAPreferenceCommand,
        AdminSetUserMFAPreferenceRequestFilterSensitiveLog: () => AdminSetUserMFAPreferenceRequestFilterSensitiveLog,
        AdminSetUserPasswordCommand: () => AdminSetUserPasswordCommand,
        AdminSetUserPasswordRequestFilterSensitiveLog: () => AdminSetUserPasswordRequestFilterSensitiveLog,
        AdminSetUserSettingsCommand: () => AdminSetUserSettingsCommand,
        AdminSetUserSettingsRequestFilterSensitiveLog: () => AdminSetUserSettingsRequestFilterSensitiveLog,
        AdminUpdateAuthEventFeedbackCommand: () => AdminUpdateAuthEventFeedbackCommand,
        AdminUpdateAuthEventFeedbackRequestFilterSensitiveLog: () => AdminUpdateAuthEventFeedbackRequestFilterSensitiveLog,
        AdminUpdateDeviceStatusCommand: () => AdminUpdateDeviceStatusCommand,
        AdminUpdateDeviceStatusRequestFilterSensitiveLog: () => AdminUpdateDeviceStatusRequestFilterSensitiveLog,
        AdminUpdateUserAttributesCommand: () => AdminUpdateUserAttributesCommand,
        AdminUpdateUserAttributesRequestFilterSensitiveLog: () => AdminUpdateUserAttributesRequestFilterSensitiveLog,
        AdminUserGlobalSignOutCommand: () => AdminUserGlobalSignOutCommand,
        AdminUserGlobalSignOutRequestFilterSensitiveLog: () => AdminUserGlobalSignOutRequestFilterSensitiveLog,
        AdvancedSecurityModeType: () => AdvancedSecurityModeType,
        AliasAttributeType: () => AliasAttributeType,
        AliasExistsException: () => AliasExistsException,
        AssociateSoftwareTokenCommand: () => AssociateSoftwareTokenCommand,
        AssociateSoftwareTokenRequestFilterSensitiveLog: () => AssociateSoftwareTokenRequestFilterSensitiveLog,
        AssociateSoftwareTokenResponseFilterSensitiveLog: () => AssociateSoftwareTokenResponseFilterSensitiveLog,
        AttributeDataType: () => AttributeDataType,
        AttributeTypeFilterSensitiveLog: () => AttributeTypeFilterSensitiveLog,
        AuthFlowType: () => AuthFlowType,
        AuthenticationResultTypeFilterSensitiveLog: () => AuthenticationResultTypeFilterSensitiveLog,
        ChallengeName: () => ChallengeName,
        ChallengeNameType: () => ChallengeNameType,
        ChallengeResponse: () => ChallengeResponse,
        ChangePasswordCommand: () => ChangePasswordCommand,
        ChangePasswordRequestFilterSensitiveLog: () => ChangePasswordRequestFilterSensitiveLog,
        CodeDeliveryFailureException: () => CodeDeliveryFailureException,
        CodeMismatchException: () => CodeMismatchException,
        CognitoIdentityProvider: () => CognitoIdentityProvider,
        CognitoIdentityProviderClient: () => CognitoIdentityProviderClient,
        CognitoIdentityProviderServiceException: () => CognitoIdentityProviderServiceException,
        CompromisedCredentialsEventActionType: () => CompromisedCredentialsEventActionType,
        ConcurrentModificationException: () => ConcurrentModificationException,
        ConfirmDeviceCommand: () => ConfirmDeviceCommand,
        ConfirmDeviceRequestFilterSensitiveLog: () => ConfirmDeviceRequestFilterSensitiveLog,
        ConfirmForgotPasswordCommand: () => ConfirmForgotPasswordCommand,
        ConfirmForgotPasswordRequestFilterSensitiveLog: () => ConfirmForgotPasswordRequestFilterSensitiveLog,
        ConfirmSignUpCommand: () => ConfirmSignUpCommand,
        ConfirmSignUpRequestFilterSensitiveLog: () => ConfirmSignUpRequestFilterSensitiveLog,
        CreateGroupCommand: () => CreateGroupCommand,
        CreateIdentityProviderCommand: () => CreateIdentityProviderCommand,
        CreateResourceServerCommand: () => CreateResourceServerCommand,
        CreateUserImportJobCommand: () => CreateUserImportJobCommand,
        CreateUserPoolClientCommand: () => CreateUserPoolClientCommand,
        CreateUserPoolClientResponseFilterSensitiveLog: () => CreateUserPoolClientResponseFilterSensitiveLog,
        CreateUserPoolCommand: () => CreateUserPoolCommand,
        CreateUserPoolDomainCommand: () => CreateUserPoolDomainCommand,
        CustomEmailSenderLambdaVersionType: () => CustomEmailSenderLambdaVersionType,
        CustomSMSSenderLambdaVersionType: () => CustomSMSSenderLambdaVersionType,
        DefaultEmailOptionType: () => DefaultEmailOptionType,
        DeleteGroupCommand: () => DeleteGroupCommand,
        DeleteIdentityProviderCommand: () => DeleteIdentityProviderCommand,
        DeleteResourceServerCommand: () => DeleteResourceServerCommand,
        DeleteUserAttributesCommand: () => DeleteUserAttributesCommand,
        DeleteUserAttributesRequestFilterSensitiveLog: () => DeleteUserAttributesRequestFilterSensitiveLog,
        DeleteUserCommand: () => DeleteUserCommand,
        DeleteUserPoolClientCommand: () => DeleteUserPoolClientCommand,
        DeleteUserPoolClientRequestFilterSensitiveLog: () => DeleteUserPoolClientRequestFilterSensitiveLog,
        DeleteUserPoolCommand: () => DeleteUserPoolCommand,
        DeleteUserPoolDomainCommand: () => DeleteUserPoolDomainCommand,
        DeleteUserRequestFilterSensitiveLog: () => DeleteUserRequestFilterSensitiveLog,
        DeletionProtectionType: () => DeletionProtectionType,
        DeliveryMediumType: () => DeliveryMediumType,
        DescribeIdentityProviderCommand: () => DescribeIdentityProviderCommand,
        DescribeResourceServerCommand: () => DescribeResourceServerCommand,
        DescribeRiskConfigurationCommand: () => DescribeRiskConfigurationCommand,
        DescribeRiskConfigurationRequestFilterSensitiveLog: () => DescribeRiskConfigurationRequestFilterSensitiveLog,
        DescribeRiskConfigurationResponseFilterSensitiveLog: () => DescribeRiskConfigurationResponseFilterSensitiveLog,
        DescribeUserImportJobCommand: () => DescribeUserImportJobCommand,
        DescribeUserPoolClientCommand: () => DescribeUserPoolClientCommand,
        DescribeUserPoolClientRequestFilterSensitiveLog: () => DescribeUserPoolClientRequestFilterSensitiveLog,
        DescribeUserPoolClientResponseFilterSensitiveLog: () => DescribeUserPoolClientResponseFilterSensitiveLog,
        DescribeUserPoolCommand: () => DescribeUserPoolCommand,
        DescribeUserPoolDomainCommand: () => DescribeUserPoolDomainCommand,
        DeviceRememberedStatusType: () => DeviceRememberedStatusType,
        DeviceTypeFilterSensitiveLog: () => DeviceTypeFilterSensitiveLog,
        DomainStatusType: () => DomainStatusType,
        DuplicateProviderException: () => DuplicateProviderException,
        EmailSendingAccountType: () => EmailSendingAccountType,
        EnableSoftwareTokenMFAException: () => EnableSoftwareTokenMFAException,
        EventFilterType: () => EventFilterType,
        EventResponseType: () => EventResponseType,
        EventSourceName: () => EventSourceName,
        EventType: () => EventType,
        ExpiredCodeException: () => ExpiredCodeException,
        ExplicitAuthFlowsType: () => ExplicitAuthFlowsType,
        FeedbackValueType: () => FeedbackValueType,
        ForbiddenException: () => ForbiddenException,
        ForgetDeviceCommand: () => ForgetDeviceCommand,
        ForgetDeviceRequestFilterSensitiveLog: () => ForgetDeviceRequestFilterSensitiveLog,
        ForgotPasswordCommand: () => ForgotPasswordCommand,
        ForgotPasswordRequestFilterSensitiveLog: () => ForgotPasswordRequestFilterSensitiveLog,
        GetCSVHeaderCommand: () => GetCSVHeaderCommand,
        GetDeviceCommand: () => GetDeviceCommand,
        GetDeviceRequestFilterSensitiveLog: () => GetDeviceRequestFilterSensitiveLog,
        GetDeviceResponseFilterSensitiveLog: () => GetDeviceResponseFilterSensitiveLog,
        GetGroupCommand: () => GetGroupCommand,
        GetIdentityProviderByIdentifierCommand: () => GetIdentityProviderByIdentifierCommand,
        GetLogDeliveryConfigurationCommand: () => GetLogDeliveryConfigurationCommand,
        GetSigningCertificateCommand: () => GetSigningCertificateCommand,
        GetUICustomizationCommand: () => GetUICustomizationCommand,
        GetUICustomizationRequestFilterSensitiveLog: () => GetUICustomizationRequestFilterSensitiveLog,
        GetUICustomizationResponseFilterSensitiveLog: () => GetUICustomizationResponseFilterSensitiveLog,
        GetUserAttributeVerificationCodeCommand: () => GetUserAttributeVerificationCodeCommand,
        GetUserAttributeVerificationCodeRequestFilterSensitiveLog: () => GetUserAttributeVerificationCodeRequestFilterSensitiveLog,
        GetUserCommand: () => GetUserCommand,
        GetUserPoolMfaConfigCommand: () => GetUserPoolMfaConfigCommand,
        GetUserRequestFilterSensitiveLog: () => GetUserRequestFilterSensitiveLog,
        GetUserResponseFilterSensitiveLog: () => GetUserResponseFilterSensitiveLog,
        GlobalSignOutCommand: () => GlobalSignOutCommand,
        GlobalSignOutRequestFilterSensitiveLog: () => GlobalSignOutRequestFilterSensitiveLog,
        GroupExistsException: () => GroupExistsException,
        IdentityProviderTypeType: () => IdentityProviderTypeType,
        InitiateAuthCommand: () => InitiateAuthCommand,
        InitiateAuthRequestFilterSensitiveLog: () => InitiateAuthRequestFilterSensitiveLog,
        InitiateAuthResponseFilterSensitiveLog: () => InitiateAuthResponseFilterSensitiveLog,
        InternalErrorException: () => InternalErrorException,
        InvalidEmailRoleAccessPolicyException: () => InvalidEmailRoleAccessPolicyException,
        InvalidLambdaResponseException: () => InvalidLambdaResponseException,
        InvalidOAuthFlowException: () => InvalidOAuthFlowException,
        InvalidParameterException: () => InvalidParameterException,
        InvalidPasswordException: () => InvalidPasswordException,
        InvalidSmsRoleAccessPolicyException: () => InvalidSmsRoleAccessPolicyException,
        InvalidSmsRoleTrustRelationshipException: () => InvalidSmsRoleTrustRelationshipException,
        InvalidUserPoolConfigurationException: () => InvalidUserPoolConfigurationException,
        LimitExceededException: () => LimitExceededException,
        ListDevicesCommand: () => ListDevicesCommand,
        ListDevicesRequestFilterSensitiveLog: () => ListDevicesRequestFilterSensitiveLog,
        ListDevicesResponseFilterSensitiveLog: () => ListDevicesResponseFilterSensitiveLog,
        ListGroupsCommand: () => ListGroupsCommand,
        ListIdentityProvidersCommand: () => ListIdentityProvidersCommand,
        ListResourceServersCommand: () => ListResourceServersCommand,
        ListTagsForResourceCommand: () => ListTagsForResourceCommand,
        ListUserImportJobsCommand: () => ListUserImportJobsCommand,
        ListUserPoolClientsCommand: () => ListUserPoolClientsCommand,
        ListUserPoolClientsResponseFilterSensitiveLog: () => ListUserPoolClientsResponseFilterSensitiveLog,
        ListUserPoolsCommand: () => ListUserPoolsCommand,
        ListUsersCommand: () => ListUsersCommand,
        ListUsersInGroupCommand: () => ListUsersInGroupCommand,
        ListUsersInGroupResponseFilterSensitiveLog: () => ListUsersInGroupResponseFilterSensitiveLog,
        ListUsersResponseFilterSensitiveLog: () => ListUsersResponseFilterSensitiveLog,
        LogLevel: () => LogLevel,
        MFAMethodNotFoundException: () => MFAMethodNotFoundException,
        MessageActionType: () => MessageActionType,
        NotAuthorizedException: () => NotAuthorizedException,
        OAuthFlowType: () => OAuthFlowType,
        PasswordResetRequiredException: () => PasswordResetRequiredException,
        PreconditionNotMetException: () => PreconditionNotMetException,
        PreventUserExistenceErrorTypes: () => PreventUserExistenceErrorTypes,
        RecoveryOptionNameType: () => RecoveryOptionNameType,
        ResendConfirmationCodeCommand: () => ResendConfirmationCodeCommand,
        ResendConfirmationCodeRequestFilterSensitiveLog: () => ResendConfirmationCodeRequestFilterSensitiveLog,
        ResourceNotFoundException: () => ResourceNotFoundException,
        RespondToAuthChallengeCommand: () => RespondToAuthChallengeCommand,
        RespondToAuthChallengeRequestFilterSensitiveLog: () => RespondToAuthChallengeRequestFilterSensitiveLog,
        RespondToAuthChallengeResponseFilterSensitiveLog: () => RespondToAuthChallengeResponseFilterSensitiveLog,
        RevokeTokenCommand: () => RevokeTokenCommand,
        RevokeTokenRequestFilterSensitiveLog: () => RevokeTokenRequestFilterSensitiveLog,
        RiskConfigurationTypeFilterSensitiveLog: () => RiskConfigurationTypeFilterSensitiveLog,
        RiskDecisionType: () => RiskDecisionType,
        RiskLevelType: () => RiskLevelType,
        ScopeDoesNotExistException: () => ScopeDoesNotExistException,
        SetLogDeliveryConfigurationCommand: () => SetLogDeliveryConfigurationCommand,
        SetRiskConfigurationCommand: () => SetRiskConfigurationCommand,
        SetRiskConfigurationRequestFilterSensitiveLog: () => SetRiskConfigurationRequestFilterSensitiveLog,
        SetRiskConfigurationResponseFilterSensitiveLog: () => SetRiskConfigurationResponseFilterSensitiveLog,
        SetUICustomizationCommand: () => SetUICustomizationCommand,
        SetUICustomizationRequestFilterSensitiveLog: () => SetUICustomizationRequestFilterSensitiveLog,
        SetUICustomizationResponseFilterSensitiveLog: () => SetUICustomizationResponseFilterSensitiveLog,
        SetUserMFAPreferenceCommand: () => SetUserMFAPreferenceCommand,
        SetUserMFAPreferenceRequestFilterSensitiveLog: () => SetUserMFAPreferenceRequestFilterSensitiveLog,
        SetUserPoolMfaConfigCommand: () => SetUserPoolMfaConfigCommand,
        SetUserSettingsCommand: () => SetUserSettingsCommand,
        SetUserSettingsRequestFilterSensitiveLog: () => SetUserSettingsRequestFilterSensitiveLog,
        SignUpCommand: () => SignUpCommand,
        SignUpRequestFilterSensitiveLog: () => SignUpRequestFilterSensitiveLog,
        SoftwareTokenMFANotFoundException: () => SoftwareTokenMFANotFoundException,
        StartUserImportJobCommand: () => StartUserImportJobCommand,
        StatusType: () => StatusType,
        StopUserImportJobCommand: () => StopUserImportJobCommand,
        TagResourceCommand: () => TagResourceCommand,
        TimeUnitsType: () => TimeUnitsType,
        TooManyFailedAttemptsException: () => TooManyFailedAttemptsException,
        TooManyRequestsException: () => TooManyRequestsException,
        UICustomizationTypeFilterSensitiveLog: () => UICustomizationTypeFilterSensitiveLog,
        UnauthorizedException: () => UnauthorizedException,
        UnexpectedLambdaException: () => UnexpectedLambdaException,
        UnsupportedIdentityProviderException: () => UnsupportedIdentityProviderException,
        UnsupportedOperationException: () => UnsupportedOperationException,
        UnsupportedTokenTypeException: () => UnsupportedTokenTypeException,
        UnsupportedUserStateException: () => UnsupportedUserStateException,
        UntagResourceCommand: () => UntagResourceCommand,
        UpdateAuthEventFeedbackCommand: () => UpdateAuthEventFeedbackCommand,
        UpdateAuthEventFeedbackRequestFilterSensitiveLog: () => UpdateAuthEventFeedbackRequestFilterSensitiveLog,
        UpdateDeviceStatusCommand: () => UpdateDeviceStatusCommand,
        UpdateDeviceStatusRequestFilterSensitiveLog: () => UpdateDeviceStatusRequestFilterSensitiveLog,
        UpdateGroupCommand: () => UpdateGroupCommand,
        UpdateIdentityProviderCommand: () => UpdateIdentityProviderCommand,
        UpdateResourceServerCommand: () => UpdateResourceServerCommand,
        UpdateUserAttributesCommand: () => UpdateUserAttributesCommand,
        UpdateUserAttributesRequestFilterSensitiveLog: () => UpdateUserAttributesRequestFilterSensitiveLog,
        UpdateUserPoolClientCommand: () => UpdateUserPoolClientCommand,
        UpdateUserPoolClientRequestFilterSensitiveLog: () => UpdateUserPoolClientRequestFilterSensitiveLog,
        UpdateUserPoolClientResponseFilterSensitiveLog: () => UpdateUserPoolClientResponseFilterSensitiveLog,
        UpdateUserPoolCommand: () => UpdateUserPoolCommand,
        UpdateUserPoolDomainCommand: () => UpdateUserPoolDomainCommand,
        UserContextDataTypeFilterSensitiveLog: () => UserContextDataTypeFilterSensitiveLog,
        UserImportInProgressException: () => UserImportInProgressException,
        UserImportJobStatusType: () => UserImportJobStatusType,
        UserLambdaValidationException: () => UserLambdaValidationException,
        UserNotConfirmedException: () => UserNotConfirmedException,
        UserNotFoundException: () => UserNotFoundException,
        UserPoolAddOnNotEnabledException: () => UserPoolAddOnNotEnabledException,
        UserPoolClientDescriptionFilterSensitiveLog: () => UserPoolClientDescriptionFilterSensitiveLog,
        UserPoolClientTypeFilterSensitiveLog: () => UserPoolClientTypeFilterSensitiveLog,
        UserPoolMfaType: () => UserPoolMfaType,
        UserPoolTaggingException: () => UserPoolTaggingException,
        UserStatusType: () => UserStatusType,
        UserTypeFilterSensitiveLog: () => UserTypeFilterSensitiveLog,
        UsernameAttributeType: () => UsernameAttributeType,
        UsernameExistsException: () => UsernameExistsException,
        VerifiedAttributeType: () => VerifiedAttributeType,
        VerifySoftwareTokenCommand: () => VerifySoftwareTokenCommand,
        VerifySoftwareTokenRequestFilterSensitiveLog: () => VerifySoftwareTokenRequestFilterSensitiveLog,
        VerifySoftwareTokenResponseFilterSensitiveLog: () => VerifySoftwareTokenResponseFilterSensitiveLog,
        VerifySoftwareTokenResponseType: () => VerifySoftwareTokenResponseType,
        VerifyUserAttributeCommand: () => VerifyUserAttributeCommand,
        VerifyUserAttributeRequestFilterSensitiveLog: () => VerifyUserAttributeRequestFilterSensitiveLog,
        __Client: () => Client,
        paginateAdminListGroupsForUser: () => paginateAdminListGroupsForUser,
        paginateAdminListUserAuthEvents: () => paginateAdminListUserAuthEvents,
        paginateListGroups: () => paginateListGroups,
        paginateListIdentityProviders: () => paginateListIdentityProviders,
        paginateListResourceServers: () => paginateListResourceServers,
        paginateListUserPoolClients: () => paginateListUserPoolClients,
        paginateListUserPools: () => paginateListUserPools,
        paginateListUsers: () => paginateListUsers,
        paginateListUsersInGroup: () => paginateListUsersInGroup
      });
      var aws_namespaceObject = {};
      __webpack_require__.r(aws_namespaceObject);
      __webpack_require__.d(aws_namespaceObject, {
        getUserAgentPrefix: () => getUserAgentPrefix,
        isVirtualHostableS3Bucket: () => isVirtualHostableS3Bucket,
        parseArn: () => parseArn,
        partition: () => partition,
        setPartitionInfo: () => setPartitionInfo,
        useDefaultPartitionInfo: () => useDefaultPartitionInfo
      });
      var lib_namespaceObject = {};
      __webpack_require__.r(lib_namespaceObject);
      __webpack_require__.d(lib_namespaceObject, {
        aws: () => aws_namespaceObject,
        booleanEquals: () => booleanEquals,
        getAttr: () => getAttr,
        isSet: () => isSet,
        isValidHostLabel: () => isValidHostLabel,
        not: () => not,
        parseURL: () => parseURL,
        stringEquals: () => stringEquals,
        substring: () => substring,
        uriEncode: () => uriEncode
      });
      ;
      const getHttpHandlerExtensionConfiguration = runtimeConfig => {
        let httpHandler = runtimeConfig.httpHandler;
        return {
          setHttpHandler(handler) {
            httpHandler = handler;
          },
          httpHandler() {
            return httpHandler;
          },
          updateHttpClientConfig(key, value) {
            httpHandler.updateHttpClientConfig(key, value);
          },
          httpHandlerConfigs() {
            return httpHandler.httpHandlerConfigs();
          }
        };
      };
      const resolveHttpHandlerRuntimeConfig = httpHandlerExtensionConfiguration => {
        return {
          httpHandler: httpHandlerExtensionConfiguration.httpHandler()
        };
      };
      ;
      ;
      var HttpAuthLocation;
      (function (HttpAuthLocation) {
        HttpAuthLocation["HEADER"] = "header";
        HttpAuthLocation["QUERY"] = "query";
      })(HttpAuthLocation || (HttpAuthLocation = {}));
      ;
      var EndpointURLScheme;
      (function (EndpointURLScheme) {
        EndpointURLScheme["HTTP"] = "http";
        EndpointURLScheme["HTTPS"] = "https";
      })(EndpointURLScheme || (EndpointURLScheme = {}));
      ;
      var AlgorithmId;
      (function (AlgorithmId) {
        AlgorithmId["MD5"] = "md5";
        AlgorithmId["CRC32"] = "crc32";
        AlgorithmId["CRC32C"] = "crc32c";
        AlgorithmId["SHA1"] = "sha1";
        AlgorithmId["SHA256"] = "sha256";
      })(AlgorithmId || (AlgorithmId = {}));
      const checksum_getChecksumConfiguration = runtimeConfig => {
        const checksumAlgorithms = [];
        if (runtimeConfig.sha256 !== undefined) {
          checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256
          });
        }
        if (runtimeConfig.md5 != undefined) {
          checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5
          });
        }
        return {
          _checksumAlgorithms: checksumAlgorithms,
          addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
          },
          checksumAlgorithms() {
            return this._checksumAlgorithms;
          }
        };
      };
      const checksum_resolveChecksumRuntimeConfig = clientConfig => {
        const runtimeConfig = {};
        clientConfig.checksumAlgorithms().forEach(checksumAlgorithm => {
          runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
        });
        return runtimeConfig;
      };
      ;
      const getDefaultClientConfiguration = runtimeConfig => {
        return {
          ...getChecksumConfiguration(runtimeConfig)
        };
      };
      const resolveDefaultRuntimeConfig = config => {
        return {
          ...resolveChecksumRuntimeConfig(config)
        };
      };
      ;
      ;
      var http_FieldPosition;
      (function (FieldPosition) {
        FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
        FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
      })(http_FieldPosition || (http_FieldPosition = {}));
      ;
      var RequestHandlerProtocol;
      (function (RequestHandlerProtocol) {
        RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
        RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
        RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
      })(RequestHandlerProtocol || (RequestHandlerProtocol = {}));
      ;
      ;
      class Field {
        constructor({
          name,
          kind = FieldPosition.HEADER,
          values = []
        }) {
          this.name = name;
          this.kind = kind;
          this.values = values;
        }
        add(value) {
          this.values.push(value);
        }
        set(values) {
          this.values = values;
        }
        remove(value) {
          this.values = this.values.filter(v => v !== value);
        }
        toString() {
          return this.values.map(v => v.includes(",") || v.includes(" ") ? `"${v}"` : v).join(", ");
        }
        get() {
          return this.values;
        }
      }
      ;
      class httpRequest_HttpRequest {
        constructor(options) {
          this.method = options.method || "GET";
          this.hostname = options.hostname || "localhost";
          this.port = options.port;
          this.query = options.query || {};
          this.headers = options.headers || {};
          this.body = options.body;
          this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
          this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
          this.username = options.username;
          this.password = options.password;
          this.fragment = options.fragment;
        }
        static isInstance(request) {
          if (!request) return false;
          const req = request;
          return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
        }
        clone() {
          const cloned = new httpRequest_HttpRequest({
            ...this,
            headers: {
              ...this.headers
            }
          });
          if (cloned.query) cloned.query = cloneQuery(cloned.query);
          return cloned;
        }
      }
      function cloneQuery(query) {
        return Object.keys(query).reduce((carry, paramName) => {
          const param = query[paramName];
          return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param
          };
        }, {});
      }
      ;
      class httpResponse_HttpResponse {
        constructor(options) {
          this.statusCode = options.statusCode;
          this.reason = options.reason;
          this.headers = options.headers || {};
          this.body = options.body;
        }
        static isInstance(response) {
          if (!response) return false;
          const resp = response;
          return typeof resp.statusCode === "number" && typeof resp.headers === "object";
        }
      }
      ;
      ;
      function resolveHostHeaderConfig(input) {
        return input;
      }
      const hostHeaderMiddleware = options => next => async args => {
        if (!httpRequest_HttpRequest.isInstance(args.request)) return next(args);
        const {
          request
        } = args;
        const {
          handlerProtocol = ""
        } = options.requestHandler.metadata || {};
        if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
          delete request.headers["host"];
          request.headers[":authority"] = "";
        } else if (!request.headers["host"]) {
          let host = request.hostname;
          if (request.port != null) host += `:${request.port}`;
          request.headers["host"] = host;
        }
        return next(args);
      };
      const hostHeaderMiddlewareOptions = {
        name: "hostHeaderMiddleware",
        step: "build",
        priority: "low",
        tags: ["HOST"],
        override: true
      };
      const getHostHeaderPlugin = options => ({
        applyToStack: clientStack => {
          clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
        }
      });
      ;
      const loggerMiddleware = () => (next, context) => async args => {
        try {
          const response = await next(args);
          const {
            clientName,
            commandName,
            logger,
            dynamoDbDocumentClientOptions = {}
          } = context;
          const {
            overrideInputFilterSensitiveLog,
            overrideOutputFilterSensitiveLog
          } = dynamoDbDocumentClientOptions;
          const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
          const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
          const {
            $metadata,
            ...outputWithoutMetadata
          } = response.output;
          logger?.info?.({
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            output: outputFilterSensitiveLog(outputWithoutMetadata),
            metadata: $metadata
          });
          return response;
        } catch (error) {
          const {
            clientName,
            commandName,
            logger,
            dynamoDbDocumentClientOptions = {}
          } = context;
          const {
            overrideInputFilterSensitiveLog
          } = dynamoDbDocumentClientOptions;
          const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
          logger?.error?.({
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            error,
            metadata: error.$metadata
          });
          throw error;
        }
      };
      const loggerMiddlewareOptions = {
        name: "loggerMiddleware",
        tags: ["LOGGER"],
        step: "initialize",
        override: true
      };
      const getLoggerPlugin = options => ({
        applyToStack: clientStack => {
          clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
        }
      });
      ;
      ;
      const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
      const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
      const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
      const recursionDetectionMiddleware = options => next => async args => {
        const {
          request
        } = args;
        if (!httpRequest_HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
          return next(args);
        }
        const functionName = {
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        }.env[ENV_LAMBDA_FUNCTION_NAME];
        const traceId = {
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        }.env[ENV_TRACE_ID];
        const nonEmptyString = str => typeof str === "string" && str.length > 0;
        if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
          request.headers[TRACE_ID_HEADER_NAME] = traceId;
        }
        return next({
          ...args,
          request
        });
      };
      const addRecursionDetectionMiddlewareOptions = {
        step: "build",
        tags: ["RECURSION_DETECTION"],
        name: "recursionDetectionMiddleware",
        override: true,
        priority: "low"
      };
      const getRecursionDetectionPlugin = options => ({
        applyToStack: clientStack => {
          clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
        }
      });
      ;
      const memoize = (provider, isExpired, requiresRefresh) => {
        let resolved;
        let pending;
        let hasResult;
        let isConstant = false;
        const coalesceProvider = async () => {
          if (!pending) {
            pending = provider();
          }
          try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
          } finally {
            pending = undefined;
          }
          return resolved;
        };
        if (isExpired === undefined) {
          return async options => {
            if (!hasResult || options?.forceRefresh) {
              resolved = await coalesceProvider();
            }
            return resolved;
          };
        }
        return async options => {
          if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
          }
          if (isConstant) {
            return resolved;
          }
          if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
          }
          if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
          }
          return resolved;
        };
      };
      var build = __webpack_require__(2492);
      ;
      const SHORT_TO_HEX = {};
      const HEX_TO_SHORT = {};
      for (let i = 0; i < 256; i++) {
        let encodedByte = i.toString(16).toLowerCase();
        if (encodedByte.length === 1) {
          encodedByte = `0${encodedByte}`;
        }
        SHORT_TO_HEX[i] = encodedByte;
        HEX_TO_SHORT[encodedByte] = i;
      }
      function fromHex(encoded) {
        if (encoded.length % 2 !== 0) {
          throw new Error("Hex encoded strings must have an even number length");
        }
        const out = new Uint8Array(encoded.length / 2);
        for (let i = 0; i < encoded.length; i += 2) {
          const encodedByte = encoded.slice(i, i + 2).toLowerCase();
          if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
          } else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
          }
        }
        return out;
      }
      function dist_es_toHex(bytes) {
        let out = "";
        for (let i = 0; i < bytes.byteLength; i++) {
          out += SHORT_TO_HEX[bytes[i]];
        }
        return out;
      }
      ;
      class Int64 {
        constructor(bytes) {
          this.bytes = bytes;
          if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
          }
        }
        static fromNumber(number) {
          if (number > 9223372036854776000 || number < -9223372036854776000) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
          }
          const bytes = new Uint8Array(8);
          for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
            bytes[i] = remaining;
          }
          if (number < 0) {
            negate(bytes);
          }
          return new Int64(bytes);
        }
        valueOf() {
          const bytes = this.bytes.slice(0);
          const negative = bytes[0] & 0b10000000;
          if (negative) {
            negate(bytes);
          }
          return parseInt(dist_es_toHex(bytes), 16) * (negative ? -1 : 1);
        }
        toString() {
          return String(this.valueOf());
        }
      }
      function negate(bytes) {
        for (let i = 0; i < 8; i++) {
          bytes[i] ^= 0xff;
        }
        for (let i = 7; i > -1; i--) {
          bytes[i]++;
          if (bytes[i] !== 0) break;
        }
      }
      ;
      class HeaderMarshaller_HeaderMarshaller {
        constructor(toUtf8, fromUtf8) {
          this.toUtf8 = toUtf8;
          this.fromUtf8 = fromUtf8;
        }
        format(headers) {
          const chunks = [];
          for (const headerName of Object.keys(headers)) {
            const bytes = this.fromUtf8(headerName);
            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
          }
          const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
          let position = 0;
          for (const chunk of chunks) {
            out.set(chunk, position);
            position += chunk.byteLength;
          }
          return out;
        }
        formatHeaderValue(header) {
          switch (header.type) {
            case "boolean":
              return Uint8Array.from([header.value ? 0 : 1]);
            case "byte":
              return Uint8Array.from([2, header.value]);
            case "short":
              const shortView = new DataView(new ArrayBuffer(3));
              shortView.setUint8(0, 3);
              shortView.setInt16(1, header.value, false);
              return new Uint8Array(shortView.buffer);
            case "integer":
              const intView = new DataView(new ArrayBuffer(5));
              intView.setUint8(0, 4);
              intView.setInt32(1, header.value, false);
              return new Uint8Array(intView.buffer);
            case "long":
              const longBytes = new Uint8Array(9);
              longBytes[0] = 5;
              longBytes.set(header.value.bytes, 1);
              return longBytes;
            case "binary":
              const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
              binView.setUint8(0, 6);
              binView.setUint16(1, header.value.byteLength, false);
              const binBytes = new Uint8Array(binView.buffer);
              binBytes.set(header.value, 3);
              return binBytes;
            case "string":
              const utf8Bytes = this.fromUtf8(header.value);
              const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
              strView.setUint8(0, 7);
              strView.setUint16(1, utf8Bytes.byteLength, false);
              const strBytes = new Uint8Array(strView.buffer);
              strBytes.set(utf8Bytes, 3);
              return strBytes;
            case "timestamp":
              const tsBytes = new Uint8Array(9);
              tsBytes[0] = 8;
              tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
              return tsBytes;
            case "uuid":
              if (!UUID_PATTERN.test(header.value)) {
                throw new Error(`Invalid UUID received: ${header.value}`);
              }
              const uuidBytes = new Uint8Array(17);
              uuidBytes[0] = 9;
              uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
              return uuidBytes;
          }
        }
        parse(headers) {
          const out = {};
          let position = 0;
          while (position < headers.byteLength) {
            const nameLength = headers.getUint8(position++);
            const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
            position += nameLength;
            switch (headers.getUint8(position++)) {
              case 0:
                out[name] = {
                  type: BOOLEAN_TAG,
                  value: true
                };
                break;
              case 1:
                out[name] = {
                  type: BOOLEAN_TAG,
                  value: false
                };
                break;
              case 2:
                out[name] = {
                  type: BYTE_TAG,
                  value: headers.getInt8(position++)
                };
                break;
              case 3:
                out[name] = {
                  type: SHORT_TAG,
                  value: headers.getInt16(position, false)
                };
                position += 2;
                break;
              case 4:
                out[name] = {
                  type: INT_TAG,
                  value: headers.getInt32(position, false)
                };
                position += 4;
                break;
              case 5:
                out[name] = {
                  type: LONG_TAG,
                  value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
                };
                position += 8;
                break;
              case 6:
                const binaryLength = headers.getUint16(position, false);
                position += 2;
                out[name] = {
                  type: BINARY_TAG,
                  value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
                };
                position += binaryLength;
                break;
              case 7:
                const stringLength = headers.getUint16(position, false);
                position += 2;
                out[name] = {
                  type: STRING_TAG,
                  value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
                };
                position += stringLength;
                break;
              case 8:
                out[name] = {
                  type: TIMESTAMP_TAG,
                  value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
                };
                position += 8;
                break;
              case 9:
                const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
                position += 16;
                out[name] = {
                  type: UUID_TAG,
                  value: `${dist_es_toHex(uuidBytes.subarray(0, 4))}-${dist_es_toHex(uuidBytes.subarray(4, 6))}-${dist_es_toHex(uuidBytes.subarray(6, 8))}-${dist_es_toHex(uuidBytes.subarray(8, 10))}-${dist_es_toHex(uuidBytes.subarray(10))}`
                };
                break;
              default:
                throw new Error(`Unrecognized header type tag`);
            }
          }
          return out;
        }
      }
      var HEADER_VALUE_TYPE;
      (function (HEADER_VALUE_TYPE) {
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
      })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
      const BOOLEAN_TAG = "boolean";
      const BYTE_TAG = "byte";
      const SHORT_TAG = "short";
      const INT_TAG = "integer";
      const LONG_TAG = "long";
      const BINARY_TAG = "binary";
      const STRING_TAG = "string";
      const TIMESTAMP_TAG = "timestamp";
      const UUID_TAG = "uuid";
      const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
      ;
      const PRELUDE_MEMBER_LENGTH = 4;
      const PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
      const CHECKSUM_LENGTH = 4;
      const MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
      function splitMessage_splitMessage({
        byteLength,
        byteOffset,
        buffer
      }) {
        if (byteLength < MINIMUM_MESSAGE_LENGTH) {
          throw new Error("Provided message too short to accommodate event stream message overhead");
        }
        const view = new DataView(buffer, byteOffset, byteLength);
        const messageLength = view.getUint32(0, false);
        if (byteLength !== messageLength) {
          throw new Error("Reported message length does not match received message length");
        }
        const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
        const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
        const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
        const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
        if (expectedPreludeChecksum !== checksummer.digest()) {
          throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
        }
        checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
        if (expectedMessageChecksum !== checksummer.digest()) {
          throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
        }
        return {
          headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
          body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
        };
      }
      ;
      class EventStreamCodec {
        constructor(toUtf8, fromUtf8) {
          this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);
          this.messageBuffer = [];
          this.isEndOfStream = false;
        }
        feed(message) {
          this.messageBuffer.push(this.decode(message));
        }
        endOfStream() {
          this.isEndOfStream = true;
        }
        getMessage() {
          const message = this.messageBuffer.pop();
          const isEndOfStream = this.isEndOfStream;
          return {
            getMessage() {
              return message;
            },
            isEndOfStream() {
              return isEndOfStream;
            }
          };
        }
        getAvailableMessages() {
          const messages = this.messageBuffer;
          this.messageBuffer = [];
          const isEndOfStream = this.isEndOfStream;
          return {
            getMessages() {
              return messages;
            },
            isEndOfStream() {
              return isEndOfStream;
            }
          };
        }
        encode({
          headers: rawHeaders,
          body
        }) {
          const headers = this.headerMarshaller.format(rawHeaders);
          const length = headers.byteLength + body.byteLength + 16;
          const out = new Uint8Array(length);
          const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
          const checksum = new Crc32();
          view.setUint32(0, length, false);
          view.setUint32(4, headers.byteLength, false);
          view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
          out.set(headers, 12);
          out.set(body, headers.byteLength + 12);
          view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
          return out;
        }
        decode(message) {
          const {
            headers,
            body
          } = splitMessage(message);
          return {
            headers: this.headerMarshaller.parse(headers),
            body
          };
        }
        formatHeaders(rawHeaders) {
          return this.headerMarshaller.format(rawHeaders);
        }
      }
      ;
      class MessageDecoderStream {
        constructor(options) {
          this.options = options;
        }
        [Symbol.asyncIterator]() {
          return this.asyncIterator();
        }
        async *asyncIterator() {
          for await (const bytes of this.options.inputStream) {
            const decoded = this.options.decoder.decode(bytes);
            yield decoded;
          }
        }
      }
      ;
      class MessageEncoderStream {
        constructor(options) {
          this.options = options;
        }
        [Symbol.asyncIterator]() {
          return this.asyncIterator();
        }
        async *asyncIterator() {
          for await (const msg of this.options.messageStream) {
            const encoded = this.options.encoder.encode(msg);
            yield encoded;
          }
          if (this.options.includeEndFrame) {
            yield new Uint8Array(0);
          }
        }
      }
      ;
      class SmithyMessageDecoderStream {
        constructor(options) {
          this.options = options;
        }
        [Symbol.asyncIterator]() {
          return this.asyncIterator();
        }
        async *asyncIterator() {
          for await (const message of this.options.messageStream) {
            const deserialized = await this.options.deserializer(message);
            if (deserialized === undefined) continue;
            yield deserialized;
          }
        }
      }
      ;
      class SmithyMessageEncoderStream {
        constructor(options) {
          this.options = options;
        }
        [Symbol.asyncIterator]() {
          return this.asyncIterator();
        }
        async *asyncIterator() {
          for await (const chunk of this.options.inputStream) {
            const payloadBuf = this.options.serializer(chunk);
            yield payloadBuf;
          }
        }
      }
      ;
      ;
      const normalizeProvider_normalizeProvider = input => {
        if (typeof input === "function") return input;
        const promisified = Promise.resolve(input);
        return () => promisified;
      };
      ;
      const toUtf8_browser_toUtf8 = input => new TextDecoder("utf-8").decode(input);
      ;
      const fromUtf8 = input => new TextEncoder().encode(input);
      ;
      const toUint8Array = data => {
        if (typeof data === "string") {
          return fromUtf8(data);
        }
        if (ArrayBuffer.isView(data)) {
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
      };
      ;
      const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
      const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
      const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
      const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
      const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
      const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
      const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
      const REGION_SET_PARAM = "X-Amz-Region-Set";
      const AUTH_HEADER = "authorization";
      const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
      const DATE_HEADER = "date";
      const GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
      const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
      const SHA256_HEADER = "x-amz-content-sha256";
      const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
      const HOST_HEADER = "host";
      const ALWAYS_UNSIGNABLE_HEADERS = {
        authorization: true,
        "cache-control": true,
        connection: true,
        expect: true,
        from: true,
        "keep-alive": true,
        "max-forwards": true,
        pragma: true,
        referer: true,
        te: true,
        trailer: true,
        "transfer-encoding": true,
        upgrade: true,
        "user-agent": true,
        "x-amzn-trace-id": true
      };
      const PROXY_HEADER_PATTERN = /^proxy-/;
      const SEC_HEADER_PATTERN = /^sec-/;
      const UNSIGNABLE_PATTERNS = null && [/^proxy-/i, /^sec-/i];
      const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
      const ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
      const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
      const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
      const MAX_CACHE_SIZE = 50;
      const KEY_TYPE_IDENTIFIER = "aws4_request";
      const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
      ;
      const signingKeyCache = {};
      const cacheQueue = [];
      const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
      const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
        const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
        const cacheKey = `${shortDate}:${region}:${service}:${dist_es_toHex(credsHash)}:${credentials.sessionToken}`;
        if (cacheKey in signingKeyCache) {
          return signingKeyCache[cacheKey];
        }
        cacheQueue.push(cacheKey);
        while (cacheQueue.length > MAX_CACHE_SIZE) {
          delete signingKeyCache[cacheQueue.shift()];
        }
        let key = `AWS4${credentials.secretAccessKey}`;
        for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
          key = await hmac(sha256Constructor, key, signable);
        }
        return signingKeyCache[cacheKey] = key;
      };
      const clearCredentialCache = () => {
        cacheQueue.length = 0;
        Object.keys(signingKeyCache).forEach(cacheKey => {
          delete signingKeyCache[cacheKey];
        });
      };
      const hmac = (ctor, secret, data) => {
        const hash = new ctor(secret);
        hash.update(toUint8Array(data));
        return hash.digest();
      };
      ;
      const getCanonicalHeaders = ({
        headers
      }, unsignableHeaders, signableHeaders) => {
        const canonical = {};
        for (const headerName of Object.keys(headers).sort()) {
          if (headers[headerName] == undefined) {
            continue;
          }
          const canonicalHeaderName = headerName.toLowerCase();
          if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
            if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
              continue;
            }
          }
          canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
        }
        return canonical;
      };
      ;
      const escapeUri = uri => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
      const hexEncode = c => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;
      ;
      const getCanonicalQuery = ({
        query = {}
      }) => {
        const keys = [];
        const serialized = {};
        for (const key of Object.keys(query).sort()) {
          if (key.toLowerCase() === SIGNATURE_HEADER) {
            continue;
          }
          keys.push(key);
          const value = query[key];
          if (typeof value === "string") {
            serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
          } else if (Array.isArray(value)) {
            serialized[key] = value.slice(0).reduce((encoded, value) => encoded.concat([`${escapeUri(key)}=${escapeUri(value)}`]), []).sort().join("&");
          }
        }
        return keys.map(key => serialized[key]).filter(serialized => serialized).join("&");
      };
      ;
      const isArrayBuffer = arg => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
      ;
      const getPayloadHash = async ({
        headers,
        body
      }, hashConstructor) => {
        for (const headerName of Object.keys(headers)) {
          if (headerName.toLowerCase() === SHA256_HEADER) {
            return headers[headerName];
          }
        }
        if (body == undefined) {
          return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
        } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
          const hashCtor = new hashConstructor();
          hashCtor.update(toUint8Array(body));
          return dist_es_toHex(await hashCtor.digest());
        }
        return UNSIGNED_PAYLOAD;
      };
      ;
      const hasHeader = (soughtHeader, headers) => {
        soughtHeader = soughtHeader.toLowerCase();
        for (const headerName of Object.keys(headers)) {
          if (soughtHeader === headerName.toLowerCase()) {
            return true;
          }
        }
        return false;
      };
      const getHeaderValue = (soughtHeader, headers) => {
        soughtHeader = soughtHeader.toLowerCase();
        for (const headerName of Object.keys(headers)) {
          if (soughtHeader === headerName.toLowerCase()) {
            return headers[headerName];
          }
        }
        return undefined;
      };
      const deleteHeader = (soughtHeader, headers) => {
        soughtHeader = soughtHeader.toLowerCase();
        for (const headerName of Object.keys(headers)) {
          if (soughtHeader === headerName.toLowerCase()) {
            delete headers[headerName];
          }
        }
      };
      ;
      const cloneRequest = ({
        headers,
        query,
        ...rest
      }) => ({
        ...rest,
        headers: {
          ...headers
        },
        query: query ? cloneRequest_cloneQuery(query) : undefined
      });
      const cloneRequest_cloneQuery = query => Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
          ...carry,
          [paramName]: Array.isArray(param) ? [...param] : param
        };
      }, {});
      ;
      const moveHeadersToQuery = (request, options = {}) => {
        const {
          headers,
          query = {}
        } = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
        for (const name of Object.keys(headers)) {
          const lname = name.toLowerCase();
          if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
            query[name] = headers[name];
            delete headers[name];
          }
        }
        return {
          ...request,
          headers,
          query
        };
      };
      ;
      const prepareRequest = request => {
        request = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
        for (const headerName of Object.keys(request.headers)) {
          if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
            delete request.headers[headerName];
          }
        }
        return request;
      };
      ;
      const iso8601 = time => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z");
      const toDate = time => {
        if (typeof time === "number") {
          return new Date(time * 1000);
        }
        if (typeof time === "string") {
          if (Number(time)) {
            return new Date(Number(time) * 1000);
          }
          return new Date(time);
        }
        return time;
      };
      ;
      class SignatureV4_SignatureV4 {
        constructor({
          applyChecksum,
          credentials,
          region,
          service,
          sha256,
          uriEscapePath = true
        }) {
          this.headerMarshaller = new HeaderMarshaller_HeaderMarshaller(toUtf8_browser_toUtf8, fromUtf8);
          this.service = service;
          this.sha256 = sha256;
          this.uriEscapePath = uriEscapePath;
          this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
          this.regionProvider = normalizeProvider_normalizeProvider(region);
          this.credentialProvider = normalizeProvider_normalizeProvider(credentials);
        }
        async presign(originalRequest, options = {}) {
          const {
            signingDate = new Date(),
            expiresIn = 3600,
            unsignableHeaders,
            unhoistableHeaders,
            signableHeaders,
            signingRegion,
            signingService
          } = options;
          const credentials = await this.credentialProvider();
          this.validateResolvedCredentials(credentials);
          const region = signingRegion ?? (await this.regionProvider());
          const {
            longDate,
            shortDate
          } = formatDate(signingDate);
          if (expiresIn > MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
          }
          const scope = createScope(shortDate, region, signingService ?? this.service);
          const request = moveHeadersToQuery(prepareRequest(originalRequest), {
            unhoistableHeaders
          });
          if (credentials.sessionToken) {
            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
          }
          request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
          request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
          request.query[AMZ_DATE_QUERY_PARAM] = longDate;
          request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
          const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
          request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
          request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
          return request;
        }
        async sign(toSign, options) {
          if (typeof toSign === "string") {
            return this.signString(toSign, options);
          } else if (toSign.headers && toSign.payload) {
            return this.signEvent(toSign, options);
          } else if (toSign.message) {
            return this.signMessage(toSign, options);
          } else {
            return this.signRequest(toSign, options);
          }
        }
        async signEvent({
          headers,
          payload
        }, {
          signingDate = new Date(),
          priorSignature,
          signingRegion,
          signingService
        }) {
          const region = signingRegion ?? (await this.regionProvider());
          const {
            shortDate,
            longDate
          } = formatDate(signingDate);
          const scope = createScope(shortDate, region, signingService ?? this.service);
          const hashedPayload = await getPayloadHash({
            headers: {},
            body: payload
          }, this.sha256);
          const hash = new this.sha256();
          hash.update(headers);
          const hashedHeaders = dist_es_toHex(await hash.digest());
          const stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join("\n");
          return this.signString(stringToSign, {
            signingDate,
            signingRegion: region,
            signingService
          });
        }
        async signMessage(signableMessage, {
          signingDate = new Date(),
          signingRegion,
          signingService
        }) {
          const promise = this.signEvent({
            headers: this.headerMarshaller.format(signableMessage.message.headers),
            payload: signableMessage.message.body
          }, {
            signingDate,
            signingRegion,
            signingService,
            priorSignature: signableMessage.priorSignature
          });
          return promise.then(signature => {
            return {
              message: signableMessage.message,
              signature
            };
          });
        }
        async signString(stringToSign, {
          signingDate = new Date(),
          signingRegion,
          signingService
        } = {}) {
          const credentials = await this.credentialProvider();
          this.validateResolvedCredentials(credentials);
          const region = signingRegion ?? (await this.regionProvider());
          const {
            shortDate
          } = formatDate(signingDate);
          const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
          hash.update(toUint8Array(stringToSign));
          return dist_es_toHex(await hash.digest());
        }
        async signRequest(requestToSign, {
          signingDate = new Date(),
          signableHeaders,
          unsignableHeaders,
          signingRegion,
          signingService
        } = {}) {
          const credentials = await this.credentialProvider();
          this.validateResolvedCredentials(credentials);
          const region = signingRegion ?? (await this.regionProvider());
          const request = prepareRequest(requestToSign);
          const {
            longDate,
            shortDate
          } = formatDate(signingDate);
          const scope = createScope(shortDate, region, signingService ?? this.service);
          request.headers[AMZ_DATE_HEADER] = longDate;
          if (credentials.sessionToken) {
            request.headers[TOKEN_HEADER] = credentials.sessionToken;
          }
          const payloadHash = await getPayloadHash(request, this.sha256);
          if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[SHA256_HEADER] = payloadHash;
          }
          const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
          const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
          request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;
          return request;
        }
        createCanonicalRequest(request, canonicalHeaders, payloadHash) {
          const sortedHeaders = Object.keys(canonicalHeaders).sort();
          return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map(name => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
        }
        async createStringToSign(longDate, credentialScope, canonicalRequest) {
          const hash = new this.sha256();
          hash.update(toUint8Array(canonicalRequest));
          const hashedRequest = await hash.digest();
          return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${dist_es_toHex(hashedRequest)}`;
        }
        getCanonicalPath({
          path
        }) {
          if (this.uriEscapePath) {
            const normalizedPathSegments = [];
            for (const pathSegment of path.split("/")) {
              if (pathSegment?.length === 0) continue;
              if (pathSegment === ".") continue;
              if (pathSegment === "..") {
                normalizedPathSegments.pop();
              } else {
                normalizedPathSegments.push(pathSegment);
              }
            }
            const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
            const doubleEncoded = encodeURIComponent(normalizedPath);
            return doubleEncoded.replace(/%2F/g, "/");
          }
          return path;
        }
        async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
          const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
          const hash = new this.sha256(await keyPromise);
          hash.update(toUint8Array(stringToSign));
          return dist_es_toHex(await hash.digest());
        }
        getSigningKey(credentials, region, shortDate, service) {
          return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
        }
        validateResolvedCredentials(credentials) {
          if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
            throw new Error("Resolved credential object is not valid");
          }
        }
      }
      const formatDate = now => {
        const longDate = iso8601(now).replace(/[\-:]/g, "");
        return {
          longDate,
          shortDate: longDate.slice(0, 8)
        };
      };
      const getCanonicalHeaderList = headers => Object.keys(headers).sort().join(";");
      ;
      ;
      const CREDENTIAL_EXPIRE_WINDOW = 300000;
      const resolveAwsAuthConfig = input => {
        const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
        const {
          signingEscapePath = true,
          systemClockOffset = input.systemClockOffset || 0,
          sha256
        } = input;
        let signer;
        if (input.signer) {
          signer = normalizeProvider_normalizeProvider(input.signer);
        } else if (input.regionInfoProvider) {
          signer = () => normalizeProvider_normalizeProvider(input.region)().then(async region => [(await input.regionInfoProvider(region, {
            useFipsEndpoint: await input.useFipsEndpoint(),
            useDualstackEndpoint: await input.useDualstackEndpoint()
          })) || {}, region]).then(([regionInfo, region]) => {
            const {
              signingRegion,
              signingService
            } = regionInfo;
            input.signingRegion = input.signingRegion || signingRegion || region;
            input.signingName = input.signingName || signingService || input.serviceId;
            const params = {
              ...input,
              credentials: normalizedCreds,
              region: input.signingRegion,
              service: input.signingName,
              sha256,
              uriEscapePath: signingEscapePath
            };
            const SignerCtor = input.signerConstructor || SignatureV4_SignatureV4;
            return new SignerCtor(params);
          });
        } else {
          signer = async authScheme => {
            authScheme = Object.assign({}, {
              name: "sigv4",
              signingName: input.signingName || input.defaultSigningName,
              signingRegion: await normalizeProvider_normalizeProvider(input.region)(),
              properties: {}
            }, authScheme);
            const signingRegion = authScheme.signingRegion;
            const signingService = authScheme.signingName;
            input.signingRegion = input.signingRegion || signingRegion;
            input.signingName = input.signingName || signingService || input.serviceId;
            const params = {
              ...input,
              credentials: normalizedCreds,
              region: input.signingRegion,
              service: input.signingName,
              sha256,
              uriEscapePath: signingEscapePath
            };
            const SignerCtor = input.signerConstructor || SignatureV4_SignatureV4;
            return new SignerCtor(params);
          };
        }
        return {
          ...input,
          systemClockOffset,
          signingEscapePath,
          credentials: normalizedCreds,
          signer
        };
      };
      const resolveSigV4AuthConfig = input => {
        const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
        const {
          signingEscapePath = true,
          systemClockOffset = input.systemClockOffset || 0,
          sha256
        } = input;
        let signer;
        if (input.signer) {
          signer = normalizeProvider(input.signer);
        } else {
          signer = normalizeProvider(new SignatureV4({
            credentials: normalizedCreds,
            region: input.region,
            service: input.signingName,
            sha256,
            uriEscapePath: signingEscapePath
          }));
        }
        return {
          ...input,
          systemClockOffset,
          signingEscapePath,
          credentials: normalizedCreds,
          signer
        };
      };
      const normalizeCredentialProvider = credentials => {
        if (typeof credentials === "function") {
          return memoize(credentials, credentials => credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, credentials => credentials.expiration !== undefined);
        }
        return normalizeProvider_normalizeProvider(credentials);
      };
      ;
      const getSkewCorrectedDate = systemClockOffset => new Date(Date.now() + systemClockOffset);
      ;
      const isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000;
      ;
      const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
        const clockTimeInMs = Date.parse(clockTime);
        if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
          return clockTimeInMs - Date.now();
        }
        return currentSystemClockOffset;
      };
      ;
      const awsAuthMiddleware = options => (next, context) => async function (args) {
        if (!httpRequest_HttpRequest.isInstance(args.request)) return next(args);
        const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
        const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : undefined;
        const signer = await options.signer(authScheme);
        const output = await next({
          ...args,
          request: await signer.sign(args.request, {
            signingDate: getSkewCorrectedDate(options.systemClockOffset),
            signingRegion: multiRegionOverride || context["signing_region"],
            signingService: context["signing_service"]
          })
        }).catch(error => {
          const serverTime = error.ServerTime ?? getDateHeader(error.$response);
          if (serverTime) {
            options.systemClockOffset = getUpdatedSystemClockOffset(serverTime, options.systemClockOffset);
          }
          throw error;
        });
        const dateHeader = getDateHeader(output.response);
        if (dateHeader) {
          options.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, options.systemClockOffset);
        }
        return output;
      };
      const getDateHeader = response => httpResponse_HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined;
      const awsAuthMiddlewareOptions = {
        name: "awsAuthMiddleware",
        tags: ["SIGNATURE", "AWSAUTH"],
        relation: "after",
        toMiddleware: "retryMiddleware",
        override: true
      };
      const getAwsAuthPlugin = options => ({
        applyToStack: clientStack => {
          clientStack.addRelativeTo(awsAuthMiddleware(options), awsAuthMiddlewareOptions);
        }
      });
      const getSigV4AuthPlugin = null && getAwsAuthPlugin;
      ;
      ;
      function resolveUserAgentConfig(input) {
        return {
          ...input,
          customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
        };
      }
      ;
      const partitions_namespaceObject = JSON.parse('{"partitions":[{"id":"aws","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","name":"aws","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^(us|eu|ap|sa|ca|me|af|il)\\\\-\\\\w+\\\\-\\\\d+$","regions":{"af-south-1":{"description":"Africa (Cape Town)"},"ap-east-1":{"description":"Asia Pacific (Hong Kong)"},"ap-northeast-1":{"description":"Asia Pacific (Tokyo)"},"ap-northeast-2":{"description":"Asia Pacific (Seoul)"},"ap-northeast-3":{"description":"Asia Pacific (Osaka)"},"ap-south-1":{"description":"Asia Pacific (Mumbai)"},"ap-south-2":{"description":"Asia Pacific (Hyderabad)"},"ap-southeast-1":{"description":"Asia Pacific (Singapore)"},"ap-southeast-2":{"description":"Asia Pacific (Sydney)"},"ap-southeast-3":{"description":"Asia Pacific (Jakarta)"},"ap-southeast-4":{"description":"Asia Pacific (Melbourne)"},"aws-global":{"description":"AWS Standard global region"},"ca-central-1":{"description":"Canada (Central)"},"eu-central-1":{"description":"Europe (Frankfurt)"},"eu-central-2":{"description":"Europe (Zurich)"},"eu-north-1":{"description":"Europe (Stockholm)"},"eu-south-1":{"description":"Europe (Milan)"},"eu-south-2":{"description":"Europe (Spain)"},"eu-west-1":{"description":"Europe (Ireland)"},"eu-west-2":{"description":"Europe (London)"},"eu-west-3":{"description":"Europe (Paris)"},"il-central-1":{"description":"Israel (Tel Aviv)"},"me-central-1":{"description":"Middle East (UAE)"},"me-south-1":{"description":"Middle East (Bahrain)"},"sa-east-1":{"description":"South America (Sao Paulo)"},"us-east-1":{"description":"US East (N. Virginia)"},"us-east-2":{"description":"US East (Ohio)"},"us-west-1":{"description":"US West (N. California)"},"us-west-2":{"description":"US West (Oregon)"}}},{"id":"aws-cn","outputs":{"dnsSuffix":"amazonaws.com.cn","dualStackDnsSuffix":"api.amazonwebservices.com.cn","name":"aws-cn","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^cn\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-cn-global":{"description":"AWS China global region"},"cn-north-1":{"description":"China (Beijing)"},"cn-northwest-1":{"description":"China (Ningxia)"}}},{"id":"aws-us-gov","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","name":"aws-us-gov","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-us-gov-global":{"description":"AWS GovCloud (US) global region"},"us-gov-east-1":{"description":"AWS GovCloud (US-East)"},"us-gov-west-1":{"description":"AWS GovCloud (US-West)"}}},{"id":"aws-iso","outputs":{"dnsSuffix":"c2s.ic.gov","dualStackDnsSuffix":"c2s.ic.gov","name":"aws-iso","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-global":{"description":"AWS ISO (US) global region"},"us-iso-east-1":{"description":"US ISO East"},"us-iso-west-1":{"description":"US ISO WEST"}}},{"id":"aws-iso-b","outputs":{"dnsSuffix":"sc2s.sgov.gov","dualStackDnsSuffix":"sc2s.sgov.gov","name":"aws-iso-b","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-b-global":{"description":"AWS ISOB (US) global region"},"us-isob-east-1":{"description":"US ISOB East (Ohio)"}}},{"id":"aws-iso-e","outputs":{"dnsSuffix":"cloud.adc-e.uk","dualStackDnsSuffix":"cloud.adc-e.uk","name":"aws-iso-e","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^eu\\\\-isoe\\\\-\\\\w+\\\\-\\\\d+$","regions":{}},{"id":"aws-iso-f","outputs":{"dnsSuffix":"csp.hci.ic.gov","dualStackDnsSuffix":"csp.hci.ic.gov","name":"aws-iso-f","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isof\\\\-\\\\w+\\\\-\\\\d+$","regions":{}}],"version":"1.1"}');
      ;
      let selectedPartitionsInfo = partitions_namespaceObject;
      let selectedUserAgentPrefix = "";
      const partition = value => {
        const {
          partitions
        } = selectedPartitionsInfo;
        for (const partition of partitions) {
          const {
            regions,
            outputs
          } = partition;
          for (const [region, regionData] of Object.entries(regions)) {
            if (region === value) {
              return {
                ...outputs,
                ...regionData
              };
            }
          }
        }
        for (const partition of partitions) {
          const {
            regionRegex,
            outputs
          } = partition;
          if (new RegExp(regionRegex).test(value)) {
            return {
              ...outputs
            };
          }
        }
        const DEFAULT_PARTITION = partitions.find(partition => partition.id === "aws");
        if (!DEFAULT_PARTITION) {
          throw new Error("Provided region was not found in the partition array or regex," + " and default partition with id 'aws' doesn't exist.");
        }
        return {
          ...DEFAULT_PARTITION.outputs
        };
      };
      const setPartitionInfo = (partitionsInfo, userAgentPrefix = "") => {
        selectedPartitionsInfo = partitionsInfo;
        selectedUserAgentPrefix = userAgentPrefix;
      };
      const useDefaultPartitionInfo = () => {
        setPartitionInfo(partitions_namespaceObject, "");
      };
      const getUserAgentPrefix = () => selectedUserAgentPrefix;
      ;
      const debugId = "endpoints";
      ;
      function toDebugString(input) {
        if (typeof input !== "object" || input == null) {
          return input;
        }
        if ("ref" in input) {
          return `$${toDebugString(input.ref)}`;
        }
        if ("fn" in input) {
          return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
        }
        return JSON.stringify(input, null, 2);
      }
      ;
      class EndpointError extends Error {
        constructor(message) {
          super(message);
          this.name = "EndpointError";
        }
      }
      ;
      const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
      const isIpAddress = value => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
      ;
      const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
      const isValidHostLabel = (value, allowSubDomains = false) => {
        if (!allowSubDomains) {
          return VALID_HOST_LABEL_REGEX.test(value);
        }
        const labels = value.split(".");
        for (const label of labels) {
          if (!isValidHostLabel(label)) {
            return false;
          }
        }
        return true;
      };
      ;
      const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
        if (allowSubDomains) {
          for (const label of value.split(".")) {
            if (!isVirtualHostableS3Bucket(label)) {
              return false;
            }
          }
          return true;
        }
        if (!isValidHostLabel(value)) {
          return false;
        }
        if (value.length < 3 || value.length > 63) {
          return false;
        }
        if (value !== value.toLowerCase()) {
          return false;
        }
        if (isIpAddress(value)) {
          return false;
        }
        return true;
      };
      ;
      const parseArn = value => {
        const segments = value.split(":");
        if (segments.length < 6) return null;
        const [arn, partition, service, region, accountId, ...resourceId] = segments;
        if (arn !== "arn" || partition === "" || service === "" || resourceId[0] === "") return null;
        return {
          partition,
          service,
          region,
          accountId,
          resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
        };
      };
      ;
      ;
      const booleanEquals = (value1, value2) => value1 === value2;
      ;
      const getAttrPathList = path => {
        const parts = path.split(".");
        const pathList = [];
        for (const part of parts) {
          const squareBracketIndex = part.indexOf("[");
          if (squareBracketIndex !== -1) {
            if (part.indexOf("]") !== part.length - 1) {
              throw new EndpointError(`Path: '${path}' does not end with ']'`);
            }
            const arrayIndex = part.slice(squareBracketIndex + 1, -1);
            if (Number.isNaN(parseInt(arrayIndex))) {
              throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
            }
            if (squareBracketIndex !== 0) {
              pathList.push(part.slice(0, squareBracketIndex));
            }
            pathList.push(arrayIndex);
          } else {
            pathList.push(part);
          }
        }
        return pathList;
      };
      ;
      const getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
        if (typeof acc !== "object") {
          throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
        } else if (Array.isArray(acc)) {
          return acc[parseInt(index)];
        }
        return acc[index];
      }, value);
      ;
      const isSet = value => value != null;
      ;
      const not = value => !value;
      ;
      ;
      var HostAddressType;
      (function (HostAddressType) {
        HostAddressType["AAAA"] = "AAAA";
        HostAddressType["A"] = "A";
      })(HostAddressType || (HostAddressType = {}));
      ;
      ;
      ;
      ;
      const DEFAULT_PORTS = {
        [EndpointURLScheme.HTTP]: 80,
        [EndpointURLScheme.HTTPS]: 443
      };
      const parseURL = value => {
        const whatwgURL = (() => {
          try {
            if (value instanceof URL) {
              return value;
            }
            if (typeof value === "object" && "hostname" in value) {
              const {
                hostname,
                port,
                protocol = "",
                path = "",
                query = {}
              } = value;
              const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : ""}${path}`);
              url.search = Object.entries(query).map(([k, v]) => `${k}=${v}`).join("&");
              return url;
            }
            return new URL(value);
          } catch (error) {
            return null;
          }
        })();
        if (!whatwgURL) {
          console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
          return null;
        }
        const urlString = whatwgURL.href;
        const {
          host,
          hostname,
          pathname,
          protocol,
          search
        } = whatwgURL;
        if (search) {
          return null;
        }
        const scheme = protocol.slice(0, -1);
        if (!Object.values(EndpointURLScheme).includes(scheme)) {
          return null;
        }
        const isIp = isIpAddress(hostname);
        const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
        const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
        return {
          scheme,
          authority,
          path: pathname,
          normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
          isIp
        };
      };
      ;
      const stringEquals = (value1, value2) => value1 === value2;
      ;
      const substring = (input, start, stop, reverse) => {
        if (start >= stop || input.length < stop) {
          return null;
        }
        if (!reverse) {
          return input.substring(start, stop);
        }
        return input.substring(input.length - stop, input.length - start);
      };
      ;
      const uriEncode = value => encodeURIComponent(value).replace(/[!*'()]/g, c => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
      ;
      ;
      const evaluateTemplate = (template, options) => {
        const evaluatedTemplateArr = [];
        const templateContext = {
          ...options.endpointParams,
          ...options.referenceRecord
        };
        let currentIndex = 0;
        while (currentIndex < template.length) {
          const openingBraceIndex = template.indexOf("{", currentIndex);
          if (openingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(currentIndex));
            break;
          }
          evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
          const closingBraceIndex = template.indexOf("}", openingBraceIndex);
          if (closingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex));
            break;
          }
          if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
            currentIndex = closingBraceIndex + 2;
          }
          const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
          if (parameterName.includes("#")) {
            const [refName, attrName] = parameterName.split("#");
            evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
          } else {
            evaluatedTemplateArr.push(templateContext[parameterName]);
          }
          currentIndex = closingBraceIndex + 1;
        }
        return evaluatedTemplateArr.join("");
      };
      ;
      const getReferenceValue = ({
        ref
      }, options) => {
        const referenceRecord = {
          ...options.endpointParams,
          ...options.referenceRecord
        };
        return referenceRecord[ref];
      };
      ;
      const evaluateExpression = (obj, keyName, options) => {
        if (typeof obj === "string") {
          return evaluateTemplate(obj, options);
        } else if (obj["fn"]) {
          return callFunction(obj, options);
        } else if (obj["ref"]) {
          return getReferenceValue(obj, options);
        }
        throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
      };
      ;
      const callFunction = ({
        fn,
        argv
      }, options) => {
        const evaluatedArgs = argv.map(arg => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
        return fn.split(".").reduce((acc, key) => acc[key], lib_namespaceObject)(...evaluatedArgs);
      };
      ;
      const evaluateCondition = ({
        assign,
        ...fnArgs
      }, options) => {
        if (assign && assign in options.referenceRecord) {
          throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
        }
        const value = callFunction(fnArgs, options);
        options.logger?.debug?.(debugId, `evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
        return {
          result: value === "" ? true : !!value,
          ...(assign != null && {
            toAssign: {
              name: assign,
              value
            }
          })
        };
      };
      ;
      const evaluateConditions = (conditions = [], options) => {
        const conditionsReferenceRecord = {};
        for (const condition of conditions) {
          const {
            result,
            toAssign
          } = evaluateCondition(condition, {
            ...options,
            referenceRecord: {
              ...options.referenceRecord,
              ...conditionsReferenceRecord
            }
          });
          if (!result) {
            return {
              result
            };
          }
          if (toAssign) {
            conditionsReferenceRecord[toAssign.name] = toAssign.value;
            options.logger?.debug?.(debugId, `assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
          }
        }
        return {
          result: true,
          referenceRecord: conditionsReferenceRecord
        };
      };
      ;
      const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
        ...acc,
        [headerKey]: headerVal.map(headerValEntry => {
          const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
          if (typeof processedExpr !== "string") {
            throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
          }
          return processedExpr;
        })
      }), {});
      ;
      const getEndpointProperty = (property, options) => {
        if (Array.isArray(property)) {
          return property.map(propertyEntry => getEndpointProperty(propertyEntry, options));
        }
        switch (typeof property) {
          case "string":
            return evaluateTemplate(property, options);
          case "object":
            if (property === null) {
              throw new EndpointError(`Unexpected endpoint property: ${property}`);
            }
            return getEndpointProperties(property, options);
          case "boolean":
            return property;
          default:
            throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
        }
      };
      ;
      const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
        ...acc,
        [propertyKey]: getEndpointProperty(propertyVal, options)
      }), {});
      ;
      const getEndpointUrl = (endpointUrl, options) => {
        const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
        if (typeof expression === "string") {
          try {
            return new URL(expression);
          } catch (error) {
            console.error(`Failed to construct URL with ${expression}`, error);
            throw error;
          }
        }
        throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
      };
      ;
      const evaluateEndpointRule = (endpointRule, options) => {
        const {
          conditions,
          endpoint
        } = endpointRule;
        const {
          result,
          referenceRecord
        } = evaluateConditions(conditions, options);
        if (!result) {
          return;
        }
        const endpointRuleOptions = {
          ...options,
          referenceRecord: {
            ...options.referenceRecord,
            ...referenceRecord
          }
        };
        const {
          url,
          properties,
          headers
        } = endpoint;
        options.logger?.debug?.(debugId, `Resolving endpoint from template: ${toDebugString(endpoint)}`);
        return {
          ...(headers != undefined && {
            headers: getEndpointHeaders(headers, endpointRuleOptions)
          }),
          ...(properties != undefined && {
            properties: getEndpointProperties(properties, endpointRuleOptions)
          }),
          url: getEndpointUrl(url, endpointRuleOptions)
        };
      };
      ;
      const evaluateErrorRule = (errorRule, options) => {
        const {
          conditions,
          error
        } = errorRule;
        const {
          result,
          referenceRecord
        } = evaluateConditions(conditions, options);
        if (!result) {
          return;
        }
        throw new EndpointError(evaluateExpression(error, "Error", {
          ...options,
          referenceRecord: {
            ...options.referenceRecord,
            ...referenceRecord
          }
        }));
      };
      ;
      const evaluateTreeRule = (treeRule, options) => {
        const {
          conditions,
          rules
        } = treeRule;
        const {
          result,
          referenceRecord
        } = evaluateConditions(conditions, options);
        if (!result) {
          return;
        }
        return evaluateRules(rules, {
          ...options,
          referenceRecord: {
            ...options.referenceRecord,
            ...referenceRecord
          }
        });
      };
      ;
      const evaluateRules = (rules, options) => {
        for (const rule of rules) {
          if (rule.type === "endpoint") {
            const endpointOrUndefined = evaluateEndpointRule(rule, options);
            if (endpointOrUndefined) {
              return endpointOrUndefined;
            }
          } else if (rule.type === "error") {
            evaluateErrorRule(rule, options);
          } else if (rule.type === "tree") {
            const endpointOrUndefined = evaluateTreeRule(rule, options);
            if (endpointOrUndefined) {
              return endpointOrUndefined;
            }
          } else {
            throw new EndpointError(`Unknown endpoint rule: ${rule}`);
          }
        }
        throw new EndpointError(`Rules evaluation failed`);
      };
      ;
      ;
      const resolveEndpoint = (ruleSetObject, options) => {
        const {
          endpointParams,
          logger
        } = options;
        const {
          parameters,
          rules
        } = ruleSetObject;
        options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
        const paramsWithDefault = Object.entries(parameters).filter(([, v]) => v.default != null).map(([k, v]) => [k, v.default]);
        if (paramsWithDefault.length > 0) {
          for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
            endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
          }
        }
        const requiredParams = Object.entries(parameters).filter(([, v]) => v.required).map(([k]) => k);
        for (const requiredParam of requiredParams) {
          if (endpointParams[requiredParam] == null) {
            throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
          }
        }
        const endpoint = evaluateRules(rules, {
          endpointParams,
          logger,
          referenceRecord: {}
        });
        if (options.endpointParams?.Endpoint) {
          try {
            const givenEndpoint = new URL(options.endpointParams.Endpoint);
            const {
              protocol,
              port
            } = givenEndpoint;
            endpoint.url.protocol = protocol;
            endpoint.url.port = port;
          } catch (e) {}
        }
        options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
        return endpoint;
      };
      ;
      ;
      const USER_AGENT = "user-agent";
      const X_AMZ_USER_AGENT = "x-amz-user-agent";
      const SPACE = " ";
      const UA_NAME_SEPARATOR = "/";
      const UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
      const UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
      const UA_ESCAPE_CHAR = "-";
      ;
      const userAgentMiddleware = options => (next, context) => async args => {
        const {
          request
        } = args;
        if (!httpRequest_HttpRequest.isInstance(request)) return next(args);
        const {
          headers
        } = request;
        const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
        const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
        const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
        const prefix = getUserAgentPrefix();
        const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent, ...customUserAgent]).join(SPACE);
        const normalUAValue = [...defaultUserAgent.filter(section => section.startsWith("aws-sdk-")), ...customUserAgent].join(SPACE);
        if (options.runtime !== "browser") {
          if (normalUAValue) {
            headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
          }
          headers[USER_AGENT] = sdkUserAgentValue;
        } else {
          headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
        }
        return next({
          ...args,
          request
        });
      };
      const escapeUserAgent = userAgentPair => {
        const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map(part => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
        const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
        const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
        const prefix = name.substring(0, prefixSeparatorIndex);
        let uaName = name.substring(prefixSeparatorIndex + 1);
        if (prefix === "api") {
          uaName = uaName.toLowerCase();
        }
        return [prefix, uaName, version].filter(item => item && item.length > 0).reduce((acc, item, index) => {
          switch (index) {
            case 0:
              return item;
            case 1:
              return `${acc}/${item}`;
            default:
              return `${acc}#${item}`;
          }
        }, "");
      };
      const getUserAgentMiddlewareOptions = {
        name: "getUserAgentMiddleware",
        step: "build",
        priority: "low",
        tags: ["SET_USER_AGENT", "USER_AGENT"],
        override: true
      };
      const getUserAgentPlugin = config => ({
        applyToStack: clientStack => {
          clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
        }
      });
      ;
      ;
      var SelectorType;
      (function (SelectorType) {
        SelectorType["ENV"] = "env";
        SelectorType["CONFIG"] = "shared config entry";
      })(SelectorType || (SelectorType = {}));
      const booleanSelector = (obj, key, type) => {
        if (!(key in obj)) return undefined;
        if (obj[key] === "true") return true;
        if (obj[key] === "false") return false;
        throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
      };
      ;
      ;
      const ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
      const CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
      const DEFAULT_USE_DUALSTACK_ENDPOINT = false;
      const NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
        environmentVariableSelector: env => booleanSelector(env, ENV_USE_DUALSTACK_ENDPOINT, SelectorType.ENV),
        configFileSelector: profile => booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, SelectorType.CONFIG),
        default: false
      };
      ;
      const ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
      const CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
      const DEFAULT_USE_FIPS_ENDPOINT = false;
      const NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
        environmentVariableSelector: env => booleanSelector(env, ENV_USE_FIPS_ENDPOINT, SelectorType.ENV),
        configFileSelector: profile => booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, SelectorType.CONFIG),
        default: false
      };
      ;
      ;
      const REGION_ENV_NAME = "AWS_REGION";
      const REGION_INI_NAME = "region";
      const NODE_REGION_CONFIG_OPTIONS = {
        environmentVariableSelector: env => env[REGION_ENV_NAME],
        configFileSelector: profile => profile[REGION_INI_NAME],
        default: () => {
          throw new Error("Region is missing");
        }
      };
      const NODE_REGION_CONFIG_FILE_OPTIONS = {
        preferredFile: "credentials"
      };
      ;
      const isFipsRegion = region => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
      ;
      const getRealRegion = region => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
      ;
      const resolveRegionConfig = input => {
        const {
          region,
          useFipsEndpoint
        } = input;
        if (!region) {
          throw new Error("Region is missing");
        }
        return {
          ...input,
          region: async () => {
            if (typeof region === "string") {
              return getRealRegion(region);
            }
            const providedRegion = await region();
            return getRealRegion(providedRegion);
          },
          useFipsEndpoint: async () => {
            const providedRegion = typeof region === "string" ? region : await region();
            if (isFipsRegion(providedRegion)) {
              return true;
            }
            return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
          }
        };
      };
      ;
      ;
      ;
      const CONTENT_LENGTH_HEADER = "content-length";
      function contentLengthMiddleware(bodyLengthChecker) {
        return next => async args => {
          const request = args.request;
          if (httpRequest_HttpRequest.isInstance(request)) {
            const {
              body,
              headers
            } = request;
            if (body && Object.keys(headers).map(str => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
              try {
                const length = bodyLengthChecker(body);
                request.headers = {
                  ...request.headers,
                  [CONTENT_LENGTH_HEADER]: String(length)
                };
              } catch (error) {}
            }
          }
          return next({
            ...args,
            request
          });
        };
      }
      const contentLengthMiddlewareOptions = {
        step: "build",
        tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
        name: "contentLengthMiddleware",
        override: true
      };
      const getContentLengthPlugin = options => ({
        applyToStack: clientStack => {
          clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
        }
      });
      ;
      const deserializerMiddleware = (options, deserializer) => (next, context) => async args => {
        const {
          response
        } = await next(args);
        try {
          const parsed = await deserializer(response, options);
          return {
            response,
            output: parsed
          };
        } catch (error) {
          Object.defineProperty(error, "$response", {
            value: response
          });
          if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            error.message += "\n  " + hint;
          }
          throw error;
        }
      };
      ;
      const serializerMiddleware = (options, serializer) => (next, context) => async args => {
        const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
        if (!endpoint) {
          throw new Error("No valid endpoint provider available.");
        }
        const request = await serializer(args.input, {
          ...options,
          endpoint
        });
        return next({
          ...args,
          request
        });
      };
      ;
      const deserializerMiddlewareOption = {
        name: "deserializerMiddleware",
        step: "deserialize",
        tags: ["DESERIALIZER"],
        override: true
      };
      const serializerMiddlewareOption = {
        name: "serializerMiddleware",
        step: "serialize",
        tags: ["SERIALIZER"],
        override: true
      };
      function getSerdePlugin(config, serializer, deserializer) {
        return {
          applyToStack: commandStack => {
            commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
            commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
          }
        };
      }
      ;
      ;
      const resolveParamsForS3 = async endpointParams => {
        const bucket = endpointParams?.Bucket || "";
        if (typeof endpointParams.Bucket === "string") {
          endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
        }
        if (isArnBucketName(bucket)) {
          if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
          }
        } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
          endpointParams.ForcePathStyle = true;
        }
        if (endpointParams.DisableMultiRegionAccessPoints) {
          endpointParams.disableMultiRegionAccessPoints = true;
          endpointParams.DisableMRAP = true;
        }
        return endpointParams;
      };
      const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
      const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
      const DOTS_PATTERN = /\.\./;
      const DOT_PATTERN = /\./;
      const S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
      const isDnsCompatibleBucketName = bucketName => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
      const isArnBucketName = bucketName => {
        const [arn, partition, service, region, account, typeOrId] = bucketName.split(":");
        const isArn = arn === "arn" && bucketName.split(":").length >= 6;
        const isValidArn = [arn, partition, service, account, typeOrId].filter(Boolean).length === 5;
        if (isArn && !isValidArn) {
          throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
        }
        return arn === "arn" && !!partition && !!service && !!account && !!typeOrId;
      };
      ;
      const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
        const configProvider = async () => {
          const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
          if (typeof configValue === "function") {
            return configValue();
          }
          return configValue;
        };
        if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
          return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
              if ("url" in endpoint) {
                return endpoint.url.href;
              }
              if ("hostname" in endpoint) {
                const {
                  protocol,
                  hostname,
                  port,
                  path
                } = endpoint;
                return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
              }
            }
            return endpoint;
          };
        }
        return configProvider;
      };
      ;
      const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
        const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
        if (typeof clientConfig.endpointProvider !== "function") {
          throw new Error("config.endpointProvider is not set.");
        }
        const endpoint = clientConfig.endpointProvider(endpointParams, context);
        return endpoint;
      };
      const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
        const endpointParams = {};
        const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
        for (const [name, instruction] of Object.entries(instructions)) {
          switch (instruction.type) {
            case "staticContextParams":
              endpointParams[name] = instruction.value;
              break;
            case "contextParams":
              endpointParams[name] = commandInput[instruction.name];
              break;
            case "clientContextParams":
            case "builtInParams":
              endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
              break;
            default:
              throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
          }
        }
        if (Object.keys(instructions).length === 0) {
          Object.assign(endpointParams, clientConfig);
        }
        if (String(clientConfig.serviceId).toLowerCase() === "s3") {
          await resolveParamsForS3(endpointParams);
        }
        return endpointParams;
      };
      ;
      const endpointMiddleware = ({
        config,
        instructions
      }) => {
        return (next, context) => async args => {
          const endpoint = await getEndpointFromInstructions(args.input, {
            getEndpointParameterInstructions() {
              return instructions;
            }
          }, {
            ...config
          }, context);
          context.endpointV2 = endpoint;
          context.authSchemes = endpoint.properties?.authSchemes;
          const authScheme = context.authSchemes?.[0];
          if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
          }
          return next({
            ...args
          });
        };
      };
      ;
      const endpointMiddlewareOptions = {
        step: "serialize",
        tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
        name: "endpointV2Middleware",
        override: true,
        relation: "before",
        toMiddleware: serializerMiddlewareOption.name
      };
      const getEndpointPlugin = (config, instructions) => ({
        applyToStack: clientStack => {
          clientStack.addRelativeTo(endpointMiddleware({
            config,
            instructions
          }), endpointMiddlewareOptions);
        }
      });
      ;
      function parseQueryString(querystring) {
        const query = {};
        querystring = querystring.replace(/^\?/, "");
        if (querystring) {
          for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
              value = decodeURIComponent(value);
            }
            if (!(key in query)) {
              query[key] = value;
            } else if (Array.isArray(query[key])) {
              query[key].push(value);
            } else {
              query[key] = [query[key], value];
            }
          }
        }
        return query;
      }
      ;
      const parseUrl = url => {
        if (typeof url === "string") {
          return parseUrl(new URL(url));
        }
        const {
          hostname,
          pathname,
          port,
          protocol,
          search
        } = url;
        let query;
        if (search) {
          query = parseQueryString(search);
        }
        return {
          hostname,
          port: port ? parseInt(port) : undefined,
          protocol,
          path: pathname,
          query
        };
      };
      ;
      const toEndpointV1 = endpoint => {
        if (typeof endpoint === "object") {
          if ("url" in endpoint) {
            return parseUrl(endpoint.url);
          }
          return endpoint;
        }
        return parseUrl(endpoint);
      };
      ;
      const resolveEndpointConfig = input => {
        const tls = input.tls ?? true;
        const {
          endpoint
        } = input;
        const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider_normalizeProvider(endpoint)()) : undefined;
        const isCustomEndpoint = !!endpoint;
        return {
          ...input,
          endpoint: customEndpointProvider,
          tls,
          isCustomEndpoint,
          useDualstackEndpoint: normalizeProvider_normalizeProvider(input.useDualstackEndpoint ?? false),
          useFipsEndpoint: normalizeProvider_normalizeProvider(input.useFipsEndpoint ?? false)
        };
      };
      ;
      ;
      var config_RETRY_MODES;
      (function (RETRY_MODES) {
        RETRY_MODES["STANDARD"] = "standard";
        RETRY_MODES["ADAPTIVE"] = "adaptive";
      })(config_RETRY_MODES || (config_RETRY_MODES = {}));
      const config_DEFAULT_MAX_ATTEMPTS = 3;
      const DEFAULT_RETRY_MODE = config_RETRY_MODES.STANDARD;
      ;
      const constants_CLOCK_SKEW_ERROR_CODES = null && ["AuthFailure", "InvalidSignatureException", "RequestExpired", "RequestInTheFuture", "RequestTimeTooSkewed", "SignatureDoesNotMatch"];
      const THROTTLING_ERROR_CODES = ["BandwidthLimitExceeded", "EC2ThrottledException", "LimitExceededException", "PriorRequestNotComplete", "ProvisionedThroughputExceededException", "RequestLimitExceeded", "RequestThrottled", "RequestThrottledException", "SlowDown", "ThrottledException", "Throttling", "ThrottlingException", "TooManyRequestsException", "TransactionInProgressException"];
      const TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
      const TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
      const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
      ;
      const isRetryableByTrait = error => error.$retryable !== undefined;
      const isClockSkewError = error => CLOCK_SKEW_ERROR_CODES.includes(error.name);
      const dist_es_isThrottlingError = error => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true;
      const isTransientError = error => TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0);
      const isServerError = error => {
        if (error.$metadata?.httpStatusCode !== undefined) {
          const statusCode = error.$metadata.httpStatusCode;
          if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
            return true;
          }
          return false;
        }
        return false;
      };
      ;
      class DefaultRateLimiter_DefaultRateLimiter {
        constructor(options) {
          this.currentCapacity = 0;
          this.enabled = false;
          this.lastMaxRate = 0;
          this.measuredTxRate = 0;
          this.requestCount = 0;
          this.lastTimestamp = 0;
          this.timeWindow = 0;
          this.beta = options?.beta ?? 0.7;
          this.minCapacity = options?.minCapacity ?? 1;
          this.minFillRate = options?.minFillRate ?? 0.5;
          this.scaleConstant = options?.scaleConstant ?? 0.4;
          this.smooth = options?.smooth ?? 0.8;
          const currentTimeInSeconds = this.getCurrentTimeInSeconds();
          this.lastThrottleTime = currentTimeInSeconds;
          this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
          this.fillRate = this.minFillRate;
          this.maxCapacity = this.minCapacity;
        }
        getCurrentTimeInSeconds() {
          return Date.now() / 1000;
        }
        async getSendToken() {
          return this.acquireTokenBucket(1);
        }
        async acquireTokenBucket(amount) {
          if (!this.enabled) {
            return;
          }
          this.refillTokenBucket();
          if (amount > this.currentCapacity) {
            const delay = (amount - this.currentCapacity) / this.fillRate * 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
          }
          this.currentCapacity = this.currentCapacity - amount;
        }
        refillTokenBucket() {
          const timestamp = this.getCurrentTimeInSeconds();
          if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            return;
          }
          const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
          this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
          this.lastTimestamp = timestamp;
        }
        updateClientSendingRate(response) {
          let calculatedRate;
          this.updateMeasuredRate();
          if (dist_es_isThrottlingError(response)) {
            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
            this.lastMaxRate = rateToUse;
            this.calculateTimeWindow();
            this.lastThrottleTime = this.getCurrentTimeInSeconds();
            calculatedRate = this.cubicThrottle(rateToUse);
            this.enableTokenBucket();
          } else {
            this.calculateTimeWindow();
            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
          }
          const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
          this.updateTokenBucketRate(newRate);
        }
        calculateTimeWindow() {
          this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
        }
        cubicThrottle(rateToUse) {
          return this.getPrecise(rateToUse * this.beta);
        }
        cubicSuccess(timestamp) {
          return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
        }
        enableTokenBucket() {
          this.enabled = true;
        }
        updateTokenBucketRate(newRate) {
          this.refillTokenBucket();
          this.fillRate = Math.max(newRate, this.minFillRate);
          this.maxCapacity = Math.max(newRate, this.minCapacity);
          this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
        }
        updateMeasuredRate() {
          const t = this.getCurrentTimeInSeconds();
          const timeBucket = Math.floor(t * 2) / 2;
          this.requestCount++;
          if (timeBucket > this.lastTxRateBucket) {
            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
            this.requestCount = 0;
            this.lastTxRateBucket = timeBucket;
          }
        }
        getPrecise(num) {
          return parseFloat(num.toFixed(8));
        }
      }
      ;
      const constants_DEFAULT_RETRY_DELAY_BASE = 100;
      const constants_MAXIMUM_RETRY_DELAY = 20 * 1000;
      const constants_THROTTLING_RETRY_DELAY_BASE = 500;
      const constants_INITIAL_RETRY_TOKENS = 500;
      const constants_RETRY_COST = 5;
      const constants_TIMEOUT_RETRY_COST = 10;
      const constants_NO_RETRY_INCREMENT = 1;
      const constants_INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
      const constants_REQUEST_HEADER = "amz-sdk-request";
      ;
      const getDefaultRetryBackoffStrategy = () => {
        let delayBase = constants_DEFAULT_RETRY_DELAY_BASE;
        const computeNextBackoffDelay = attempts => {
          return Math.floor(Math.min(constants_MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
        };
        const setDelayBase = delay => {
          delayBase = delay;
        };
        return {
          computeNextBackoffDelay,
          setDelayBase
        };
      };
      ;
      const createDefaultRetryToken = ({
        retryDelay,
        retryCount,
        retryCost
      }) => {
        const getRetryCount = () => retryCount;
        const getRetryDelay = () => Math.min(constants_MAXIMUM_RETRY_DELAY, retryDelay);
        const getRetryCost = () => retryCost;
        return {
          getRetryCount,
          getRetryDelay,
          getRetryCost
        };
      };
      ;
      class StandardRetryStrategy_StandardRetryStrategy {
        constructor(maxAttempts) {
          this.maxAttempts = maxAttempts;
          this.mode = config_RETRY_MODES.STANDARD;
          this.capacity = constants_INITIAL_RETRY_TOKENS;
          this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
          this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
        }
        async acquireInitialRetryToken(retryTokenScope) {
          return createDefaultRetryToken({
            retryDelay: constants_DEFAULT_RETRY_DELAY_BASE,
            retryCount: 0
          });
        }
        async refreshRetryTokenForRetry(token, errorInfo) {
          const maxAttempts = await this.getMaxAttempts();
          if (this.shouldRetry(token, errorInfo, maxAttempts)) {
            const errorType = errorInfo.errorType;
            this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? constants_THROTTLING_RETRY_DELAY_BASE : constants_DEFAULT_RETRY_DELAY_BASE);
            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
            const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
            const capacityCost = this.getCapacityCost(errorType);
            this.capacity -= capacityCost;
            return createDefaultRetryToken({
              retryDelay,
              retryCount: token.getRetryCount() + 1,
              retryCost: capacityCost
            });
          }
          throw new Error("No retry token available");
        }
        recordSuccess(token) {
          this.capacity = Math.max(constants_INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? constants_NO_RETRY_INCREMENT));
        }
        getCapacity() {
          return this.capacity;
        }
        async getMaxAttempts() {
          try {
            return await this.maxAttemptsProvider();
          } catch (error) {
            console.warn(`Max attempts provider could not resolve. Using default of ${config_DEFAULT_MAX_ATTEMPTS}`);
            return config_DEFAULT_MAX_ATTEMPTS;
          }
        }
        shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
          const attempts = tokenToRenew.getRetryCount() + 1;
          return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
        }
        getCapacityCost(errorType) {
          return errorType === "TRANSIENT" ? constants_TIMEOUT_RETRY_COST : constants_RETRY_COST;
        }
        isRetryableError(errorType) {
          return errorType === "THROTTLING" || errorType === "TRANSIENT";
        }
      }
      ;
      class AdaptiveRetryStrategy {
        constructor(maxAttemptsProvider, options) {
          this.maxAttemptsProvider = maxAttemptsProvider;
          this.mode = config_RETRY_MODES.ADAPTIVE;
          const {
            rateLimiter
          } = options ?? {};
          this.rateLimiter = rateLimiter ?? new DefaultRateLimiter_DefaultRateLimiter();
          this.standardRetryStrategy = new StandardRetryStrategy_StandardRetryStrategy(maxAttemptsProvider);
        }
        async acquireInitialRetryToken(retryTokenScope) {
          await this.rateLimiter.getSendToken();
          return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
        }
        async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
          this.rateLimiter.updateClientSendingRate(errorInfo);
          return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        }
        recordSuccess(token) {
          this.rateLimiter.updateClientSendingRate({});
          this.standardRetryStrategy.recordSuccess(token);
        }
      }
      ;
      class ConfiguredRetryStrategy extends (null && StandardRetryStrategy) {
        constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE) {
          super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
          if (typeof computeNextBackoffDelay === "number") {
            this.computeNextBackoffDelay = () => computeNextBackoffDelay;
          } else {
            this.computeNextBackoffDelay = computeNextBackoffDelay;
          }
        }
        async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
          const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
          token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
          return token;
        }
      }
      ;
      ;
      const defaultRetryQuota_getDefaultRetryQuota = (initialRetryTokens, options) => {
        const MAX_CAPACITY = initialRetryTokens;
        const noRetryIncrement = options?.noRetryIncrement ?? NO_RETRY_INCREMENT;
        const retryCost = options?.retryCost ?? RETRY_COST;
        const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;
        let availableCapacity = initialRetryTokens;
        const getCapacityAmount = error => error.name === "TimeoutError" ? timeoutRetryCost : retryCost;
        const hasRetryTokens = error => getCapacityAmount(error) <= availableCapacity;
        const retrieveRetryTokens = error => {
          if (!hasRetryTokens(error)) {
            throw new Error("No retry token available");
          }
          const capacityAmount = getCapacityAmount(error);
          availableCapacity -= capacityAmount;
          return capacityAmount;
        };
        const releaseRetryTokens = capacityReleaseAmount => {
          availableCapacity += capacityReleaseAmount ?? noRetryIncrement;
          availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
        };
        return Object.freeze({
          hasRetryTokens,
          retrieveRetryTokens,
          releaseRetryTokens
        });
      };
      ;
      const delayDecider_defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
      ;
      class dist_es_StandardRetryStrategy_StandardRetryStrategy {
        constructor(maxAttemptsProvider, options) {
          this.maxAttemptsProvider = maxAttemptsProvider;
          this.mode = RETRY_MODES.STANDARD;
          this.retryDecider = options?.retryDecider ?? defaultRetryDecider;
          this.delayDecider = options?.delayDecider ?? defaultDelayDecider;
          this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(INITIAL_RETRY_TOKENS);
        }
        shouldRetry(error, attempts, maxAttempts) {
          return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
        }
        async getMaxAttempts() {
          let maxAttempts;
          try {
            maxAttempts = await this.maxAttemptsProvider();
          } catch (error) {
            maxAttempts = DEFAULT_MAX_ATTEMPTS;
          }
          return maxAttempts;
        }
        async retry(next, args, options) {
          let retryTokenAmount;
          let attempts = 0;
          let totalDelay = 0;
          const maxAttempts = await this.getMaxAttempts();
          const {
            request
          } = args;
          if (HttpRequest.isInstance(request)) {
            request.headers[INVOCATION_ID_HEADER] = v4();
          }
          while (true) {
            try {
              if (HttpRequest.isInstance(request)) {
                request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
              }
              if (options?.beforeRequest) {
                await options.beforeRequest();
              }
              const {
                response,
                output
              } = await next(args);
              if (options?.afterRequest) {
                options.afterRequest(response);
              }
              this.retryQuota.releaseRetryTokens(retryTokenAmount);
              output.$metadata.attempts = attempts + 1;
              output.$metadata.totalRetryDelay = totalDelay;
              return {
                response,
                output
              };
            } catch (e) {
              const err = asSdkError(e);
              attempts++;
              if (this.shouldRetry(err, attempts, maxAttempts)) {
                retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
                const delayFromDecider = this.delayDecider(isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);
                const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
                const delay = Math.max(delayFromResponse || 0, delayFromDecider);
                totalDelay += delay;
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
              }
              if (!err.$metadata) {
                err.$metadata = {};
              }
              err.$metadata.attempts = attempts;
              err.$metadata.totalRetryDelay = totalDelay;
              throw err;
            }
          }
        }
      }
      const getDelayFromRetryAfterHeader = response => {
        if (!HttpResponse.isInstance(response)) return;
        const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === "retry-after");
        if (!retryAfterHeaderName) return;
        const retryAfter = response.headers[retryAfterHeaderName];
        const retryAfterSeconds = Number(retryAfter);
        if (!Number.isNaN(retryAfterSeconds)) return retryAfterSeconds * 1000;
        const retryAfterDate = new Date(retryAfter);
        return retryAfterDate.getTime() - Date.now();
      };
      ;
      class AdaptiveRetryStrategy_AdaptiveRetryStrategy extends (null && StandardRetryStrategy) {
        constructor(maxAttemptsProvider, options) {
          const {
            rateLimiter,
            ...superOptions
          } = options ?? {};
          super(maxAttemptsProvider, superOptions);
          this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
          this.mode = RETRY_MODES.ADAPTIVE;
        }
        async retry(next, args) {
          return super.retry(next, args, {
            beforeRequest: async () => {
              return this.rateLimiter.getSendToken();
            },
            afterRequest: response => {
              this.rateLimiter.updateClientSendingRate(response);
            }
          });
        }
      }
      ;
      const ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
      const CONFIG_MAX_ATTEMPTS = "max_attempts";
      const NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
        environmentVariableSelector: env => {
          const value = env[ENV_MAX_ATTEMPTS];
          if (!value) return undefined;
          const maxAttempt = parseInt(value);
          if (Number.isNaN(maxAttempt)) {
            throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
          }
          return maxAttempt;
        },
        configFileSelector: profile => {
          const value = profile[CONFIG_MAX_ATTEMPTS];
          if (!value) return undefined;
          const maxAttempt = parseInt(value);
          if (Number.isNaN(maxAttempt)) {
            throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
          }
          return maxAttempt;
        },
        default: config_DEFAULT_MAX_ATTEMPTS
      };
      const resolveRetryConfig = input => {
        const {
          retryStrategy
        } = input;
        const maxAttempts = normalizeProvider_normalizeProvider(input.maxAttempts ?? config_DEFAULT_MAX_ATTEMPTS);
        return {
          ...input,
          maxAttempts,
          retryStrategy: async () => {
            if (retryStrategy) {
              return retryStrategy;
            }
            const retryMode = await normalizeProvider_normalizeProvider(input.retryMode)();
            if (retryMode === config_RETRY_MODES.ADAPTIVE) {
              return new AdaptiveRetryStrategy(maxAttempts);
            }
            return new StandardRetryStrategy_StandardRetryStrategy(maxAttempts);
          }
        };
      };
      const ENV_RETRY_MODE = "AWS_RETRY_MODE";
      const CONFIG_RETRY_MODE = "retry_mode";
      const NODE_RETRY_MODE_CONFIG_OPTIONS = {
        environmentVariableSelector: env => env[ENV_RETRY_MODE],
        configFileSelector: profile => profile[CONFIG_RETRY_MODE],
        default: DEFAULT_RETRY_MODE
      };
      ;
      const omitRetryHeadersMiddleware = () => next => async args => {
        const {
          request
        } = args;
        if (HttpRequest.isInstance(request)) {
          delete request.headers[INVOCATION_ID_HEADER];
          delete request.headers[REQUEST_HEADER];
        }
        return next(args);
      };
      const omitRetryHeadersMiddlewareOptions = {
        name: "omitRetryHeadersMiddleware",
        tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
        relation: "before",
        toMiddleware: "awsAuthMiddleware",
        override: true
      };
      const getOmitRetryHeadersPlugin = options => ({
        applyToStack: clientStack => {
          clientStack.addRelativeTo(omitRetryHeadersMiddleware(), omitRetryHeadersMiddlewareOptions);
        }
      });
      ;
      var getRandomValues;
      var rnds8 = new Uint8Array(16);
      function rng() {
        if (!getRandomValues) {
          getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
          if (!getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
          }
        }
        return getRandomValues(rnds8);
      }
      ;
      const regex = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
      ;
      function validate(uuid) {
        return typeof uuid === 'string' && regex.test(uuid);
      }
      const esm_browser_validate = validate;
      ;
      var byteToHex = [];
      for (var i = 0; i < 256; ++i) {
        byteToHex.push((i + 0x100).toString(16).substr(1));
      }
      function stringify(arr) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
        if (!esm_browser_validate(uuid)) {
          throw TypeError('Stringified UUID is invalid');
        }
        return uuid;
      }
      const esm_browser_stringify = stringify;
      ;
      function v4_v4(options, buf, offset) {
        options = options || {};
        var rnds = options.random || (options.rng || rng)();
        rnds[6] = rnds[6] & 0x0f | 0x40;
        rnds[8] = rnds[8] & 0x3f | 0x80;
        if (buf) {
          offset = offset || 0;
          for (var i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
          }
          return buf;
        }
        return esm_browser_stringify(rnds);
      }
      const esm_browser_v4 = v4_v4;
      ;
      const util_asSdkError = error => {
        if (error instanceof Error) return error;
        if (error instanceof Object) return Object.assign(new Error(), error);
        if (typeof error === "string") return new Error(error);
        return new Error(`AWS SDK error wrapper for ${error}`);
      };
      ;
      const retryMiddleware = options => (next, context) => async args => {
        let retryStrategy = await options.retryStrategy();
        const maxAttempts = await options.maxAttempts();
        if (isRetryStrategyV2(retryStrategy)) {
          retryStrategy = retryStrategy;
          let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
          let lastError = new Error();
          let attempts = 0;
          let totalRetryDelay = 0;
          const {
            request
          } = args;
          if (httpRequest_HttpRequest.isInstance(request)) {
            request.headers[constants_INVOCATION_ID_HEADER] = esm_browser_v4();
          }
          while (true) {
            try {
              if (httpRequest_HttpRequest.isInstance(request)) {
                request.headers[constants_REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
              }
              const {
                response,
                output
              } = await next(args);
              retryStrategy.recordSuccess(retryToken);
              output.$metadata.attempts = attempts + 1;
              output.$metadata.totalRetryDelay = totalRetryDelay;
              return {
                response,
                output
              };
            } catch (e) {
              const retryErrorInfo = getRetryErrorInfo(e);
              lastError = util_asSdkError(e);
              try {
                retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
              } catch (refreshError) {
                if (!lastError.$metadata) {
                  lastError.$metadata = {};
                }
                lastError.$metadata.attempts = attempts + 1;
                lastError.$metadata.totalRetryDelay = totalRetryDelay;
                throw lastError;
              }
              attempts = retryToken.getRetryCount();
              const delay = retryToken.getRetryDelay();
              totalRetryDelay += delay;
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        } else {
          retryStrategy = retryStrategy;
          if (retryStrategy?.mode) context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
          return retryStrategy.retry(next, args);
        }
      };
      const isRetryStrategyV2 = retryStrategy => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
      const getRetryErrorInfo = error => {
        const errorInfo = {
          errorType: getRetryErrorType(error)
        };
        const retryAfterHint = getRetryAfterHint(error.$response);
        if (retryAfterHint) {
          errorInfo.retryAfterHint = retryAfterHint;
        }
        return errorInfo;
      };
      const getRetryErrorType = error => {
        if (dist_es_isThrottlingError(error)) return "THROTTLING";
        if (isTransientError(error)) return "TRANSIENT";
        if (isServerError(error)) return "SERVER_ERROR";
        return "CLIENT_ERROR";
      };
      const retryMiddlewareOptions = {
        name: "retryMiddleware",
        tags: ["RETRY"],
        step: "finalizeRequest",
        priority: "high",
        override: true
      };
      const getRetryPlugin = options => ({
        applyToStack: clientStack => {
          clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
        }
      });
      const getRetryAfterHint = response => {
        if (!httpResponse_HttpResponse.isInstance(response)) return;
        const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === "retry-after");
        if (!retryAfterHeaderName) return;
        const retryAfter = response.headers[retryAfterHeaderName];
        const retryAfterSeconds = Number(retryAfter);
        if (!Number.isNaN(retryAfterSeconds)) return new Date(retryAfterSeconds * 1000);
        const retryAfterDate = new Date(retryAfter);
        return retryAfterDate;
      };
      ;
      ;
      class NoOpLogger {
        trace() {}
        debug() {}
        info() {}
        warn() {}
        error() {}
      }
      ;
      const constructStack = () => {
        let absoluteEntries = [];
        let relativeEntries = [];
        const entriesNameSet = new Set();
        const sort = entries => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] || priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
        const removeByName = toRemove => {
          let isRemoved = false;
          const filterCb = entry => {
            if (entry.name && entry.name === toRemove) {
              isRemoved = true;
              entriesNameSet.delete(toRemove);
              return false;
            }
            return true;
          };
          absoluteEntries = absoluteEntries.filter(filterCb);
          relativeEntries = relativeEntries.filter(filterCb);
          return isRemoved;
        };
        const removeByReference = toRemove => {
          let isRemoved = false;
          const filterCb = entry => {
            if (entry.middleware === toRemove) {
              isRemoved = true;
              if (entry.name) entriesNameSet.delete(entry.name);
              return false;
            }
            return true;
          };
          absoluteEntries = absoluteEntries.filter(filterCb);
          relativeEntries = relativeEntries.filter(filterCb);
          return isRemoved;
        };
        const cloneTo = toStack => {
          absoluteEntries.forEach(entry => {
            toStack.add(entry.middleware, {
              ...entry
            });
          });
          relativeEntries.forEach(entry => {
            toStack.addRelativeTo(entry.middleware, {
              ...entry
            });
          });
          return toStack;
        };
        const expandRelativeMiddlewareList = from => {
          const expandedMiddlewareList = [];
          from.before.forEach(entry => {
            if (entry.before.length === 0 && entry.after.length === 0) {
              expandedMiddlewareList.push(entry);
            } else {
              expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
          });
          expandedMiddlewareList.push(from);
          from.after.reverse().forEach(entry => {
            if (entry.before.length === 0 && entry.after.length === 0) {
              expandedMiddlewareList.push(entry);
            } else {
              expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
          });
          return expandedMiddlewareList;
        };
        const getMiddlewareList = (debug = false) => {
          const normalizedAbsoluteEntries = [];
          const normalizedRelativeEntries = [];
          const normalizedEntriesNameMap = {};
          absoluteEntries.forEach(entry => {
            const normalizedEntry = {
              ...entry,
              before: [],
              after: []
            };
            if (normalizedEntry.name) normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
            normalizedAbsoluteEntries.push(normalizedEntry);
          });
          relativeEntries.forEach(entry => {
            const normalizedEntry = {
              ...entry,
              before: [],
              after: []
            };
            if (normalizedEntry.name) normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
            normalizedRelativeEntries.push(normalizedEntry);
          });
          normalizedRelativeEntries.forEach(entry => {
            if (entry.toMiddleware) {
              const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
              if (toMiddleware === undefined) {
                if (debug) {
                  return;
                }
                throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
              }
              if (entry.relation === "after") {
                toMiddleware.after.push(entry);
              }
              if (entry.relation === "before") {
                toMiddleware.before.push(entry);
              }
            }
          });
          const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
          }, []);
          return mainChain;
        };
        const stack = {
          add: (middleware, options = {}) => {
            const {
              name,
              override
            } = options;
            const entry = {
              step: "initialize",
              priority: "normal",
              middleware,
              ...options
            };
            if (name) {
              if (entriesNameSet.has(name)) {
                if (!override) throw new Error(`Duplicate middleware name '${name}'`);
                const toOverrideIndex = absoluteEntries.findIndex(entry => entry.name === name);
                const toOverride = absoluteEntries[toOverrideIndex];
                if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
                  throw new Error(`"${name}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be ` + `overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
                }
                absoluteEntries.splice(toOverrideIndex, 1);
              }
              entriesNameSet.add(name);
            }
            absoluteEntries.push(entry);
          },
          addRelativeTo: (middleware, options) => {
            const {
              name,
              override
            } = options;
            const entry = {
              middleware,
              ...options
            };
            if (name) {
              if (entriesNameSet.has(name)) {
                if (!override) throw new Error(`Duplicate middleware name '${name}'`);
                const toOverrideIndex = relativeEntries.findIndex(entry => entry.name === name);
                const toOverride = relativeEntries[toOverrideIndex];
                if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                  throw new Error(`"${name}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` + `by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
                }
                relativeEntries.splice(toOverrideIndex, 1);
              }
              entriesNameSet.add(name);
            }
            relativeEntries.push(entry);
          },
          clone: () => cloneTo(constructStack()),
          use: plugin => {
            plugin.applyToStack(stack);
          },
          remove: toRemove => {
            if (typeof toRemove === "string") return removeByName(toRemove);else return removeByReference(toRemove);
          },
          removeByTag: toRemove => {
            let isRemoved = false;
            const filterCb = entry => {
              const {
                tags,
                name
              } = entry;
              if (tags && tags.includes(toRemove)) {
                if (name) entriesNameSet.delete(name);
                isRemoved = true;
                return false;
              }
              return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
          },
          concat: from => {
            const cloned = cloneTo(constructStack());
            cloned.use(from);
            return cloned;
          },
          applyToStack: cloneTo,
          identify: () => {
            return getMiddlewareList(true).map(mw => {
              return mw.name + ": " + (mw.tags || []).join(",");
            });
          },
          resolve: (handler, context) => {
            for (const middleware of getMiddlewareList().map(entry => entry.middleware).reverse()) {
              handler = middleware(handler, context);
            }
            return handler;
          }
        };
        return stack;
      };
      const stepWeights = {
        initialize: 5,
        serialize: 4,
        build: 3,
        finalizeRequest: 2,
        deserialize: 1
      };
      const priorityWeights = {
        high: 3,
        normal: 2,
        low: 1
      };
      ;
      ;
      class Client {
        constructor(config) {
          this.middlewareStack = constructStack();
          this.config = config;
        }
        send(command, optionsOrCb, cb) {
          const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
          const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
          const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
          if (callback) {
            handler(command).then(result => callback(null, result.output), err => callback(err)).catch(() => {});
          } else {
            return handler(command).then(result => result.output);
          }
        }
        destroy() {
          if (this.config.requestHandler.destroy) this.config.requestHandler.destroy();
        }
      }
      ;
      const alphabetByEncoding = {};
      const alphabetByValue = new Array(64);
      for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        alphabetByEncoding[char] = i;
        alphabetByValue[i] = char;
      }
      for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        const index = i + 26;
        alphabetByEncoding[char] = index;
        alphabetByValue[index] = char;
      }
      for (let i = 0; i < 10; i++) {
        alphabetByEncoding[i.toString(10)] = i + 52;
        const char = i.toString(10);
        const index = i + 52;
        alphabetByEncoding[char] = index;
        alphabetByValue[index] = char;
      }
      alphabetByEncoding["+"] = 62;
      alphabetByValue[62] = "+";
      alphabetByEncoding["/"] = 63;
      alphabetByValue[63] = "/";
      const bitsPerLetter = 6;
      const bitsPerByte = 8;
      const maxLetterValue = 0b111111;
      ;
      const fromBase64 = input => {
        let totalByteLength = input.length / 4 * 3;
        if (input.slice(-2) === "==") {
          totalByteLength -= 2;
        } else if (input.slice(-1) === "=") {
          totalByteLength--;
        }
        const out = new ArrayBuffer(totalByteLength);
        const dataView = new DataView(out);
        for (let i = 0; i < input.length; i += 4) {
          let bits = 0;
          let bitLength = 0;
          for (let j = i, limit = i + 3; j <= limit; j++) {
            if (input[j] !== "=") {
              if (!(input[j] in alphabetByEncoding)) {
                throw new TypeError(`Invalid character ${input[j]} in base64 string.`);
              }
              bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;
              bitLength += bitsPerLetter;
            } else {
              bits >>= bitsPerLetter;
            }
          }
          const chunkOffset = i / 4 * 3;
          bits >>= bitLength % bitsPerByte;
          const byteLength = Math.floor(bitLength / bitsPerByte);
          for (let k = 0; k < byteLength; k++) {
            const offset = (byteLength - k - 1) * bitsPerByte;
            dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);
          }
        }
        return new Uint8Array(out);
      };
      ;
      function toBase64_browser_toBase64(input) {
        let str = "";
        for (let i = 0; i < input.length; i += 3) {
          let bits = 0;
          let bitLength = 0;
          for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {
            bits |= input[j] << (limit - j - 1) * bitsPerByte;
            bitLength += bitsPerByte;
          }
          const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
          bits <<= bitClusterCount * bitsPerLetter - bitLength;
          for (let k = 1; k <= bitClusterCount; k++) {
            const offset = (bitClusterCount - k) * bitsPerLetter;
            str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
          }
          str += "==".slice(0, 4 - bitClusterCount);
        }
        return str;
      }
      ;
      ;
      function transformToString(payload, encoding = "utf-8") {
        if (encoding === "base64") {
          return toBase64_browser_toBase64(payload);
        }
        return toUtf8_browser_toUtf8(payload);
      }
      function transformFromString(str, encoding) {
        if (encoding === "base64") {
          return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
        }
        return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
      }
      ;
      class Uint8ArrayBlobAdapter extends Uint8Array {
        static fromString(source, encoding = "utf-8") {
          switch (typeof source) {
            case "string":
              return transformFromString(source, encoding);
            default:
              throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
          }
        }
        static mutate(source) {
          Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
          return source;
        }
        transformToString(encoding = "utf-8") {
          return transformToString(this, encoding);
        }
      }
      ;
      function buildQueryString(query) {
        const parts = [];
        for (let key of Object.keys(query).sort()) {
          const value = query[key];
          key = escapeUri(key);
          if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
              parts.push(`${key}=${escapeUri(value[i])}`);
            }
          } else {
            let qsEntry = key;
            if (value || typeof value === "string") {
              qsEntry += `=${escapeUri(value)}`;
            }
            parts.push(qsEntry);
          }
        }
        return parts.join("&");
      }
      ;
      function requestTimeout(timeoutInMs = 0) {
        return new Promise((resolve, reject) => {
          if (timeoutInMs) {
            setTimeout(() => {
              const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
              timeoutError.name = "TimeoutError";
              reject(timeoutError);
            }, timeoutInMs);
          }
        });
      }
      ;
      class FetchHttpHandler {
        constructor(options) {
          if (typeof options === "function") {
            this.configProvider = options().then(opts => opts || {});
          } else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
          }
        }
        destroy() {}
        async handle(request, {
          abortSignal
        } = {}) {
          if (!this.config) {
            this.config = await this.configProvider;
          }
          const requestTimeoutInMs = this.config.requestTimeout;
          if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
          }
          let path = request.path;
          const queryString = buildQueryString(request.query || {});
          if (queryString) {
            path += `?${queryString}`;
          }
          if (request.fragment) {
            path += `#${request.fragment}`;
          }
          let auth = "";
          if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
          }
          const {
            port,
            method
          } = request;
          const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
          const body = method === "GET" || method === "HEAD" ? undefined : request.body;
          const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method
          };
          if (typeof AbortController !== "undefined") {
            requestOptions["signal"] = abortSignal;
          }
          const fetchRequest = new Request(url, requestOptions);
          const raceOfPromises = [fetch(fetchRequest).then(response => {
            const fetchHeaders = response.headers;
            const transformedHeaders = {};
            for (const pair of fetchHeaders.entries()) {
              transformedHeaders[pair[0]] = pair[1];
            }
            const hasReadableStream = response.body != undefined;
            if (!hasReadableStream) {
              return response.blob().then(body => ({
                response: new httpResponse_HttpResponse({
                  headers: transformedHeaders,
                  reason: response.statusText,
                  statusCode: response.status,
                  body
                })
              }));
            }
            return {
              response: new httpResponse_HttpResponse({
                headers: transformedHeaders,
                reason: response.statusText,
                statusCode: response.status,
                body: response.body
              })
            };
          }), requestTimeout(requestTimeoutInMs)];
          if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
              abortSignal.onabort = () => {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
              };
            }));
          }
          return Promise.race(raceOfPromises);
        }
        updateHttpClientConfig(key, value) {
          this.config = undefined;
          this.configProvider = this.configProvider.then(config => {
            config[key] = value;
            return config;
          });
        }
        httpHandlerConfigs() {
          return this.config ?? {};
        }
      }
      ;
      const stream_collector_streamCollector = stream => {
        if (typeof Blob === "function" && stream instanceof Blob) {
          return collectBlob(stream);
        }
        return collectStream(stream);
      };
      async function collectBlob(blob) {
        const base64 = await readToBase64(blob);
        const arrayBuffer = fromBase64(base64);
        return new Uint8Array(arrayBuffer);
      }
      async function collectStream(stream) {
        let res = new Uint8Array(0);
        const reader = stream.getReader();
        let isDone = false;
        while (!isDone) {
          const {
            done,
            value
          } = await reader.read();
          if (value) {
            const prior = res;
            res = new Uint8Array(prior.length + value.length);
            res.set(prior);
            res.set(value, prior.length);
          }
          isDone = done;
        }
        return res;
      }
      function readToBase64(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            if (reader.readyState !== 2) {
              return reject(new Error("Reader aborted too early"));
            }
            const result = reader.result ?? "";
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
          };
          reader.onabort = () => reject(new Error("Read aborted"));
          reader.onerror = () => reject(reader.error);
          reader.readAsDataURL(blob);
        });
      }
      ;
      ;
      const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
      const sdkStreamMixin = stream => {
        if (!isBlobInstance(stream) && !isReadableStreamInstance(stream)) {
          const name = stream?.__proto__?.constructor?.name || stream;
          throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
        }
        let transformed = false;
        const transformToByteArray = async () => {
          if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
          }
          transformed = true;
          return await streamCollector(stream);
        };
        const blobToWebStream = blob => {
          if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" + "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
          }
          return blob.stream();
        };
        return Object.assign(stream, {
          transformToByteArray: transformToByteArray,
          transformToString: async encoding => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
              return toBase64(buf);
            } else if (encoding === "hex") {
              return toHex(buf);
            } else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
              return toUtf8(buf);
            } else if (typeof TextDecoder === "function") {
              return new TextDecoder(encoding).decode(buf);
            } else {
              throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
          },
          transformToWebStream: () => {
            if (transformed) {
              throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
              return blobToWebStream(stream);
            } else if (isReadableStreamInstance(stream)) {
              return stream;
            } else {
              throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
          }
        });
      };
      const isBlobInstance = stream => typeof Blob === "function" && stream instanceof Blob;
      const isReadableStreamInstance = stream => typeof ReadableStream === "function" && stream instanceof ReadableStream;
      ;
      ;
      const collectBody = async (streamBody = new Uint8Array(), context) => {
        if (streamBody instanceof Uint8Array) {
          return Uint8ArrayBlobAdapter.mutate(streamBody);
        }
        if (!streamBody) {
          return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
        }
        const fromContext = context.streamCollector(streamBody);
        return Uint8ArrayBlobAdapter.mutate(await fromContext);
      };
      ;
      class Command {
        constructor() {
          this.middlewareStack = constructStack();
        }
      }
      ;
      const SENSITIVE_STRING = "***SensitiveInformation***";
      ;
      const createAggregatedClient = (commands, Client) => {
        for (const command of Object.keys(commands)) {
          const CommandCtor = commands[command];
          const methodImpl = async function (args, optionsOrCb, cb) {
            const command = new CommandCtor(args);
            if (typeof optionsOrCb === "function") {
              this.send(command, optionsOrCb);
            } else if (typeof cb === "function") {
              if (typeof optionsOrCb !== "object") throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
              this.send(command, optionsOrCb || {}, cb);
            } else {
              return this.send(command, optionsOrCb);
            }
          };
          const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
          Client.prototype[methodName] = methodImpl;
        }
      };
      ;
      const parseBoolean = value => {
        switch (value) {
          case "true":
            return true;
          case "false":
            return false;
          default:
            throw new Error(`Unable to parse boolean value "${value}"`);
        }
      };
      const expectBoolean = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        if (typeof value === "number") {
          if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
          }
          if (value === 0) {
            return false;
          }
          if (value === 1) {
            return true;
          }
        }
        if (typeof value === "string") {
          const lower = value.toLowerCase();
          if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
          }
          if (lower === "false") {
            return false;
          }
          if (lower === "true") {
            return true;
          }
        }
        if (typeof value === "boolean") {
          return value;
        }
        throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
      };
      const expectNumber = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        if (typeof value === "string") {
          const parsed = parseFloat(value);
          if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
              logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
          }
        }
        if (typeof value === "number") {
          return value;
        }
        throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
      };
      const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
      const expectFloat32 = value => {
        const expected = expectNumber(value);
        if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
          if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
          }
        }
        return expected;
      };
      const expectLong = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        if (Number.isInteger(value) && !Number.isNaN(value)) {
          return value;
        }
        throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
      };
      const expectInt = null && expectLong;
      const expectInt32 = value => expectSizedInt(value, 32);
      const expectShort = value => expectSizedInt(value, 16);
      const expectByte = value => expectSizedInt(value, 8);
      const expectSizedInt = (value, size) => {
        const expected = expectLong(value);
        if (expected !== undefined && castInt(expected, size) !== expected) {
          throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
        }
        return expected;
      };
      const castInt = (value, size) => {
        switch (size) {
          case 32:
            return Int32Array.of(value)[0];
          case 16:
            return Int16Array.of(value)[0];
          case 8:
            return Int8Array.of(value)[0];
        }
      };
      const expectNonNull = (value, location) => {
        if (value === null || value === undefined) {
          if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
          }
          throw new TypeError("Expected a non-null value");
        }
        return value;
      };
      const expectObject = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        if (typeof value === "object" && !Array.isArray(value)) {
          return value;
        }
        const receivedType = Array.isArray(value) ? "array" : typeof value;
        throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
      };
      const expectString = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        if (typeof value === "string") {
          return value;
        }
        if (["boolean", "number", "bigint"].includes(typeof value)) {
          logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
          return String(value);
        }
        throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
      };
      const expectUnion = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        const asObject = expectObject(value);
        const setKeys = Object.entries(asObject).filter(([, v]) => v != null).map(([k]) => k);
        if (setKeys.length === 0) {
          throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
        }
        if (setKeys.length > 1) {
          throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
        }
        return asObject;
      };
      const strictParseDouble = value => {
        if (typeof value == "string") {
          return expectNumber(parseNumber(value));
        }
        return expectNumber(value);
      };
      const strictParseFloat = null && strictParseDouble;
      const parse_utils_strictParseFloat32 = value => {
        if (typeof value == "string") {
          return expectFloat32(parseNumber(value));
        }
        return expectFloat32(value);
      };
      const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
      const parseNumber = value => {
        const matches = value.match(NUMBER_REGEX);
        if (matches === null || matches[0].length !== value.length) {
          throw new TypeError(`Expected real number, got implicit NaN`);
        }
        return parseFloat(value);
      };
      const limitedParseDouble = value => {
        if (typeof value == "string") {
          return parseFloatString(value);
        }
        return expectNumber(value);
      };
      const handleFloat = null && limitedParseDouble;
      const limitedParseFloat = null && limitedParseDouble;
      const limitedParseFloat32 = value => {
        if (typeof value == "string") {
          return parseFloatString(value);
        }
        return expectFloat32(value);
      };
      const parseFloatString = value => {
        switch (value) {
          case "NaN":
            return NaN;
          case "Infinity":
            return Infinity;
          case "-Infinity":
            return -Infinity;
          default:
            throw new Error(`Unable to parse float value: ${value}`);
        }
      };
      const strictParseLong = value => {
        if (typeof value === "string") {
          return expectLong(parseNumber(value));
        }
        return expectLong(value);
      };
      const strictParseInt = null && strictParseLong;
      const strictParseInt32 = value => {
        if (typeof value === "string") {
          return expectInt32(parseNumber(value));
        }
        return expectInt32(value);
      };
      const parse_utils_strictParseShort = value => {
        if (typeof value === "string") {
          return expectShort(parseNumber(value));
        }
        return expectShort(value);
      };
      const parse_utils_strictParseByte = value => {
        if (typeof value === "string") {
          return expectByte(parseNumber(value));
        }
        return expectByte(value);
      };
      const stackTraceWarning = message => {
        return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter(s => !s.includes("stackTraceWarning")).join("\n");
      };
      const logger = {
        warn: console.warn
      };
      ;
      const DAYS = null && ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      const MONTHS = null && ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      function dateToUtcString(date) {
        const year = date.getUTCFullYear();
        const month = date.getUTCMonth();
        const dayOfWeek = date.getUTCDay();
        const dayOfMonthInt = date.getUTCDate();
        const hoursInt = date.getUTCHours();
        const minutesInt = date.getUTCMinutes();
        const secondsInt = date.getUTCSeconds();
        const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
        const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
        const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
        const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
        return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
      }
      const RFC3339 = null && new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
      const parseRfc3339DateTime = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        if (typeof value !== "string") {
          throw new TypeError("RFC-3339 date-times must be expressed as strings");
        }
        const match = RFC3339.exec(value);
        if (!match) {
          throw new TypeError("Invalid RFC-3339 date-time value");
        }
        const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        const year = strictParseShort(stripLeadingZeroes(yearStr));
        const month = parseDateValue(monthStr, "month", 1, 12);
        const day = parseDateValue(dayStr, "day", 1, 31);
        return buildDate(year, month, day, {
          hours,
          minutes,
          seconds,
          fractionalMilliseconds
        });
      };
      const RFC3339_WITH_OFFSET = null && new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
      const parseRfc3339DateTimeWithOffset = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        if (typeof value !== "string") {
          throw new TypeError("RFC-3339 date-times must be expressed as strings");
        }
        const match = RFC3339_WITH_OFFSET.exec(value);
        if (!match) {
          throw new TypeError("Invalid RFC-3339 date-time value");
        }
        const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
        const year = strictParseShort(stripLeadingZeroes(yearStr));
        const month = parseDateValue(monthStr, "month", 1, 12);
        const day = parseDateValue(dayStr, "day", 1, 31);
        const date = buildDate(year, month, day, {
          hours,
          minutes,
          seconds,
          fractionalMilliseconds
        });
        if (offsetStr.toUpperCase() != "Z") {
          date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
        }
        return date;
      };
      const IMF_FIXDATE = null && new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
      const RFC_850_DATE = null && new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
      const ASC_TIME = null && new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
      const parseRfc7231DateTime = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        if (typeof value !== "string") {
          throw new TypeError("RFC-7231 date-times must be expressed as strings");
        }
        let match = IMF_FIXDATE.exec(value);
        if (match) {
          const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
          return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds
          });
        }
        match = RFC_850_DATE.exec(value);
        if (match) {
          const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
          return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds
          }));
        }
        match = ASC_TIME.exec(value);
        if (match) {
          const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
          return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds
          });
        }
        throw new TypeError("Invalid RFC-7231 date-time value");
      };
      const parseEpochTimestamp = value => {
        if (value === null || value === undefined) {
          return undefined;
        }
        let valueAsDouble;
        if (typeof value === "number") {
          valueAsDouble = value;
        } else if (typeof value === "string") {
          valueAsDouble = strictParseDouble(value);
        } else {
          throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
        }
        if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
          throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
        }
        return new Date(Math.round(valueAsDouble * 1000));
      };
      const buildDate = (year, month, day, time) => {
        const adjustedMonth = month - 1;
        validateDayOfMonth(year, adjustedMonth, day);
        return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
      };
      const parseTwoDigitYear = value => {
        const thisYear = new Date().getUTCFullYear();
        const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
        if (valueInThisCentury < thisYear) {
          return valueInThisCentury + 100;
        }
        return valueInThisCentury;
      };
      const FIFTY_YEARS_IN_MILLIS = null && 50 * 365 * 24 * 60 * 60 * 1000;
      const adjustRfc850Year = input => {
        if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
          return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
        }
        return input;
      };
      const parseMonthByShortName = value => {
        const monthIdx = MONTHS.indexOf(value);
        if (monthIdx < 0) {
          throw new TypeError(`Invalid month: ${value}`);
        }
        return monthIdx + 1;
      };
      const DAYS_IN_MONTH = null && [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      const validateDayOfMonth = (year, month, day) => {
        let maxDays = DAYS_IN_MONTH[month];
        if (month === 1 && isLeapYear(year)) {
          maxDays = 29;
        }
        if (day > maxDays) {
          throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
        }
      };
      const isLeapYear = year => {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      };
      const parseDateValue = (value, type, lower, upper) => {
        const dateVal = strictParseByte(stripLeadingZeroes(value));
        if (dateVal < lower || dateVal > upper) {
          throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
        }
        return dateVal;
      };
      const parseMilliseconds = value => {
        if (value === null || value === undefined) {
          return 0;
        }
        return strictParseFloat32("0." + value) * 1000;
      };
      const parseOffsetToMilliseconds = value => {
        const directionStr = value[0];
        let direction = 1;
        if (directionStr == "+") {
          direction = 1;
        } else if (directionStr == "-") {
          direction = -1;
        } else {
          throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
        }
        const hour = Number(value.substring(1, 3));
        const minute = Number(value.substring(4, 6));
        return direction * (hour * 60 + minute) * 60 * 1000;
      };
      const stripLeadingZeroes = value => {
        let idx = 0;
        while (idx < value.length - 1 && value.charAt(idx) === "0") {
          idx++;
        }
        if (idx === 0) {
          return value;
        }
        return value.slice(idx);
      };
      ;
      class ServiceException extends Error {
        constructor(options) {
          super(options.message);
          Object.setPrototypeOf(this, ServiceException.prototype);
          this.name = options.name;
          this.$fault = options.$fault;
          this.$metadata = options.$metadata;
        }
      }
      const decorateServiceException = (exception, additions = {}) => {
        Object.entries(additions).filter(([, v]) => v !== undefined).forEach(([k, v]) => {
          if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
          }
        });
        const message = exception.message || exception.Message || "UnknownError";
        exception.message = message;
        delete exception.Message;
        return exception;
      };
      ;
      const throwDefaultError = ({
        output,
        parsedBody,
        exceptionCtor,
        errorCode
      }) => {
        const $metadata = deserializeMetadata(output);
        const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
        const response = new exceptionCtor({
          name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
          $fault: "client",
          $metadata
        });
        throw decorateServiceException(response, parsedBody);
      };
      const withBaseException = ExceptionCtor => {
        return ({
          output,
          parsedBody,
          errorCode
        }) => {
          throwDefaultError({
            output,
            parsedBody,
            exceptionCtor: ExceptionCtor,
            errorCode
          });
        };
      };
      const deserializeMetadata = output => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"]
      });
      ;
      const loadConfigsForDefaultMode = mode => {
        switch (mode) {
          case "standard":
            return {
              retryMode: "standard",
              connectionTimeout: 3100
            };
          case "in-region":
            return {
              retryMode: "standard",
              connectionTimeout: 1100
            };
          case "cross-region":
            return {
              retryMode: "standard",
              connectionTimeout: 3100
            };
          case "mobile":
            return {
              retryMode: "standard",
              connectionTimeout: 30000
            };
          default:
            return {};
        }
      };
      ;
      const extensions_checksum_getChecksumConfiguration = runtimeConfig => {
        const checksumAlgorithms = [];
        for (const id in AlgorithmId) {
          const algorithmId = AlgorithmId[id];
          if (runtimeConfig[algorithmId] === undefined) {
            continue;
          }
          checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId]
          });
        }
        return {
          _checksumAlgorithms: checksumAlgorithms,
          addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
          },
          checksumAlgorithms() {
            return this._checksumAlgorithms;
          }
        };
      };
      const extensions_checksum_resolveChecksumRuntimeConfig = clientConfig => {
        const runtimeConfig = {};
        clientConfig.checksumAlgorithms().forEach(checksumAlgorithm => {
          runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
        });
        return runtimeConfig;
      };
      ;
      const getRetryConfiguration = runtimeConfig => {
        let _retryStrategy = runtimeConfig.retryStrategy;
        return {
          setRetryStrategy(retryStrategy) {
            _retryStrategy = retryStrategy;
          },
          retryStrategy() {
            return _retryStrategy;
          }
        };
      };
      const resolveRetryRuntimeConfig = retryStrategyConfiguration => {
        const runtimeConfig = {};
        runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
        return runtimeConfig;
      };
      ;
      const getDefaultExtensionConfiguration = runtimeConfig => {
        return {
          ...extensions_checksum_getChecksumConfiguration(runtimeConfig),
          ...getRetryConfiguration(runtimeConfig)
        };
      };
      const defaultExtensionConfiguration_getDefaultClientConfiguration = null && getDefaultExtensionConfiguration;
      const defaultExtensionConfiguration_resolveDefaultRuntimeConfig = config => {
        return {
          ...extensions_checksum_resolveChecksumRuntimeConfig(config),
          ...resolveRetryRuntimeConfig(config)
        };
      };
      ;
      ;
      const StringWrapper = function () {
        const Class = Object.getPrototypeOf(this).constructor;
        const Constructor = Function.bind.apply(String, [null, ...arguments]);
        const instance = new Constructor();
        Object.setPrototypeOf(instance, Class.prototype);
        return instance;
      };
      StringWrapper.prototype = Object.create(String.prototype, {
        constructor: {
          value: StringWrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      Object.setPrototypeOf(StringWrapper, String);
      class LazyJsonString extends (null && StringWrapper) {
        deserializeJSON() {
          return JSON.parse(super.toString());
        }
        toJSON() {
          return super.toString();
        }
        static fromObject(object) {
          if (object instanceof LazyJsonString) {
            return object;
          } else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
          }
          return new LazyJsonString(JSON.stringify(object));
        }
      }
      ;
      function map(arg0, arg1, arg2) {
        let target;
        let filter;
        let instructions;
        if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
          target = {};
          instructions = arg0;
        } else {
          target = arg0;
          if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
          } else {
            instructions = arg1;
          }
        }
        for (const key of Object.keys(instructions)) {
          if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
          }
          applyInstruction(target, null, instructions, key);
        }
        return target;
      }
      const convertMap = target => {
        const output = {};
        for (const [k, v] of Object.entries(target || {})) {
          output[k] = [, v];
        }
        return output;
      };
      const take = (source, instructions) => {
        const out = {};
        for (const key in instructions) {
          applyInstruction(out, source, instructions, key);
        }
        return out;
      };
      const mapWithFilter = (target, filter, instructions) => {
        return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
          if (Array.isArray(value)) {
            _instructions[key] = value;
          } else {
            if (typeof value === "function") {
              _instructions[key] = [filter, value()];
            } else {
              _instructions[key] = [filter, value];
            }
          }
          return _instructions;
        }, {}));
      };
      const applyInstruction = (target, source, instructions, targetKey) => {
        if (source !== null) {
          let instruction = instructions[targetKey];
          if (typeof instruction === "function") {
            instruction = [, instruction];
          }
          const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
          if (typeof filter === "function" && filter(source[sourceKey]) || typeof filter !== "function" && !!filter) {
            target[targetKey] = valueFn(source[sourceKey]);
          }
          return;
        }
        let [filter, value] = instructions[targetKey];
        if (typeof value === "function") {
          let _value;
          const defaultFilterPassed = filter === undefined && (_value = value()) != null;
          const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
          if (defaultFilterPassed) {
            target[targetKey] = _value;
          } else if (customFilterPassed) {
            target[targetKey] = value();
          }
        } else {
          const defaultFilterPassed = filter === undefined && value != null;
          const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
          if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
          }
        }
      };
      const nonNullish = _ => _ != null;
      const pass = _ => _;
      ;
      const _json = obj => {
        if (obj == null) {
          return {};
        }
        if (Array.isArray(obj)) {
          return obj.filter(_ => _ != null);
        }
        if (typeof obj === "object") {
          const target = {};
          for (const key of Object.keys(obj)) {
            if (obj[key] == null) {
              continue;
            }
            target[key] = _json(obj[key]);
          }
          return target;
        }
        return obj;
      };
      ;
      ;
      const resolveClientEndpointParameters = options => {
        return {
          ...options,
          useDualstackEndpoint: options.useDualstackEndpoint ?? false,
          useFipsEndpoint: options.useFipsEndpoint ?? false,
          defaultSigningName: "cognito-idp"
        };
      };
      ;
      const package_namespaceObject = {
        "i8": "3.410.0"
      };
      var sha256_browser_build = __webpack_require__(8322);
      var es5 = __webpack_require__(7160);
      var es5_default = __webpack_require__.n(es5);
      ;
      const defaultUserAgent = ({
        serviceId,
        clientVersion
      }) => async () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? es5_default().parse(window.navigator.userAgent) : undefined;
        const sections = [["aws-sdk-js", clientVersion], ["ua", "2.0"], [`os/${parsedUA?.os?.name || "other"}`, parsedUA?.os?.version], ["lang/js"], ["md/browser", `${parsedUA?.browser?.name ?? "unknown"}_${parsedUA?.browser?.version ?? "unknown"}`]];
        if (serviceId) {
          sections.push([`api/${serviceId}`, clientVersion]);
        }
        return sections;
      };
      ;
      const invalidProvider = message => () => Promise.reject(message);
      ;
      const calculateBodyLength = body => {
        if (typeof body === "string") {
          let len = body.length;
          for (let i = len - 1; i >= 0; i--) {
            const code = body.charCodeAt(i);
            if (code > 0x7f && code <= 0x7ff) len++;else if (code > 0x7ff && code <= 0xffff) len += 2;
            if (code >= 0xdc00 && code <= 0xdfff) i--;
          }
          return len;
        } else if (typeof body.byteLength === "number") {
          return body.byteLength;
        } else if (typeof body.size === "number") {
          return body.size;
        }
        throw new Error(`Body Length computation failed for ${body}`);
      };
      ;
      const q = "required",
        r = "fn",
        s = "argv",
        t = "ref";
      const a = "isSet",
        b = "tree",
        c = "error",
        d = "endpoint",
        e = "PartitionResult",
        f = {
          [q]: false,
          "type": "String"
        },
        g = {
          [q]: true,
          "default": false,
          "type": "Boolean"
        },
        h = {
          [t]: "Endpoint"
        },
        ruleset_i = {
          [r]: "booleanEquals",
          [s]: [{
            [t]: "UseFIPS"
          }, true]
        },
        j = {
          [r]: "booleanEquals",
          [s]: [{
            [t]: "UseDualStack"
          }, true]
        },
        k = {},
        l = {
          [r]: "booleanEquals",
          [s]: [true, {
            [r]: "getAttr",
            [s]: [{
              [t]: e
            }, "supportsFIPS"]
          }]
        },
        m = {
          [r]: "booleanEquals",
          [s]: [true, {
            [r]: "getAttr",
            [s]: [{
              [t]: e
            }, "supportsDualStack"]
          }]
        },
        n = [ruleset_i],
        o = [j],
        p = [{
          [t]: "Region"
        }];
      const _data = {
        version: "1.0",
        parameters: {
          Region: f,
          UseDualStack: g,
          UseFIPS: g,
          Endpoint: f
        },
        rules: [{
          conditions: [{
            [r]: a,
            [s]: [h]
          }],
          type: b,
          rules: [{
            conditions: n,
            error: "Invalid Configuration: FIPS and custom endpoint are not supported",
            type: c
          }, {
            conditions: o,
            error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
            type: c
          }, {
            endpoint: {
              url: h,
              properties: k,
              headers: k
            },
            type: d
          }]
        }, {
          conditions: [{
            [r]: a,
            [s]: p
          }],
          type: b,
          rules: [{
            conditions: [{
              [r]: "aws.partition",
              [s]: p,
              assign: e
            }],
            type: b,
            rules: [{
              conditions: [ruleset_i, j],
              type: b,
              rules: [{
                conditions: [l, m],
                type: b,
                rules: [{
                  endpoint: {
                    url: "https://cognito-idp-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                    properties: k,
                    headers: k
                  },
                  type: d
                }]
              }, {
                error: "FIPS and DualStack are enabled, but this partition does not support one or both",
                type: c
              }]
            }, {
              conditions: n,
              type: b,
              rules: [{
                conditions: [l],
                type: b,
                rules: [{
                  endpoint: {
                    url: "https://cognito-idp-fips.{Region}.{PartitionResult#dnsSuffix}",
                    properties: k,
                    headers: k
                  },
                  type: d
                }]
              }, {
                error: "FIPS is enabled but this partition does not support FIPS",
                type: c
              }]
            }, {
              conditions: o,
              type: b,
              rules: [{
                conditions: [m],
                type: b,
                rules: [{
                  endpoint: {
                    url: "https://cognito-idp.{Region}.{PartitionResult#dualStackDnsSuffix}",
                    properties: k,
                    headers: k
                  },
                  type: d
                }]
              }, {
                error: "DualStack is enabled but this partition does not support DualStack",
                type: c
              }]
            }, {
              endpoint: {
                url: "https://cognito-idp.{Region}.{PartitionResult#dnsSuffix}",
                properties: k,
                headers: k
              },
              type: d
            }]
          }]
        }, {
          error: "Invalid Configuration: Missing Region",
          type: c
        }]
      };
      const ruleSet = _data;
      ;
      const defaultEndpointResolver = (endpointParams, context = {}) => {
        return resolveEndpoint(ruleSet, {
          endpointParams: endpointParams,
          logger: context.logger
        });
      };
      ;
      const getRuntimeConfig = config => ({
        apiVersion: "2016-04-18",
        base64Decoder: config?.base64Decoder ?? fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64_browser_toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        logger: config?.logger ?? new NoOpLogger(),
        serviceId: config?.serviceId ?? "Cognito Identity Provider",
        urlParser: config?.urlParser ?? parseUrl,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? toUtf8_browser_toUtf8
      });
      ;
      const DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
      ;
      const resolveDefaultsModeConfig = ({
        defaultsMode
      } = {}) => memoize(async () => {
        const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
        switch (mode?.toLowerCase()) {
          case "auto":
            return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
          case "mobile":
          case "in-region":
          case "cross-region":
          case "standard":
          case "legacy":
            return Promise.resolve(mode?.toLocaleLowerCase());
          case undefined:
            return Promise.resolve("legacy");
          default:
            throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
        }
      });
      const isMobileBrowser = () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? es5_default().parse(window.navigator.userAgent) : undefined;
        const platform = parsedUA?.platform?.type;
        return platform === "tablet" || platform === "mobile";
      };
      ;
      ;
      const runtimeConfig_browser_getRuntimeConfig = config => {
        const defaultsMode = resolveDefaultsModeConfig(config);
        const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
        const clientSharedValues = getRuntimeConfig(config);
        return {
          ...clientSharedValues,
          ...config,
          runtime: "browser",
          defaultsMode,
          bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
          credentialDefaultProvider: config?.credentialDefaultProvider ?? (_ => () => Promise.reject(new Error("Credential is missing"))),
          defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({
            serviceId: clientSharedValues.serviceId,
            clientVersion: package_namespaceObject.i8
          }),
          maxAttempts: config?.maxAttempts ?? config_DEFAULT_MAX_ATTEMPTS,
          region: config?.region ?? invalidProvider("Region is missing"),
          requestHandler: config?.requestHandler ?? new FetchHttpHandler(defaultConfigProvider),
          retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
          sha256: config?.sha256 ?? sha256_browser_build.Sha256,
          streamCollector: config?.streamCollector ?? stream_collector_streamCollector,
          useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
          useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
        };
      };
      ;
      const asPartial = t => t;
      const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
        const extensionConfiguration = {
          ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
          ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig))
        };
        extensions.forEach(extension => extension.configure(extensionConfiguration));
        return {
          ...runtimeConfig,
          ...defaultExtensionConfiguration_resolveDefaultRuntimeConfig(extensionConfiguration),
          ...resolveHttpHandlerRuntimeConfig(extensionConfiguration)
        };
      };
      ;
      class CognitoIdentityProviderClient extends Client {
        constructor(...[configuration]) {
          const _config_0 = runtimeConfig_browser_getRuntimeConfig(configuration || {});
          const _config_1 = resolveClientEndpointParameters(_config_0);
          const _config_2 = resolveRegionConfig(_config_1);
          const _config_3 = resolveEndpointConfig(_config_2);
          const _config_4 = resolveRetryConfig(_config_3);
          const _config_5 = resolveHostHeaderConfig(_config_4);
          const _config_6 = resolveAwsAuthConfig(_config_5);
          const _config_7 = resolveUserAgentConfig(_config_6);
          const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
          super(_config_8);
          this.config = _config_8;
          this.middlewareStack.use(getRetryPlugin(this.config));
          this.middlewareStack.use(getContentLengthPlugin(this.config));
          this.middlewareStack.use(getHostHeaderPlugin(this.config));
          this.middlewareStack.use(getLoggerPlugin(this.config));
          this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
          this.middlewareStack.use(getUserAgentPlugin(this.config));
        }
        destroy() {
          super.destroy();
        }
      }
      ;
      class CognitoIdentityProviderServiceException extends ServiceException {
        constructor(options) {
          super(options);
          Object.setPrototypeOf(this, CognitoIdentityProviderServiceException.prototype);
        }
      }
      ;
      const RecoveryOptionNameType = {
        ADMIN_ONLY: "admin_only",
        VERIFIED_EMAIL: "verified_email",
        VERIFIED_PHONE_NUMBER: "verified_phone_number"
      };
      const AccountTakeoverEventActionType = {
        BLOCK: "BLOCK",
        MFA_IF_CONFIGURED: "MFA_IF_CONFIGURED",
        MFA_REQUIRED: "MFA_REQUIRED",
        NO_ACTION: "NO_ACTION"
      };
      const AttributeDataType = {
        BOOLEAN: "Boolean",
        DATETIME: "DateTime",
        NUMBER: "Number",
        STRING: "String"
      };
      class InternalErrorException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "InternalErrorException",
            $fault: "server",
            ...opts
          });
          this.name = "InternalErrorException";
          this.$fault = "server";
          Object.setPrototypeOf(this, InternalErrorException.prototype);
        }
      }
      class InvalidParameterException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "InvalidParameterException",
            $fault: "client",
            ...opts
          });
          this.name = "InvalidParameterException";
          this.$fault = "client";
          Object.setPrototypeOf(this, InvalidParameterException.prototype);
        }
      }
      class NotAuthorizedException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "NotAuthorizedException",
            $fault: "client",
            ...opts
          });
          this.name = "NotAuthorizedException";
          this.$fault = "client";
          Object.setPrototypeOf(this, NotAuthorizedException.prototype);
        }
      }
      class ResourceNotFoundException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts
          });
          this.name = "ResourceNotFoundException";
          this.$fault = "client";
          Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
        }
      }
      class TooManyRequestsException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "TooManyRequestsException",
            $fault: "client",
            ...opts
          });
          this.name = "TooManyRequestsException";
          this.$fault = "client";
          Object.setPrototypeOf(this, TooManyRequestsException.prototype);
        }
      }
      class UserImportInProgressException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UserImportInProgressException",
            $fault: "client",
            ...opts
          });
          this.name = "UserImportInProgressException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UserImportInProgressException.prototype);
        }
      }
      class UserNotFoundException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UserNotFoundException",
            $fault: "client",
            ...opts
          });
          this.name = "UserNotFoundException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UserNotFoundException.prototype);
        }
      }
      class InvalidLambdaResponseException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "InvalidLambdaResponseException",
            $fault: "client",
            ...opts
          });
          this.name = "InvalidLambdaResponseException";
          this.$fault = "client";
          Object.setPrototypeOf(this, InvalidLambdaResponseException.prototype);
        }
      }
      class LimitExceededException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts
          });
          this.name = "LimitExceededException";
          this.$fault = "client";
          Object.setPrototypeOf(this, LimitExceededException.prototype);
        }
      }
      class TooManyFailedAttemptsException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "TooManyFailedAttemptsException",
            $fault: "client",
            ...opts
          });
          this.name = "TooManyFailedAttemptsException";
          this.$fault = "client";
          Object.setPrototypeOf(this, TooManyFailedAttemptsException.prototype);
        }
      }
      class UnexpectedLambdaException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UnexpectedLambdaException",
            $fault: "client",
            ...opts
          });
          this.name = "UnexpectedLambdaException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UnexpectedLambdaException.prototype);
        }
      }
      class UserLambdaValidationException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UserLambdaValidationException",
            $fault: "client",
            ...opts
          });
          this.name = "UserLambdaValidationException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UserLambdaValidationException.prototype);
        }
      }
      const DeliveryMediumType = {
        EMAIL: "EMAIL",
        SMS: "SMS"
      };
      const MessageActionType = {
        RESEND: "RESEND",
        SUPPRESS: "SUPPRESS"
      };
      const UserStatusType = {
        ARCHIVED: "ARCHIVED",
        COMPROMISED: "COMPROMISED",
        CONFIRMED: "CONFIRMED",
        FORCE_CHANGE_PASSWORD: "FORCE_CHANGE_PASSWORD",
        RESET_REQUIRED: "RESET_REQUIRED",
        UNCONFIRMED: "UNCONFIRMED",
        UNKNOWN: "UNKNOWN"
      };
      class CodeDeliveryFailureException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "CodeDeliveryFailureException",
            $fault: "client",
            ...opts
          });
          this.name = "CodeDeliveryFailureException";
          this.$fault = "client";
          Object.setPrototypeOf(this, CodeDeliveryFailureException.prototype);
        }
      }
      class InvalidPasswordException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "InvalidPasswordException",
            $fault: "client",
            ...opts
          });
          this.name = "InvalidPasswordException";
          this.$fault = "client";
          Object.setPrototypeOf(this, InvalidPasswordException.prototype);
        }
      }
      class InvalidSmsRoleAccessPolicyException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "InvalidSmsRoleAccessPolicyException",
            $fault: "client",
            ...opts
          });
          this.name = "InvalidSmsRoleAccessPolicyException";
          this.$fault = "client";
          Object.setPrototypeOf(this, InvalidSmsRoleAccessPolicyException.prototype);
        }
      }
      class InvalidSmsRoleTrustRelationshipException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "InvalidSmsRoleTrustRelationshipException",
            $fault: "client",
            ...opts
          });
          this.name = "InvalidSmsRoleTrustRelationshipException";
          this.$fault = "client";
          Object.setPrototypeOf(this, InvalidSmsRoleTrustRelationshipException.prototype);
        }
      }
      class PreconditionNotMetException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "PreconditionNotMetException",
            $fault: "client",
            ...opts
          });
          this.name = "PreconditionNotMetException";
          this.$fault = "client";
          Object.setPrototypeOf(this, PreconditionNotMetException.prototype);
        }
      }
      class UnsupportedUserStateException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UnsupportedUserStateException",
            $fault: "client",
            ...opts
          });
          this.name = "UnsupportedUserStateException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UnsupportedUserStateException.prototype);
        }
      }
      class UsernameExistsException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UsernameExistsException",
            $fault: "client",
            ...opts
          });
          this.name = "UsernameExistsException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UsernameExistsException.prototype);
        }
      }
      class AliasExistsException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "AliasExistsException",
            $fault: "client",
            ...opts
          });
          this.name = "AliasExistsException";
          this.$fault = "client";
          Object.setPrototypeOf(this, AliasExistsException.prototype);
        }
      }
      class InvalidUserPoolConfigurationException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "InvalidUserPoolConfigurationException",
            $fault: "client",
            ...opts
          });
          this.name = "InvalidUserPoolConfigurationException";
          this.$fault = "client";
          Object.setPrototypeOf(this, InvalidUserPoolConfigurationException.prototype);
        }
      }
      const AuthFlowType = {
        ADMIN_NO_SRP_AUTH: "ADMIN_NO_SRP_AUTH",
        ADMIN_USER_PASSWORD_AUTH: "ADMIN_USER_PASSWORD_AUTH",
        CUSTOM_AUTH: "CUSTOM_AUTH",
        REFRESH_TOKEN: "REFRESH_TOKEN",
        REFRESH_TOKEN_AUTH: "REFRESH_TOKEN_AUTH",
        USER_PASSWORD_AUTH: "USER_PASSWORD_AUTH",
        USER_SRP_AUTH: "USER_SRP_AUTH"
      };
      const ChallengeNameType = {
        ADMIN_NO_SRP_AUTH: "ADMIN_NO_SRP_AUTH",
        CUSTOM_CHALLENGE: "CUSTOM_CHALLENGE",
        DEVICE_PASSWORD_VERIFIER: "DEVICE_PASSWORD_VERIFIER",
        DEVICE_SRP_AUTH: "DEVICE_SRP_AUTH",
        MFA_SETUP: "MFA_SETUP",
        NEW_PASSWORD_REQUIRED: "NEW_PASSWORD_REQUIRED",
        PASSWORD_VERIFIER: "PASSWORD_VERIFIER",
        SELECT_MFA_TYPE: "SELECT_MFA_TYPE",
        SMS_MFA: "SMS_MFA",
        SOFTWARE_TOKEN_MFA: "SOFTWARE_TOKEN_MFA"
      };
      class MFAMethodNotFoundException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "MFAMethodNotFoundException",
            $fault: "client",
            ...opts
          });
          this.name = "MFAMethodNotFoundException";
          this.$fault = "client";
          Object.setPrototypeOf(this, MFAMethodNotFoundException.prototype);
        }
      }
      class PasswordResetRequiredException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "PasswordResetRequiredException",
            $fault: "client",
            ...opts
          });
          this.name = "PasswordResetRequiredException";
          this.$fault = "client";
          Object.setPrototypeOf(this, PasswordResetRequiredException.prototype);
        }
      }
      class UserNotConfirmedException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UserNotConfirmedException",
            $fault: "client",
            ...opts
          });
          this.name = "UserNotConfirmedException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UserNotConfirmedException.prototype);
        }
      }
      const ChallengeName = {
        Mfa: "Mfa",
        Password: "Password"
      };
      const ChallengeResponse = {
        Failure: "Failure",
        Success: "Success"
      };
      const FeedbackValueType = {
        INVALID: "Invalid",
        VALID: "Valid"
      };
      const EventResponseType = {
        Fail: "Fail",
        InProgress: "InProgress",
        Pass: "Pass"
      };
      const RiskDecisionType = {
        AccountTakeover: "AccountTakeover",
        Block: "Block",
        NoRisk: "NoRisk"
      };
      const RiskLevelType = {
        High: "High",
        Low: "Low",
        Medium: "Medium"
      };
      const EventType = {
        ForgotPassword: "ForgotPassword",
        PasswordChange: "PasswordChange",
        ResendCode: "ResendCode",
        SignIn: "SignIn",
        SignUp: "SignUp"
      };
      class UserPoolAddOnNotEnabledException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UserPoolAddOnNotEnabledException",
            $fault: "client",
            ...opts
          });
          this.name = "UserPoolAddOnNotEnabledException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UserPoolAddOnNotEnabledException.prototype);
        }
      }
      class InvalidEmailRoleAccessPolicyException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "InvalidEmailRoleAccessPolicyException",
            $fault: "client",
            ...opts
          });
          this.name = "InvalidEmailRoleAccessPolicyException";
          this.$fault = "client";
          Object.setPrototypeOf(this, InvalidEmailRoleAccessPolicyException.prototype);
        }
      }
      class CodeMismatchException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "CodeMismatchException",
            $fault: "client",
            ...opts
          });
          this.name = "CodeMismatchException";
          this.$fault = "client";
          Object.setPrototypeOf(this, CodeMismatchException.prototype);
        }
      }
      class ExpiredCodeException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "ExpiredCodeException",
            $fault: "client",
            ...opts
          });
          this.name = "ExpiredCodeException";
          this.$fault = "client";
          Object.setPrototypeOf(this, ExpiredCodeException.prototype);
        }
      }
      class SoftwareTokenMFANotFoundException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "SoftwareTokenMFANotFoundException",
            $fault: "client",
            ...opts
          });
          this.name = "SoftwareTokenMFANotFoundException";
          this.$fault = "client";
          Object.setPrototypeOf(this, SoftwareTokenMFANotFoundException.prototype);
        }
      }
      const DeviceRememberedStatusType = {
        NOT_REMEMBERED: "not_remembered",
        REMEMBERED: "remembered"
      };
      const AdvancedSecurityModeType = {
        AUDIT: "AUDIT",
        ENFORCED: "ENFORCED",
        OFF: "OFF"
      };
      const AliasAttributeType = {
        EMAIL: "email",
        PHONE_NUMBER: "phone_number",
        PREFERRED_USERNAME: "preferred_username"
      };
      class ConcurrentModificationException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "ConcurrentModificationException",
            $fault: "client",
            ...opts
          });
          this.name = "ConcurrentModificationException";
          this.$fault = "client";
          Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
        }
      }
      class ForbiddenException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "ForbiddenException",
            $fault: "client",
            ...opts
          });
          this.name = "ForbiddenException";
          this.$fault = "client";
          Object.setPrototypeOf(this, ForbiddenException.prototype);
        }
      }
      const VerifiedAttributeType = {
        EMAIL: "email",
        PHONE_NUMBER: "phone_number"
      };
      class GroupExistsException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "GroupExistsException",
            $fault: "client",
            ...opts
          });
          this.name = "GroupExistsException";
          this.$fault = "client";
          Object.setPrototypeOf(this, GroupExistsException.prototype);
        }
      }
      const IdentityProviderTypeType = {
        Facebook: "Facebook",
        Google: "Google",
        LoginWithAmazon: "LoginWithAmazon",
        OIDC: "OIDC",
        SAML: "SAML",
        SignInWithApple: "SignInWithApple"
      };
      class DuplicateProviderException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "DuplicateProviderException",
            $fault: "client",
            ...opts
          });
          this.name = "DuplicateProviderException";
          this.$fault = "client";
          Object.setPrototypeOf(this, DuplicateProviderException.prototype);
        }
      }
      const UserImportJobStatusType = {
        Created: "Created",
        Expired: "Expired",
        Failed: "Failed",
        InProgress: "InProgress",
        Pending: "Pending",
        Stopped: "Stopped",
        Stopping: "Stopping",
        Succeeded: "Succeeded"
      };
      const DeletionProtectionType = {
        ACTIVE: "ACTIVE",
        INACTIVE: "INACTIVE"
      };
      const EmailSendingAccountType = {
        COGNITO_DEFAULT: "COGNITO_DEFAULT",
        DEVELOPER: "DEVELOPER"
      };
      const CustomEmailSenderLambdaVersionType = {
        V1_0: "V1_0"
      };
      const CustomSMSSenderLambdaVersionType = {
        V1_0: "V1_0"
      };
      const UserPoolMfaType = {
        OFF: "OFF",
        ON: "ON",
        OPTIONAL: "OPTIONAL"
      };
      const UsernameAttributeType = {
        EMAIL: "email",
        PHONE_NUMBER: "phone_number"
      };
      const DefaultEmailOptionType = {
        CONFIRM_WITH_CODE: "CONFIRM_WITH_CODE",
        CONFIRM_WITH_LINK: "CONFIRM_WITH_LINK"
      };
      const StatusType = {
        Disabled: "Disabled",
        Enabled: "Enabled"
      };
      class UserPoolTaggingException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UserPoolTaggingException",
            $fault: "client",
            ...opts
          });
          this.name = "UserPoolTaggingException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UserPoolTaggingException.prototype);
        }
      }
      const OAuthFlowType = {
        client_credentials: "client_credentials",
        code: "code",
        implicit: "implicit"
      };
      const ExplicitAuthFlowsType = {
        ADMIN_NO_SRP_AUTH: "ADMIN_NO_SRP_AUTH",
        ALLOW_ADMIN_USER_PASSWORD_AUTH: "ALLOW_ADMIN_USER_PASSWORD_AUTH",
        ALLOW_CUSTOM_AUTH: "ALLOW_CUSTOM_AUTH",
        ALLOW_REFRESH_TOKEN_AUTH: "ALLOW_REFRESH_TOKEN_AUTH",
        ALLOW_USER_PASSWORD_AUTH: "ALLOW_USER_PASSWORD_AUTH",
        ALLOW_USER_SRP_AUTH: "ALLOW_USER_SRP_AUTH",
        CUSTOM_AUTH_FLOW_ONLY: "CUSTOM_AUTH_FLOW_ONLY",
        USER_PASSWORD_AUTH: "USER_PASSWORD_AUTH"
      };
      const PreventUserExistenceErrorTypes = {
        ENABLED: "ENABLED",
        LEGACY: "LEGACY"
      };
      const TimeUnitsType = {
        DAYS: "days",
        HOURS: "hours",
        MINUTES: "minutes",
        SECONDS: "seconds"
      };
      class InvalidOAuthFlowException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "InvalidOAuthFlowException",
            $fault: "client",
            ...opts
          });
          this.name = "InvalidOAuthFlowException";
          this.$fault = "client";
          Object.setPrototypeOf(this, InvalidOAuthFlowException.prototype);
        }
      }
      class ScopeDoesNotExistException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "ScopeDoesNotExistException",
            $fault: "client",
            ...opts
          });
          this.name = "ScopeDoesNotExistException";
          this.$fault = "client";
          Object.setPrototypeOf(this, ScopeDoesNotExistException.prototype);
        }
      }
      class UnsupportedIdentityProviderException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UnsupportedIdentityProviderException",
            $fault: "client",
            ...opts
          });
          this.name = "UnsupportedIdentityProviderException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UnsupportedIdentityProviderException.prototype);
        }
      }
      const CompromisedCredentialsEventActionType = {
        BLOCK: "BLOCK",
        NO_ACTION: "NO_ACTION"
      };
      const EventFilterType = {
        PASSWORD_CHANGE: "PASSWORD_CHANGE",
        SIGN_IN: "SIGN_IN",
        SIGN_UP: "SIGN_UP"
      };
      const DomainStatusType = {
        ACTIVE: "ACTIVE",
        CREATING: "CREATING",
        DELETING: "DELETING",
        FAILED: "FAILED",
        UPDATING: "UPDATING"
      };
      const EventSourceName = {
        USER_NOTIFICATION: "userNotification"
      };
      const LogLevel = {
        ERROR: "ERROR"
      };
      class UnauthorizedException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UnauthorizedException",
            $fault: "client",
            ...opts
          });
          this.name = "UnauthorizedException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UnauthorizedException.prototype);
        }
      }
      class UnsupportedOperationException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UnsupportedOperationException",
            $fault: "client",
            ...opts
          });
          this.name = "UnsupportedOperationException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
        }
      }
      class UnsupportedTokenTypeException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "UnsupportedTokenTypeException",
            $fault: "client",
            ...opts
          });
          this.name = "UnsupportedTokenTypeException";
          this.$fault = "client";
          Object.setPrototypeOf(this, UnsupportedTokenTypeException.prototype);
        }
      }
      const AdminAddUserToGroupRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminConfirmSignUpRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AttributeTypeFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Value && {
          Value: SENSITIVE_STRING
        })
      });
      const AdminCreateUserRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.UserAttributes && {
          UserAttributes: obj.UserAttributes.map(item => AttributeTypeFilterSensitiveLog(item))
        }),
        ...(obj.ValidationData && {
          ValidationData: obj.ValidationData.map(item => AttributeTypeFilterSensitiveLog(item))
        }),
        ...(obj.TemporaryPassword && {
          TemporaryPassword: SENSITIVE_STRING
        })
      });
      const UserTypeFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.Attributes && {
          Attributes: obj.Attributes.map(item => AttributeTypeFilterSensitiveLog(item))
        })
      });
      const AdminCreateUserResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.User && {
          User: UserTypeFilterSensitiveLog(obj.User)
        })
      });
      const AdminDeleteUserRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminDeleteUserAttributesRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminDisableUserRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminEnableUserRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminForgetDeviceRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminGetDeviceRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const DeviceTypeFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.DeviceAttributes && {
          DeviceAttributes: obj.DeviceAttributes.map(item => AttributeTypeFilterSensitiveLog(item))
        })
      });
      const AdminGetDeviceResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Device && {
          Device: DeviceTypeFilterSensitiveLog(obj.Device)
        })
      });
      const AdminGetUserRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminGetUserResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.UserAttributes && {
          UserAttributes: obj.UserAttributes.map(item => AttributeTypeFilterSensitiveLog(item))
        })
      });
      const AdminInitiateAuthRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.AuthParameters && {
          AuthParameters: SENSITIVE_STRING
        })
      });
      const AuthenticationResultTypeFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        }),
        ...(obj.RefreshToken && {
          RefreshToken: SENSITIVE_STRING
        }),
        ...(obj.IdToken && {
          IdToken: SENSITIVE_STRING
        })
      });
      const AdminInitiateAuthResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        }),
        ...(obj.AuthenticationResult && {
          AuthenticationResult: AuthenticationResultTypeFilterSensitiveLog(obj.AuthenticationResult)
        })
      });
      const AdminListDevicesRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminListDevicesResponseFilterSensitiveLog = obj => ({
        ...obj
      });
      const AdminListGroupsForUserRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminListUserAuthEventsRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminRemoveUserFromGroupRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminResetUserPasswordRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminRespondToAuthChallengeRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.ChallengeResponses && {
          ChallengeResponses: SENSITIVE_STRING
        }),
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        })
      });
      const AdminRespondToAuthChallengeResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        }),
        ...(obj.AuthenticationResult && {
          AuthenticationResult: AuthenticationResultTypeFilterSensitiveLog(obj.AuthenticationResult)
        })
      });
      const AdminSetUserMFAPreferenceRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminSetUserPasswordRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.Password && {
          Password: SENSITIVE_STRING
        })
      });
      const AdminSetUserSettingsRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminUpdateAuthEventFeedbackRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminUpdateDeviceStatusRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AdminUpdateUserAttributesRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.UserAttributes && {
          UserAttributes: obj.UserAttributes.map(item => AttributeTypeFilterSensitiveLog(item))
        })
      });
      const AdminUserGlobalSignOutRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const AssociateSoftwareTokenRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        }),
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        })
      });
      const AssociateSoftwareTokenResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.SecretCode && {
          SecretCode: SENSITIVE_STRING
        }),
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        })
      });
      const ChangePasswordRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.PreviousPassword && {
          PreviousPassword: SENSITIVE_STRING
        }),
        ...(obj.ProposedPassword && {
          ProposedPassword: SENSITIVE_STRING
        }),
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const ConfirmDeviceRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const UserContextDataTypeFilterSensitiveLog = obj => ({
        ...obj
      });
      const ConfirmForgotPasswordRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.SecretHash && {
          SecretHash: SENSITIVE_STRING
        }),
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.Password && {
          Password: SENSITIVE_STRING
        }),
        ...(obj.UserContextData && {
          UserContextData: SENSITIVE_STRING
        })
      });
      const ConfirmSignUpRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.SecretHash && {
          SecretHash: SENSITIVE_STRING
        }),
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.UserContextData && {
          UserContextData: SENSITIVE_STRING
        })
      });
      const UserPoolClientTypeFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.ClientSecret && {
          ClientSecret: SENSITIVE_STRING
        })
      });
      const CreateUserPoolClientResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.UserPoolClient && {
          UserPoolClient: UserPoolClientTypeFilterSensitiveLog(obj.UserPoolClient)
        })
      });
      const DeleteUserRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const DeleteUserAttributesRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const DeleteUserPoolClientRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      const DescribeRiskConfigurationRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      const RiskConfigurationTypeFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      const DescribeRiskConfigurationResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.RiskConfiguration && {
          RiskConfiguration: RiskConfigurationTypeFilterSensitiveLog(obj.RiskConfiguration)
        })
      });
      const DescribeUserPoolClientRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      const DescribeUserPoolClientResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.UserPoolClient && {
          UserPoolClient: UserPoolClientTypeFilterSensitiveLog(obj.UserPoolClient)
        })
      });
      const ForgetDeviceRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const ForgotPasswordRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.SecretHash && {
          SecretHash: SENSITIVE_STRING
        }),
        ...(obj.UserContextData && {
          UserContextData: SENSITIVE_STRING
        }),
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const GetDeviceRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const GetDeviceResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Device && {
          Device: DeviceTypeFilterSensitiveLog(obj.Device)
        })
      });
      const GetUICustomizationRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      const UICustomizationTypeFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      const GetUICustomizationResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.UICustomization && {
          UICustomization: UICustomizationTypeFilterSensitiveLog(obj.UICustomization)
        })
      });
      const GetUserRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const GetUserResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.UserAttributes && {
          UserAttributes: obj.UserAttributes.map(item => AttributeTypeFilterSensitiveLog(item))
        })
      });
      const GetUserAttributeVerificationCodeRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const GlobalSignOutRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const InitiateAuthRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AuthParameters && {
          AuthParameters: SENSITIVE_STRING
        }),
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.UserContextData && {
          UserContextData: SENSITIVE_STRING
        })
      });
      const InitiateAuthResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        }),
        ...(obj.AuthenticationResult && {
          AuthenticationResult: AuthenticationResultTypeFilterSensitiveLog(obj.AuthenticationResult)
        })
      });
      const ListDevicesRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const ListDevicesResponseFilterSensitiveLog = obj => ({
        ...obj
      });
      const UserPoolClientDescriptionFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      const ListUserPoolClientsResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.UserPoolClients && {
          UserPoolClients: obj.UserPoolClients.map(item => UserPoolClientDescriptionFilterSensitiveLog(item))
        })
      });
      const ListUsersResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Users && {
          Users: obj.Users.map(item => UserTypeFilterSensitiveLog(item))
        })
      });
      const ListUsersInGroupResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Users && {
          Users: obj.Users.map(item => UserTypeFilterSensitiveLog(item))
        })
      });
      const ResendConfirmationCodeRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.SecretHash && {
          SecretHash: SENSITIVE_STRING
        }),
        ...(obj.UserContextData && {
          UserContextData: SENSITIVE_STRING
        }),
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        })
      });
      const RespondToAuthChallengeRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        }),
        ...(obj.ChallengeResponses && {
          ChallengeResponses: SENSITIVE_STRING
        }),
        ...(obj.UserContextData && {
          UserContextData: SENSITIVE_STRING
        })
      });
      const RespondToAuthChallengeResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        }),
        ...(obj.AuthenticationResult && {
          AuthenticationResult: AuthenticationResultTypeFilterSensitiveLog(obj.AuthenticationResult)
        })
      });
      const RevokeTokenRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Token && {
          Token: SENSITIVE_STRING
        }),
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.ClientSecret && {
          ClientSecret: SENSITIVE_STRING
        })
      });
      const SetRiskConfigurationRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      ;
      class EnableSoftwareTokenMFAException extends CognitoIdentityProviderServiceException {
        constructor(opts) {
          super({
            name: "EnableSoftwareTokenMFAException",
            $fault: "client",
            ...opts
          });
          this.name = "EnableSoftwareTokenMFAException";
          this.$fault = "client";
          Object.setPrototypeOf(this, EnableSoftwareTokenMFAException.prototype);
        }
      }
      const VerifySoftwareTokenResponseType = {
        ERROR: "ERROR",
        SUCCESS: "SUCCESS"
      };
      const SetRiskConfigurationResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.RiskConfiguration && {
          RiskConfiguration: RiskConfigurationTypeFilterSensitiveLog(obj.RiskConfiguration)
        })
      });
      const SetUICustomizationRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      const SetUICustomizationResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.UICustomization && {
          UICustomization: UICustomizationTypeFilterSensitiveLog(obj.UICustomization)
        })
      });
      const SetUserMFAPreferenceRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const SetUserSettingsRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const SignUpRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        }),
        ...(obj.SecretHash && {
          SecretHash: SENSITIVE_STRING
        }),
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.Password && {
          Password: SENSITIVE_STRING
        }),
        ...(obj.UserAttributes && {
          UserAttributes: obj.UserAttributes.map(item => AttributeTypeFilterSensitiveLog(item))
        }),
        ...(obj.ValidationData && {
          ValidationData: obj.ValidationData.map(item => AttributeTypeFilterSensitiveLog(item))
        }),
        ...(obj.UserContextData && {
          UserContextData: SENSITIVE_STRING
        })
      });
      const UpdateAuthEventFeedbackRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Username && {
          Username: SENSITIVE_STRING
        }),
        ...(obj.FeedbackToken && {
          FeedbackToken: SENSITIVE_STRING
        })
      });
      const UpdateDeviceStatusRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const UpdateUserAttributesRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.UserAttributes && {
          UserAttributes: obj.UserAttributes.map(item => AttributeTypeFilterSensitiveLog(item))
        }),
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      const UpdateUserPoolClientRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.ClientId && {
          ClientId: SENSITIVE_STRING
        })
      });
      const UpdateUserPoolClientResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.UserPoolClient && {
          UserPoolClient: UserPoolClientTypeFilterSensitiveLog(obj.UserPoolClient)
        })
      });
      const VerifySoftwareTokenRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        }),
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        }),
        ...(obj.UserCode && {
          UserCode: SENSITIVE_STRING
        })
      });
      const VerifySoftwareTokenResponseFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.Session && {
          Session: SENSITIVE_STRING
        })
      });
      const VerifyUserAttributeRequestFilterSensitiveLog = obj => ({
        ...obj,
        ...(obj.AccessToken && {
          AccessToken: SENSITIVE_STRING
        })
      });
      ;
      const se_AddCustomAttributesCommand = async (input, context) => {
        const headers = sharedHeaders("AddCustomAttributes");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminAddUserToGroupCommand = async (input, context) => {
        const headers = sharedHeaders("AdminAddUserToGroup");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminConfirmSignUpCommand = async (input, context) => {
        const headers = sharedHeaders("AdminConfirmSignUp");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminCreateUserCommand = async (input, context) => {
        const headers = sharedHeaders("AdminCreateUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminDeleteUserCommand = async (input, context) => {
        const headers = sharedHeaders("AdminDeleteUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminDeleteUserAttributesCommand = async (input, context) => {
        const headers = sharedHeaders("AdminDeleteUserAttributes");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminDisableProviderForUserCommand = async (input, context) => {
        const headers = sharedHeaders("AdminDisableProviderForUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminDisableUserCommand = async (input, context) => {
        const headers = sharedHeaders("AdminDisableUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminEnableUserCommand = async (input, context) => {
        const headers = sharedHeaders("AdminEnableUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminForgetDeviceCommand = async (input, context) => {
        const headers = sharedHeaders("AdminForgetDevice");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminGetDeviceCommand = async (input, context) => {
        const headers = sharedHeaders("AdminGetDevice");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminGetUserCommand = async (input, context) => {
        const headers = sharedHeaders("AdminGetUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminInitiateAuthCommand = async (input, context) => {
        const headers = sharedHeaders("AdminInitiateAuth");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminLinkProviderForUserCommand = async (input, context) => {
        const headers = sharedHeaders("AdminLinkProviderForUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminListDevicesCommand = async (input, context) => {
        const headers = sharedHeaders("AdminListDevices");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminListGroupsForUserCommand = async (input, context) => {
        const headers = sharedHeaders("AdminListGroupsForUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminListUserAuthEventsCommand = async (input, context) => {
        const headers = sharedHeaders("AdminListUserAuthEvents");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminRemoveUserFromGroupCommand = async (input, context) => {
        const headers = sharedHeaders("AdminRemoveUserFromGroup");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminResetUserPasswordCommand = async (input, context) => {
        const headers = sharedHeaders("AdminResetUserPassword");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminRespondToAuthChallengeCommand = async (input, context) => {
        const headers = sharedHeaders("AdminRespondToAuthChallenge");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminSetUserMFAPreferenceCommand = async (input, context) => {
        const headers = sharedHeaders("AdminSetUserMFAPreference");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminSetUserPasswordCommand = async (input, context) => {
        const headers = sharedHeaders("AdminSetUserPassword");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminSetUserSettingsCommand = async (input, context) => {
        const headers = sharedHeaders("AdminSetUserSettings");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminUpdateAuthEventFeedbackCommand = async (input, context) => {
        const headers = sharedHeaders("AdminUpdateAuthEventFeedback");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminUpdateDeviceStatusCommand = async (input, context) => {
        const headers = sharedHeaders("AdminUpdateDeviceStatus");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminUpdateUserAttributesCommand = async (input, context) => {
        const headers = sharedHeaders("AdminUpdateUserAttributes");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AdminUserGlobalSignOutCommand = async (input, context) => {
        const headers = sharedHeaders("AdminUserGlobalSignOut");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_AssociateSoftwareTokenCommand = async (input, context) => {
        const headers = sharedHeaders("AssociateSoftwareToken");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ChangePasswordCommand = async (input, context) => {
        const headers = sharedHeaders("ChangePassword");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ConfirmDeviceCommand = async (input, context) => {
        const headers = sharedHeaders("ConfirmDevice");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ConfirmForgotPasswordCommand = async (input, context) => {
        const headers = sharedHeaders("ConfirmForgotPassword");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ConfirmSignUpCommand = async (input, context) => {
        const headers = sharedHeaders("ConfirmSignUp");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_CreateGroupCommand = async (input, context) => {
        const headers = sharedHeaders("CreateGroup");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_CreateIdentityProviderCommand = async (input, context) => {
        const headers = sharedHeaders("CreateIdentityProvider");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_CreateResourceServerCommand = async (input, context) => {
        const headers = sharedHeaders("CreateResourceServer");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_CreateUserImportJobCommand = async (input, context) => {
        const headers = sharedHeaders("CreateUserImportJob");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_CreateUserPoolCommand = async (input, context) => {
        const headers = sharedHeaders("CreateUserPool");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_CreateUserPoolClientCommand = async (input, context) => {
        const headers = sharedHeaders("CreateUserPoolClient");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_CreateUserPoolDomainCommand = async (input, context) => {
        const headers = sharedHeaders("CreateUserPoolDomain");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DeleteGroupCommand = async (input, context) => {
        const headers = sharedHeaders("DeleteGroup");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DeleteIdentityProviderCommand = async (input, context) => {
        const headers = sharedHeaders("DeleteIdentityProvider");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DeleteResourceServerCommand = async (input, context) => {
        const headers = sharedHeaders("DeleteResourceServer");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DeleteUserCommand = async (input, context) => {
        const headers = sharedHeaders("DeleteUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DeleteUserAttributesCommand = async (input, context) => {
        const headers = sharedHeaders("DeleteUserAttributes");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DeleteUserPoolCommand = async (input, context) => {
        const headers = sharedHeaders("DeleteUserPool");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DeleteUserPoolClientCommand = async (input, context) => {
        const headers = sharedHeaders("DeleteUserPoolClient");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DeleteUserPoolDomainCommand = async (input, context) => {
        const headers = sharedHeaders("DeleteUserPoolDomain");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DescribeIdentityProviderCommand = async (input, context) => {
        const headers = sharedHeaders("DescribeIdentityProvider");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DescribeResourceServerCommand = async (input, context) => {
        const headers = sharedHeaders("DescribeResourceServer");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DescribeRiskConfigurationCommand = async (input, context) => {
        const headers = sharedHeaders("DescribeRiskConfiguration");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DescribeUserImportJobCommand = async (input, context) => {
        const headers = sharedHeaders("DescribeUserImportJob");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DescribeUserPoolCommand = async (input, context) => {
        const headers = sharedHeaders("DescribeUserPool");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DescribeUserPoolClientCommand = async (input, context) => {
        const headers = sharedHeaders("DescribeUserPoolClient");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_DescribeUserPoolDomainCommand = async (input, context) => {
        const headers = sharedHeaders("DescribeUserPoolDomain");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ForgetDeviceCommand = async (input, context) => {
        const headers = sharedHeaders("ForgetDevice");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ForgotPasswordCommand = async (input, context) => {
        const headers = sharedHeaders("ForgotPassword");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetCSVHeaderCommand = async (input, context) => {
        const headers = sharedHeaders("GetCSVHeader");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetDeviceCommand = async (input, context) => {
        const headers = sharedHeaders("GetDevice");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetGroupCommand = async (input, context) => {
        const headers = sharedHeaders("GetGroup");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetIdentityProviderByIdentifierCommand = async (input, context) => {
        const headers = sharedHeaders("GetIdentityProviderByIdentifier");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetLogDeliveryConfigurationCommand = async (input, context) => {
        const headers = sharedHeaders("GetLogDeliveryConfiguration");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetSigningCertificateCommand = async (input, context) => {
        const headers = sharedHeaders("GetSigningCertificate");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetUICustomizationCommand = async (input, context) => {
        const headers = sharedHeaders("GetUICustomization");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetUserCommand = async (input, context) => {
        const headers = sharedHeaders("GetUser");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetUserAttributeVerificationCodeCommand = async (input, context) => {
        const headers = sharedHeaders("GetUserAttributeVerificationCode");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GetUserPoolMfaConfigCommand = async (input, context) => {
        const headers = sharedHeaders("GetUserPoolMfaConfig");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_GlobalSignOutCommand = async (input, context) => {
        const headers = sharedHeaders("GlobalSignOut");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_InitiateAuthCommand = async (input, context) => {
        const headers = sharedHeaders("InitiateAuth");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListDevicesCommand = async (input, context) => {
        const headers = sharedHeaders("ListDevices");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListGroupsCommand = async (input, context) => {
        const headers = sharedHeaders("ListGroups");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListIdentityProvidersCommand = async (input, context) => {
        const headers = sharedHeaders("ListIdentityProviders");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListResourceServersCommand = async (input, context) => {
        const headers = sharedHeaders("ListResourceServers");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListTagsForResourceCommand = async (input, context) => {
        const headers = sharedHeaders("ListTagsForResource");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListUserImportJobsCommand = async (input, context) => {
        const headers = sharedHeaders("ListUserImportJobs");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListUserPoolClientsCommand = async (input, context) => {
        const headers = sharedHeaders("ListUserPoolClients");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListUserPoolsCommand = async (input, context) => {
        const headers = sharedHeaders("ListUserPools");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListUsersCommand = async (input, context) => {
        const headers = sharedHeaders("ListUsers");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ListUsersInGroupCommand = async (input, context) => {
        const headers = sharedHeaders("ListUsersInGroup");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_ResendConfirmationCodeCommand = async (input, context) => {
        const headers = sharedHeaders("ResendConfirmationCode");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_RespondToAuthChallengeCommand = async (input, context) => {
        const headers = sharedHeaders("RespondToAuthChallenge");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_RevokeTokenCommand = async (input, context) => {
        const headers = sharedHeaders("RevokeToken");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_SetLogDeliveryConfigurationCommand = async (input, context) => {
        const headers = sharedHeaders("SetLogDeliveryConfiguration");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_SetRiskConfigurationCommand = async (input, context) => {
        const headers = sharedHeaders("SetRiskConfiguration");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_SetUICustomizationCommand = async (input, context) => {
        const headers = sharedHeaders("SetUICustomization");
        let body;
        body = JSON.stringify(se_SetUICustomizationRequest(input, context));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_SetUserMFAPreferenceCommand = async (input, context) => {
        const headers = sharedHeaders("SetUserMFAPreference");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_SetUserPoolMfaConfigCommand = async (input, context) => {
        const headers = sharedHeaders("SetUserPoolMfaConfig");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_SetUserSettingsCommand = async (input, context) => {
        const headers = sharedHeaders("SetUserSettings");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_SignUpCommand = async (input, context) => {
        const headers = sharedHeaders("SignUp");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_StartUserImportJobCommand = async (input, context) => {
        const headers = sharedHeaders("StartUserImportJob");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_StopUserImportJobCommand = async (input, context) => {
        const headers = sharedHeaders("StopUserImportJob");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_TagResourceCommand = async (input, context) => {
        const headers = sharedHeaders("TagResource");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UntagResourceCommand = async (input, context) => {
        const headers = sharedHeaders("UntagResource");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UpdateAuthEventFeedbackCommand = async (input, context) => {
        const headers = sharedHeaders("UpdateAuthEventFeedback");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UpdateDeviceStatusCommand = async (input, context) => {
        const headers = sharedHeaders("UpdateDeviceStatus");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UpdateGroupCommand = async (input, context) => {
        const headers = sharedHeaders("UpdateGroup");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UpdateIdentityProviderCommand = async (input, context) => {
        const headers = sharedHeaders("UpdateIdentityProvider");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UpdateResourceServerCommand = async (input, context) => {
        const headers = sharedHeaders("UpdateResourceServer");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UpdateUserAttributesCommand = async (input, context) => {
        const headers = sharedHeaders("UpdateUserAttributes");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UpdateUserPoolCommand = async (input, context) => {
        const headers = sharedHeaders("UpdateUserPool");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UpdateUserPoolClientCommand = async (input, context) => {
        const headers = sharedHeaders("UpdateUserPoolClient");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_UpdateUserPoolDomainCommand = async (input, context) => {
        const headers = sharedHeaders("UpdateUserPoolDomain");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_VerifySoftwareTokenCommand = async (input, context) => {
        const headers = sharedHeaders("VerifySoftwareToken");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const se_VerifyUserAttributeCommand = async (input, context) => {
        const headers = sharedHeaders("VerifyUserAttribute");
        let body;
        body = JSON.stringify(_json(input));
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
      };
      const de_AddCustomAttributesCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AddCustomAttributesCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AddCustomAttributesCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserImportInProgressException":
          case "com.amazonaws.cognitoidentityprovider#UserImportInProgressException":
            throw await de_UserImportInProgressExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminAddUserToGroupCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminAddUserToGroupCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_AdminAddUserToGroupCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminConfirmSignUpCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminConfirmSignUpCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminConfirmSignUpCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyFailedAttemptsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyFailedAttemptsException":
            throw await de_TooManyFailedAttemptsExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminCreateUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminCreateUserCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_AdminCreateUserResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminCreateUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "CodeDeliveryFailureException":
          case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidPasswordException":
          case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PreconditionNotMetException":
          case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
            throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UnsupportedUserStateException":
          case "com.amazonaws.cognitoidentityprovider#UnsupportedUserStateException":
            throw await de_UnsupportedUserStateExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          case "UsernameExistsException":
          case "com.amazonaws.cognitoidentityprovider#UsernameExistsException":
            throw await de_UsernameExistsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminDeleteUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminDeleteUserCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_AdminDeleteUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminDeleteUserAttributesCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminDeleteUserAttributesCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminDeleteUserAttributesCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminDisableProviderForUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminDisableProviderForUserCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminDisableProviderForUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "AliasExistsException":
          case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminDisableUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminDisableUserCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminDisableUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminEnableUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminEnableUserCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminEnableUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminForgetDeviceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminForgetDeviceCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_AdminForgetDeviceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminGetDeviceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminGetDeviceCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_AdminGetDeviceResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminGetDeviceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminGetUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminGetUserCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_AdminGetUserResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminGetUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminInitiateAuthCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminInitiateAuthCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminInitiateAuthCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "MFAMethodNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#MFAMethodNotFoundException":
            throw await de_MFAMethodNotFoundExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminLinkProviderForUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminLinkProviderForUserCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminLinkProviderForUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "AliasExistsException":
          case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminListDevicesCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminListDevicesCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_AdminListDevicesResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminListDevicesCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminListGroupsForUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminListGroupsForUserCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_AdminListGroupsForUserResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminListGroupsForUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminListUserAuthEventsCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminListUserAuthEventsCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_AdminListUserAuthEventsResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminListUserAuthEventsCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          case "UserPoolAddOnNotEnabledException":
          case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminRemoveUserFromGroupCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminRemoveUserFromGroupCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_AdminRemoveUserFromGroupCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminResetUserPasswordCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminResetUserPasswordCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminResetUserPasswordCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminRespondToAuthChallengeCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminRespondToAuthChallengeCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminRespondToAuthChallengeCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "AliasExistsException":
          case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
          case "CodeMismatchException":
          case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
          case "ExpiredCodeException":
          case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidPasswordException":
          case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "MFAMethodNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#MFAMethodNotFoundException":
            throw await de_MFAMethodNotFoundExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "SoftwareTokenMFANotFoundException":
          case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
            throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminSetUserMFAPreferenceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminSetUserMFAPreferenceCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminSetUserMFAPreferenceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminSetUserPasswordCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminSetUserPasswordCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminSetUserPasswordCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidPasswordException":
          case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminSetUserSettingsCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminSetUserSettingsCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminSetUserSettingsCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminUpdateAuthEventFeedbackCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminUpdateAuthEventFeedbackCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminUpdateAuthEventFeedbackCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          case "UserPoolAddOnNotEnabledException":
          case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminUpdateDeviceStatusCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminUpdateDeviceStatusCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminUpdateDeviceStatusCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminUpdateUserAttributesCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminUpdateUserAttributesCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminUpdateUserAttributesCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "AliasExistsException":
          case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AdminUserGlobalSignOutCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AdminUserGlobalSignOutCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AdminUserGlobalSignOutCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AssociateSoftwareTokenCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_AssociateSoftwareTokenCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_AssociateSoftwareTokenCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ConcurrentModificationException":
          case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "SoftwareTokenMFANotFoundException":
          case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
            throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ChangePasswordCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ChangePasswordCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ChangePasswordCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidPasswordException":
          case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ConfirmDeviceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ConfirmDeviceCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ConfirmDeviceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidPasswordException":
          case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          case "UsernameExistsException":
          case "com.amazonaws.cognitoidentityprovider#UsernameExistsException":
            throw await de_UsernameExistsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ConfirmForgotPasswordCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ConfirmForgotPasswordCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ConfirmForgotPasswordCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "CodeMismatchException":
          case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
          case "ExpiredCodeException":
          case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidPasswordException":
          case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyFailedAttemptsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyFailedAttemptsException":
            throw await de_TooManyFailedAttemptsExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ConfirmSignUpCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ConfirmSignUpCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ConfirmSignUpCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "AliasExistsException":
          case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
          case "CodeMismatchException":
          case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
          case "ExpiredCodeException":
          case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyFailedAttemptsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyFailedAttemptsException":
            throw await de_TooManyFailedAttemptsExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_CreateGroupCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_CreateGroupCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_CreateGroupResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_CreateGroupCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "GroupExistsException":
          case "com.amazonaws.cognitoidentityprovider#GroupExistsException":
            throw await de_GroupExistsExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_CreateIdentityProviderCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_CreateIdentityProviderCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_CreateIdentityProviderResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_CreateIdentityProviderCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "DuplicateProviderException":
          case "com.amazonaws.cognitoidentityprovider#DuplicateProviderException":
            throw await de_DuplicateProviderExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_CreateResourceServerCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_CreateResourceServerCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_CreateResourceServerCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_CreateUserImportJobCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_CreateUserImportJobCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_CreateUserImportJobResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_CreateUserImportJobCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PreconditionNotMetException":
          case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
            throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_CreateUserPoolCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_CreateUserPoolCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_CreateUserPoolResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_CreateUserPoolCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserPoolTaggingException":
          case "com.amazonaws.cognitoidentityprovider#UserPoolTaggingException":
            throw await de_UserPoolTaggingExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_CreateUserPoolClientCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_CreateUserPoolClientCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_CreateUserPoolClientResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_CreateUserPoolClientCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidOAuthFlowException":
          case "com.amazonaws.cognitoidentityprovider#InvalidOAuthFlowException":
            throw await de_InvalidOAuthFlowExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "ScopeDoesNotExistException":
          case "com.amazonaws.cognitoidentityprovider#ScopeDoesNotExistException":
            throw await de_ScopeDoesNotExistExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_CreateUserPoolDomainCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_CreateUserPoolDomainCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_CreateUserPoolDomainCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DeleteGroupCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DeleteGroupCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_DeleteGroupCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DeleteIdentityProviderCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DeleteIdentityProviderCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_DeleteIdentityProviderCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ConcurrentModificationException":
          case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnsupportedIdentityProviderException":
          case "com.amazonaws.cognitoidentityprovider#UnsupportedIdentityProviderException":
            throw await de_UnsupportedIdentityProviderExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DeleteResourceServerCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DeleteResourceServerCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_DeleteResourceServerCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DeleteUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DeleteUserCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_DeleteUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DeleteUserAttributesCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DeleteUserAttributesCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_DeleteUserAttributesCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DeleteUserPoolCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DeleteUserPoolCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_DeleteUserPoolCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserImportInProgressException":
          case "com.amazonaws.cognitoidentityprovider#UserImportInProgressException":
            throw await de_UserImportInProgressExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DeleteUserPoolClientCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DeleteUserPoolClientCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_DeleteUserPoolClientCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ConcurrentModificationException":
          case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DeleteUserPoolDomainCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DeleteUserPoolDomainCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_DeleteUserPoolDomainCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DescribeIdentityProviderCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DescribeIdentityProviderCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_DescribeIdentityProviderResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_DescribeIdentityProviderCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DescribeResourceServerCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DescribeResourceServerCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_DescribeResourceServerCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DescribeRiskConfigurationCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DescribeRiskConfigurationCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_DescribeRiskConfigurationResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_DescribeRiskConfigurationCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserPoolAddOnNotEnabledException":
          case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DescribeUserImportJobCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DescribeUserImportJobCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_DescribeUserImportJobResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_DescribeUserImportJobCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DescribeUserPoolCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DescribeUserPoolCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_DescribeUserPoolResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_DescribeUserPoolCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserPoolTaggingException":
          case "com.amazonaws.cognitoidentityprovider#UserPoolTaggingException":
            throw await de_UserPoolTaggingExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DescribeUserPoolClientCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DescribeUserPoolClientCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_DescribeUserPoolClientResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_DescribeUserPoolClientCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_DescribeUserPoolDomainCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_DescribeUserPoolDomainCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_DescribeUserPoolDomainCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ForgetDeviceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ForgetDeviceCommandError(output, context);
        }
        await collectBody(output.body, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output)
        };
        return response;
      };
      const de_ForgetDeviceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ForgotPasswordCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ForgotPasswordCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ForgotPasswordCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "CodeDeliveryFailureException":
          case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetCSVHeaderCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetCSVHeaderCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetCSVHeaderCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetDeviceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetDeviceCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_GetDeviceResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetDeviceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetGroupCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetGroupCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_GetGroupResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetGroupCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetIdentityProviderByIdentifierCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetIdentityProviderByIdentifierCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_GetIdentityProviderByIdentifierResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetIdentityProviderByIdentifierCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetLogDeliveryConfigurationCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetLogDeliveryConfigurationCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetLogDeliveryConfigurationCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetSigningCertificateCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetSigningCertificateCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetSigningCertificateCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetUICustomizationCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetUICustomizationCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_GetUICustomizationResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetUICustomizationCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetUserCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetUserCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetUserCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetUserAttributeVerificationCodeCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetUserAttributeVerificationCodeCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetUserAttributeVerificationCodeCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "CodeDeliveryFailureException":
          case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GetUserPoolMfaConfigCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GetUserPoolMfaConfigCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GetUserPoolMfaConfigCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_GlobalSignOutCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_GlobalSignOutCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_GlobalSignOutCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_InitiateAuthCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_InitiateAuthCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_InitiateAuthCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListDevicesCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListDevicesCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_ListDevicesResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListDevicesCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListGroupsCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListGroupsCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_ListGroupsResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListGroupsCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListIdentityProvidersCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListIdentityProvidersCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_ListIdentityProvidersResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListIdentityProvidersCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListResourceServersCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListResourceServersCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListResourceServersCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListTagsForResourceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListTagsForResourceCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListTagsForResourceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListUserImportJobsCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListUserImportJobsCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_ListUserImportJobsResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListUserImportJobsCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListUserPoolClientsCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListUserPoolClientsCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListUserPoolClientsCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListUserPoolsCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListUserPoolsCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_ListUserPoolsResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListUserPoolsCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListUsersCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListUsersCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_ListUsersResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListUsersCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ListUsersInGroupCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ListUsersInGroupCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_ListUsersInGroupResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ListUsersInGroupCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_ResendConfirmationCodeCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_ResendConfirmationCodeCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_ResendConfirmationCodeCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "CodeDeliveryFailureException":
          case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_RespondToAuthChallengeCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_RespondToAuthChallengeCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_RespondToAuthChallengeCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "AliasExistsException":
          case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
          case "CodeMismatchException":
          case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
          case "ExpiredCodeException":
          case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidPasswordException":
          case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "MFAMethodNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#MFAMethodNotFoundException":
            throw await de_MFAMethodNotFoundExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "SoftwareTokenMFANotFoundException":
          case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
            throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_RevokeTokenCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_RevokeTokenCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_RevokeTokenCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnauthorizedException":
          case "com.amazonaws.cognitoidentityprovider#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
          case "UnsupportedOperationException":
          case "com.amazonaws.cognitoidentityprovider#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
          case "UnsupportedTokenTypeException":
          case "com.amazonaws.cognitoidentityprovider#UnsupportedTokenTypeException":
            throw await de_UnsupportedTokenTypeExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_SetLogDeliveryConfigurationCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_SetLogDeliveryConfigurationCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_SetLogDeliveryConfigurationCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_SetRiskConfigurationCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_SetRiskConfigurationCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_SetRiskConfigurationResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_SetRiskConfigurationCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "CodeDeliveryFailureException":
          case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserPoolAddOnNotEnabledException":
          case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_SetUICustomizationCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_SetUICustomizationCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_SetUICustomizationResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_SetUICustomizationCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_SetUserMFAPreferenceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_SetUserMFAPreferenceCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_SetUserMFAPreferenceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_SetUserPoolMfaConfigCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_SetUserPoolMfaConfigCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_SetUserPoolMfaConfigCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_SetUserSettingsCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_SetUserSettingsCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_SetUserSettingsCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_SignUpCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_SignUpCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_SignUpCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "CodeDeliveryFailureException":
          case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidPasswordException":
          case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UsernameExistsException":
          case "com.amazonaws.cognitoidentityprovider#UsernameExistsException":
            throw await de_UsernameExistsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_StartUserImportJobCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_StartUserImportJobCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_StartUserImportJobResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_StartUserImportJobCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PreconditionNotMetException":
          case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
            throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_StopUserImportJobCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_StopUserImportJobCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_StopUserImportJobResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_StopUserImportJobCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PreconditionNotMetException":
          case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
            throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_TagResourceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_TagResourceCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_TagResourceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UntagResourceCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UntagResourceCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UntagResourceCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UpdateAuthEventFeedbackCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UpdateAuthEventFeedbackCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UpdateAuthEventFeedbackCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          case "UserPoolAddOnNotEnabledException":
          case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UpdateDeviceStatusCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UpdateDeviceStatusCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UpdateDeviceStatusCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UpdateGroupCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UpdateGroupCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_UpdateGroupResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UpdateGroupCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UpdateIdentityProviderCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UpdateIdentityProviderCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_UpdateIdentityProviderResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UpdateIdentityProviderCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ConcurrentModificationException":
          case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnsupportedIdentityProviderException":
          case "com.amazonaws.cognitoidentityprovider#UnsupportedIdentityProviderException":
            throw await de_UnsupportedIdentityProviderExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UpdateResourceServerCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UpdateResourceServerCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UpdateResourceServerCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UpdateUserAttributesCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UpdateUserAttributesCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UpdateUserAttributesCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "AliasExistsException":
          case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
          case "CodeDeliveryFailureException":
          case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
          case "CodeMismatchException":
          case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
          case "ExpiredCodeException":
          case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidLambdaResponseException":
          case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UnexpectedLambdaException":
          case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
          case "UserLambdaValidationException":
          case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UpdateUserPoolCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UpdateUserPoolCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UpdateUserPoolCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ConcurrentModificationException":
          case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidEmailRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleAccessPolicyException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
          case "InvalidSmsRoleTrustRelationshipException":
          case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserImportInProgressException":
          case "com.amazonaws.cognitoidentityprovider#UserImportInProgressException":
            throw await de_UserImportInProgressExceptionRes(parsedOutput, context);
          case "UserPoolTaggingException":
          case "com.amazonaws.cognitoidentityprovider#UserPoolTaggingException":
            throw await de_UserPoolTaggingExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UpdateUserPoolClientCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UpdateUserPoolClientCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = de_UpdateUserPoolClientResponse(data, context);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UpdateUserPoolClientCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "ConcurrentModificationException":
          case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidOAuthFlowException":
          case "com.amazonaws.cognitoidentityprovider#InvalidOAuthFlowException":
            throw await de_InvalidOAuthFlowExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "ScopeDoesNotExistException":
          case "com.amazonaws.cognitoidentityprovider#ScopeDoesNotExistException":
            throw await de_ScopeDoesNotExistExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_UpdateUserPoolDomainCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_UpdateUserPoolDomainCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_UpdateUserPoolDomainCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_VerifySoftwareTokenCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_VerifySoftwareTokenCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_VerifySoftwareTokenCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "CodeMismatchException":
          case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
          case "EnableSoftwareTokenMFAException":
          case "com.amazonaws.cognitoidentityprovider#EnableSoftwareTokenMFAException":
            throw await de_EnableSoftwareTokenMFAExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "InvalidUserPoolConfigurationException":
          case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "SoftwareTokenMFANotFoundException":
          case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
            throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_VerifyUserAttributeCommand = async (output, context) => {
        if (output.statusCode >= 300) {
          return de_VerifyUserAttributeCommandError(output, context);
        }
        const data = await parseBody(output.body, context);
        let contents = {};
        contents = _json(data);
        const response = {
          $metadata: Aws_json1_1_deserializeMetadata(output),
          ...contents
        };
        return response;
      };
      const de_VerifyUserAttributeCommandError = async (output, context) => {
        const parsedOutput = {
          ...output,
          body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
          case "AliasExistsException":
          case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
          case "CodeMismatchException":
          case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
          case "ExpiredCodeException":
          case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
          case "ForbiddenException":
          case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
          case "InternalErrorException":
          case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
          case "InvalidParameterException":
          case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
          case "LimitExceededException":
          case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
          case "NotAuthorizedException":
          case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
          case "PasswordResetRequiredException":
          case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
          case "ResourceNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
          case "TooManyRequestsException":
          case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
          case "UserNotConfirmedException":
          case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
          case "UserNotFoundException":
          case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
          default:
            const parsedBody = parsedOutput.body;
            return Aws_json1_1_throwDefaultError({
              output,
              parsedBody,
              errorCode
            });
        }
      };
      const de_AliasExistsExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new AliasExistsException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_CodeDeliveryFailureExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new CodeDeliveryFailureException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_CodeMismatchExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new CodeMismatchException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new ConcurrentModificationException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_DuplicateProviderExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new DuplicateProviderException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_EnableSoftwareTokenMFAExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new EnableSoftwareTokenMFAException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_ExpiredCodeExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new ExpiredCodeException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_ForbiddenExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new ForbiddenException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_GroupExistsExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new GroupExistsException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_InternalErrorExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new InternalErrorException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_InvalidEmailRoleAccessPolicyExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new InvalidEmailRoleAccessPolicyException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_InvalidLambdaResponseExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new InvalidLambdaResponseException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_InvalidOAuthFlowExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new InvalidOAuthFlowException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_InvalidParameterExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new InvalidParameterException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_InvalidPasswordExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new InvalidPasswordException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_InvalidSmsRoleAccessPolicyExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new InvalidSmsRoleAccessPolicyException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_InvalidSmsRoleTrustRelationshipExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new InvalidSmsRoleTrustRelationshipException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_InvalidUserPoolConfigurationExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new InvalidUserPoolConfigurationException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new LimitExceededException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_MFAMethodNotFoundExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new MFAMethodNotFoundException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_NotAuthorizedExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new NotAuthorizedException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_PasswordResetRequiredExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new PasswordResetRequiredException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_PreconditionNotMetExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new PreconditionNotMetException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new ResourceNotFoundException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_ScopeDoesNotExistExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new ScopeDoesNotExistException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_SoftwareTokenMFANotFoundExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new SoftwareTokenMFANotFoundException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_TooManyFailedAttemptsExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new TooManyFailedAttemptsException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new TooManyRequestsException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UnauthorizedException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UnexpectedLambdaExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UnexpectedLambdaException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UnsupportedIdentityProviderExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UnsupportedIdentityProviderException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UnsupportedOperationExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UnsupportedOperationException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UnsupportedTokenTypeExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UnsupportedTokenTypeException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UnsupportedUserStateExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UnsupportedUserStateException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UserImportInProgressExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UserImportInProgressException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UserLambdaValidationExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UserLambdaValidationException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UsernameExistsExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UsernameExistsException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UserNotConfirmedExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UserNotConfirmedException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UserNotFoundExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UserNotFoundException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UserPoolAddOnNotEnabledExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UserPoolAddOnNotEnabledException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const de_UserPoolTaggingExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json(body);
        const exception = new UserPoolTaggingException({
          $metadata: Aws_json1_1_deserializeMetadata(parsedOutput),
          ...deserialized
        });
        return decorateServiceException(exception, body);
      };
      const se_SetUICustomizationRequest = (input, context) => {
        return take(input, {
          CSS: [],
          ClientId: [],
          ImageFile: context.base64Encoder,
          UserPoolId: []
        });
      };
      const de_AdminCreateUserResponse = (output, context) => {
        return take(output, {
          User: _ => de_UserType(_, context)
        });
      };
      const de_AdminGetDeviceResponse = (output, context) => {
        return take(output, {
          Device: _ => de_DeviceType(_, context)
        });
      };
      const de_AdminGetUserResponse = (output, context) => {
        return take(output, {
          Enabled: expectBoolean,
          MFAOptions: _json,
          PreferredMfaSetting: expectString,
          UserAttributes: _json,
          UserCreateDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          UserLastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          UserMFASettingList: _json,
          UserStatus: expectString,
          Username: expectString
        });
      };
      const de_AdminListDevicesResponse = (output, context) => {
        return take(output, {
          Devices: _ => de_DeviceListType(_, context),
          PaginationToken: expectString
        });
      };
      const de_AdminListGroupsForUserResponse = (output, context) => {
        return take(output, {
          Groups: _ => de_GroupListType(_, context),
          NextToken: expectString
        });
      };
      const de_AdminListUserAuthEventsResponse = (output, context) => {
        return take(output, {
          AuthEvents: _ => de_AuthEventsType(_, context),
          NextToken: expectString
        });
      };
      const de_AuthEventsType = (output, context) => {
        const retVal = (output || []).filter(e => e != null).map(entry => {
          return de_AuthEventType(entry, context);
        });
        return retVal;
      };
      const de_AuthEventType = (output, context) => {
        return take(output, {
          ChallengeResponses: _json,
          CreationDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          EventContextData: _json,
          EventFeedback: _ => de_EventFeedbackType(_, context),
          EventId: expectString,
          EventResponse: expectString,
          EventRisk: _json,
          EventType: expectString
        });
      };
      const de_CreateGroupResponse = (output, context) => {
        return take(output, {
          Group: _ => de_GroupType(_, context)
        });
      };
      const de_CreateIdentityProviderResponse = (output, context) => {
        return take(output, {
          IdentityProvider: _ => de_IdentityProviderType(_, context)
        });
      };
      const de_CreateUserImportJobResponse = (output, context) => {
        return take(output, {
          UserImportJob: _ => de_UserImportJobType(_, context)
        });
      };
      const de_CreateUserPoolClientResponse = (output, context) => {
        return take(output, {
          UserPoolClient: _ => de_UserPoolClientType(_, context)
        });
      };
      const de_CreateUserPoolResponse = (output, context) => {
        return take(output, {
          UserPool: _ => de_UserPoolType(_, context)
        });
      };
      const de_DescribeIdentityProviderResponse = (output, context) => {
        return take(output, {
          IdentityProvider: _ => de_IdentityProviderType(_, context)
        });
      };
      const de_DescribeRiskConfigurationResponse = (output, context) => {
        return take(output, {
          RiskConfiguration: _ => de_RiskConfigurationType(_, context)
        });
      };
      const de_DescribeUserImportJobResponse = (output, context) => {
        return take(output, {
          UserImportJob: _ => de_UserImportJobType(_, context)
        });
      };
      const de_DescribeUserPoolClientResponse = (output, context) => {
        return take(output, {
          UserPoolClient: _ => de_UserPoolClientType(_, context)
        });
      };
      const de_DescribeUserPoolResponse = (output, context) => {
        return take(output, {
          UserPool: _ => de_UserPoolType(_, context)
        });
      };
      const de_DeviceListType = (output, context) => {
        const retVal = (output || []).filter(e => e != null).map(entry => {
          return de_DeviceType(entry, context);
        });
        return retVal;
      };
      const de_DeviceType = (output, context) => {
        return take(output, {
          DeviceAttributes: _json,
          DeviceCreateDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          DeviceKey: expectString,
          DeviceLastAuthenticatedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          DeviceLastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_)))
        });
      };
      const de_EventFeedbackType = (output, context) => {
        return take(output, {
          FeedbackDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          FeedbackValue: expectString,
          Provider: expectString
        });
      };
      const de_GetDeviceResponse = (output, context) => {
        return take(output, {
          Device: _ => de_DeviceType(_, context)
        });
      };
      const de_GetGroupResponse = (output, context) => {
        return take(output, {
          Group: _ => de_GroupType(_, context)
        });
      };
      const de_GetIdentityProviderByIdentifierResponse = (output, context) => {
        return take(output, {
          IdentityProvider: _ => de_IdentityProviderType(_, context)
        });
      };
      const de_GetUICustomizationResponse = (output, context) => {
        return take(output, {
          UICustomization: _ => de_UICustomizationType(_, context)
        });
      };
      const de_GroupListType = (output, context) => {
        const retVal = (output || []).filter(e => e != null).map(entry => {
          return de_GroupType(entry, context);
        });
        return retVal;
      };
      const de_GroupType = (output, context) => {
        return take(output, {
          CreationDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          Description: expectString,
          GroupName: expectString,
          LastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          Precedence: expectInt32,
          RoleArn: expectString,
          UserPoolId: expectString
        });
      };
      const de_IdentityProviderType = (output, context) => {
        return take(output, {
          AttributeMapping: _json,
          CreationDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          IdpIdentifiers: _json,
          LastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          ProviderDetails: _json,
          ProviderName: expectString,
          ProviderType: expectString,
          UserPoolId: expectString
        });
      };
      const de_ListDevicesResponse = (output, context) => {
        return take(output, {
          Devices: _ => de_DeviceListType(_, context),
          PaginationToken: expectString
        });
      };
      const de_ListGroupsResponse = (output, context) => {
        return take(output, {
          Groups: _ => de_GroupListType(_, context),
          NextToken: expectString
        });
      };
      const de_ListIdentityProvidersResponse = (output, context) => {
        return take(output, {
          NextToken: expectString,
          Providers: _ => de_ProvidersListType(_, context)
        });
      };
      const de_ListUserImportJobsResponse = (output, context) => {
        return take(output, {
          PaginationToken: expectString,
          UserImportJobs: _ => de_UserImportJobsListType(_, context)
        });
      };
      const de_ListUserPoolsResponse = (output, context) => {
        return take(output, {
          NextToken: expectString,
          UserPools: _ => de_UserPoolListType(_, context)
        });
      };
      const de_ListUsersInGroupResponse = (output, context) => {
        return take(output, {
          NextToken: expectString,
          Users: _ => de_UsersListType(_, context)
        });
      };
      const de_ListUsersResponse = (output, context) => {
        return take(output, {
          PaginationToken: expectString,
          Users: _ => de_UsersListType(_, context)
        });
      };
      const de_ProviderDescription = (output, context) => {
        return take(output, {
          CreationDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          LastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          ProviderName: expectString,
          ProviderType: expectString
        });
      };
      const de_ProvidersListType = (output, context) => {
        const retVal = (output || []).filter(e => e != null).map(entry => {
          return de_ProviderDescription(entry, context);
        });
        return retVal;
      };
      const de_RiskConfigurationType = (output, context) => {
        return take(output, {
          AccountTakeoverRiskConfiguration: _json,
          ClientId: expectString,
          CompromisedCredentialsRiskConfiguration: _json,
          LastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          RiskExceptionConfiguration: _json,
          UserPoolId: expectString
        });
      };
      const de_SetRiskConfigurationResponse = (output, context) => {
        return take(output, {
          RiskConfiguration: _ => de_RiskConfigurationType(_, context)
        });
      };
      const de_SetUICustomizationResponse = (output, context) => {
        return take(output, {
          UICustomization: _ => de_UICustomizationType(_, context)
        });
      };
      const de_StartUserImportJobResponse = (output, context) => {
        return take(output, {
          UserImportJob: _ => de_UserImportJobType(_, context)
        });
      };
      const de_StopUserImportJobResponse = (output, context) => {
        return take(output, {
          UserImportJob: _ => de_UserImportJobType(_, context)
        });
      };
      const de_UICustomizationType = (output, context) => {
        return take(output, {
          CSS: expectString,
          CSSVersion: expectString,
          ClientId: expectString,
          CreationDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          ImageUrl: expectString,
          LastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          UserPoolId: expectString
        });
      };
      const de_UpdateGroupResponse = (output, context) => {
        return take(output, {
          Group: _ => de_GroupType(_, context)
        });
      };
      const de_UpdateIdentityProviderResponse = (output, context) => {
        return take(output, {
          IdentityProvider: _ => de_IdentityProviderType(_, context)
        });
      };
      const de_UpdateUserPoolClientResponse = (output, context) => {
        return take(output, {
          UserPoolClient: _ => de_UserPoolClientType(_, context)
        });
      };
      const de_UserImportJobsListType = (output, context) => {
        const retVal = (output || []).filter(e => e != null).map(entry => {
          return de_UserImportJobType(entry, context);
        });
        return retVal;
      };
      const de_UserImportJobType = (output, context) => {
        return take(output, {
          CloudWatchLogsRoleArn: expectString,
          CompletionDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          CompletionMessage: expectString,
          CreationDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          FailedUsers: expectLong,
          ImportedUsers: expectLong,
          JobId: expectString,
          JobName: expectString,
          PreSignedUrl: expectString,
          SkippedUsers: expectLong,
          StartDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          Status: expectString,
          UserPoolId: expectString
        });
      };
      const de_UserPoolClientType = (output, context) => {
        return take(output, {
          AccessTokenValidity: expectInt32,
          AllowedOAuthFlows: _json,
          AllowedOAuthFlowsUserPoolClient: expectBoolean,
          AllowedOAuthScopes: _json,
          AnalyticsConfiguration: _json,
          AuthSessionValidity: expectInt32,
          CallbackURLs: _json,
          ClientId: expectString,
          ClientName: expectString,
          ClientSecret: expectString,
          CreationDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          DefaultRedirectURI: expectString,
          EnablePropagateAdditionalUserContextData: expectBoolean,
          EnableTokenRevocation: expectBoolean,
          ExplicitAuthFlows: _json,
          IdTokenValidity: expectInt32,
          LastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          LogoutURLs: _json,
          PreventUserExistenceErrors: expectString,
          ReadAttributes: _json,
          RefreshTokenValidity: expectInt32,
          SupportedIdentityProviders: _json,
          TokenValidityUnits: _json,
          UserPoolId: expectString,
          WriteAttributes: _json
        });
      };
      const de_UserPoolDescriptionType = (output, context) => {
        return take(output, {
          CreationDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          Id: expectString,
          LambdaConfig: _json,
          LastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          Name: expectString,
          Status: expectString
        });
      };
      const de_UserPoolListType = (output, context) => {
        const retVal = (output || []).filter(e => e != null).map(entry => {
          return de_UserPoolDescriptionType(entry, context);
        });
        return retVal;
      };
      const de_UserPoolType = (output, context) => {
        return take(output, {
          AccountRecoverySetting: _json,
          AdminCreateUserConfig: _json,
          AliasAttributes: _json,
          Arn: expectString,
          AutoVerifiedAttributes: _json,
          CreationDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          CustomDomain: expectString,
          DeletionProtection: expectString,
          DeviceConfiguration: _json,
          Domain: expectString,
          EmailConfiguration: _json,
          EmailConfigurationFailure: expectString,
          EmailVerificationMessage: expectString,
          EmailVerificationSubject: expectString,
          EstimatedNumberOfUsers: expectInt32,
          Id: expectString,
          LambdaConfig: _json,
          LastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          MfaConfiguration: expectString,
          Name: expectString,
          Policies: _json,
          SchemaAttributes: _json,
          SmsAuthenticationMessage: expectString,
          SmsConfiguration: _json,
          SmsConfigurationFailure: expectString,
          SmsVerificationMessage: expectString,
          Status: expectString,
          UserAttributeUpdateSettings: _json,
          UserPoolAddOns: _json,
          UserPoolTags: _json,
          UsernameAttributes: _json,
          UsernameConfiguration: _json,
          VerificationMessageTemplate: _json
        });
      };
      const de_UsersListType = (output, context) => {
        const retVal = (output || []).filter(e => e != null).map(entry => {
          return de_UserType(entry, context);
        });
        return retVal;
      };
      const de_UserType = (output, context) => {
        return take(output, {
          Attributes: _json,
          Enabled: expectBoolean,
          MFAOptions: _json,
          UserCreateDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          UserLastModifiedDate: _ => expectNonNull(parseEpochTimestamp(expectNumber(_))),
          UserStatus: expectString,
          Username: expectString
        });
      };
      const Aws_json1_1_deserializeMetadata = output => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"]
      });
      const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then(body => context.utf8Encoder(body));
      const Aws_json1_1_throwDefaultError = withBaseException(CognitoIdentityProviderServiceException);
      const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
        const {
          hostname,
          protocol = "https",
          port,
          path: basePath
        } = await context.endpoint();
        const contents = {
          protocol,
          hostname,
          port,
          method: "POST",
          path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
          headers
        };
        if (resolvedHostname !== undefined) {
          contents.hostname = resolvedHostname;
        }
        if (body !== undefined) {
          contents.body = body;
        }
        return new httpRequest_HttpRequest(contents);
      };
      function sharedHeaders(operation) {
        return {
          "content-type": "application/x-amz-json-1.1",
          "x-amz-target": `AWSCognitoIdentityProviderService.${operation}`
        };
      }
      const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then(encoded => {
        if (encoded.length) {
          return JSON.parse(encoded);
        }
        return {};
      });
      const parseErrorBody = async (errorBody, context) => {
        const value = await parseBody(errorBody, context);
        value.message = value.message ?? value.Message;
        return value;
      };
      const loadRestJsonErrorCode = (output, data) => {
        const findKey = (object, key) => Object.keys(object).find(k => k.toLowerCase() === key.toLowerCase());
        const sanitizeErrorCode = rawValue => {
          let cleanValue = rawValue;
          if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
          }
          if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
          }
          if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
          }
          if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
          }
          return cleanValue;
        };
        const headerKey = findKey(output.headers, "x-amzn-errortype");
        if (headerKey !== undefined) {
          return sanitizeErrorCode(output.headers[headerKey]);
        }
        if (data.code !== undefined) {
          return sanitizeErrorCode(data.code);
        }
        if (data["__type"] !== undefined) {
          return sanitizeErrorCode(data["__type"]);
        }
      };
      ;
      class AddCustomAttributesCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AddCustomAttributesCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AddCustomAttributesCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AddCustomAttributesCommand(input, context);
        }
        deserialize(output, context) {
          return de_AddCustomAttributesCommand(output, context);
        }
      }
      ;
      class AdminAddUserToGroupCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminAddUserToGroupCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminAddUserToGroupCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminAddUserToGroupRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminAddUserToGroupCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminAddUserToGroupCommand(output, context);
        }
      }
      ;
      class AdminConfirmSignUpCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminConfirmSignUpCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminConfirmSignUpCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminConfirmSignUpRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminConfirmSignUpCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminConfirmSignUpCommand(output, context);
        }
      }
      ;
      class AdminCreateUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminCreateUserCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminCreateUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminCreateUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: AdminCreateUserResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminCreateUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminCreateUserCommand(output, context);
        }
      }
      ;
      class AdminDeleteUserAttributesCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminDeleteUserAttributesCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminDeleteUserAttributesCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminDeleteUserAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminDeleteUserAttributesCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminDeleteUserAttributesCommand(output, context);
        }
      }
      ;
      class AdminDeleteUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminDeleteUserCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminDeleteUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminDeleteUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminDeleteUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminDeleteUserCommand(output, context);
        }
      }
      ;
      class AdminDisableProviderForUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminDisableProviderForUserCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminDisableProviderForUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminDisableProviderForUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminDisableProviderForUserCommand(output, context);
        }
      }
      ;
      class AdminDisableUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminDisableUserCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminDisableUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminDisableUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminDisableUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminDisableUserCommand(output, context);
        }
      }
      ;
      class AdminEnableUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminEnableUserCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminEnableUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminEnableUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminEnableUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminEnableUserCommand(output, context);
        }
      }
      ;
      class AdminForgetDeviceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminForgetDeviceCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminForgetDeviceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminForgetDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminForgetDeviceCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminForgetDeviceCommand(output, context);
        }
      }
      ;
      class AdminGetDeviceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminGetDeviceCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminGetDeviceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminGetDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: AdminGetDeviceResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminGetDeviceCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminGetDeviceCommand(output, context);
        }
      }
      ;
      class AdminGetUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminGetUserCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminGetUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminGetUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: AdminGetUserResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminGetUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminGetUserCommand(output, context);
        }
      }
      ;
      class AdminInitiateAuthCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminInitiateAuthCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminInitiateAuthCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminInitiateAuthRequestFilterSensitiveLog,
            outputFilterSensitiveLog: AdminInitiateAuthResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminInitiateAuthCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminInitiateAuthCommand(output, context);
        }
      }
      ;
      class AdminLinkProviderForUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminLinkProviderForUserCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminLinkProviderForUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminLinkProviderForUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminLinkProviderForUserCommand(output, context);
        }
      }
      ;
      class AdminListDevicesCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminListDevicesCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminListDevicesCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminListDevicesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: AdminListDevicesResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminListDevicesCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminListDevicesCommand(output, context);
        }
      }
      ;
      class AdminListGroupsForUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminListGroupsForUserCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminListGroupsForUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminListGroupsForUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminListGroupsForUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminListGroupsForUserCommand(output, context);
        }
      }
      ;
      class AdminListUserAuthEventsCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminListUserAuthEventsCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminListUserAuthEventsCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminListUserAuthEventsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminListUserAuthEventsCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminListUserAuthEventsCommand(output, context);
        }
      }
      ;
      class AdminRemoveUserFromGroupCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminRemoveUserFromGroupCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminRemoveUserFromGroupCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminRemoveUserFromGroupRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminRemoveUserFromGroupCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminRemoveUserFromGroupCommand(output, context);
        }
      }
      ;
      class AdminResetUserPasswordCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminResetUserPasswordCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminResetUserPasswordCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminResetUserPasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminResetUserPasswordCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminResetUserPasswordCommand(output, context);
        }
      }
      ;
      class AdminRespondToAuthChallengeCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminRespondToAuthChallengeCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminRespondToAuthChallengeCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminRespondToAuthChallengeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: AdminRespondToAuthChallengeResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminRespondToAuthChallengeCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminRespondToAuthChallengeCommand(output, context);
        }
      }
      ;
      class AdminSetUserMFAPreferenceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminSetUserMFAPreferenceCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminSetUserMFAPreferenceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminSetUserMFAPreferenceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminSetUserMFAPreferenceCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminSetUserMFAPreferenceCommand(output, context);
        }
      }
      ;
      class AdminSetUserPasswordCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminSetUserPasswordCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminSetUserPasswordCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminSetUserPasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminSetUserPasswordCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminSetUserPasswordCommand(output, context);
        }
      }
      ;
      class AdminSetUserSettingsCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminSetUserSettingsCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminSetUserSettingsCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminSetUserSettingsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminSetUserSettingsCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminSetUserSettingsCommand(output, context);
        }
      }
      ;
      class AdminUpdateAuthEventFeedbackCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminUpdateAuthEventFeedbackCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminUpdateAuthEventFeedbackCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminUpdateAuthEventFeedbackRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminUpdateAuthEventFeedbackCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminUpdateAuthEventFeedbackCommand(output, context);
        }
      }
      ;
      class AdminUpdateDeviceStatusCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminUpdateDeviceStatusCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminUpdateDeviceStatusCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminUpdateDeviceStatusRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminUpdateDeviceStatusCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminUpdateDeviceStatusCommand(output, context);
        }
      }
      ;
      class AdminUpdateUserAttributesCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminUpdateUserAttributesCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminUpdateUserAttributesCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminUpdateUserAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminUpdateUserAttributesCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminUpdateUserAttributesCommand(output, context);
        }
      }
      ;
      class AdminUserGlobalSignOutCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AdminUserGlobalSignOutCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AdminUserGlobalSignOutCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AdminUserGlobalSignOutRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AdminUserGlobalSignOutCommand(input, context);
        }
        deserialize(output, context) {
          return de_AdminUserGlobalSignOutCommand(output, context);
        }
      }
      ;
      class AssociateSoftwareTokenCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, AssociateSoftwareTokenCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "AssociateSoftwareTokenCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: AssociateSoftwareTokenRequestFilterSensitiveLog,
            outputFilterSensitiveLog: AssociateSoftwareTokenResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_AssociateSoftwareTokenCommand(input, context);
        }
        deserialize(output, context) {
          return de_AssociateSoftwareTokenCommand(output, context);
        }
      }
      ;
      class ChangePasswordCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ChangePasswordCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ChangePasswordCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: ChangePasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ChangePasswordCommand(input, context);
        }
        deserialize(output, context) {
          return de_ChangePasswordCommand(output, context);
        }
      }
      ;
      class ConfirmDeviceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ConfirmDeviceCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ConfirmDeviceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: ConfirmDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ConfirmDeviceCommand(input, context);
        }
        deserialize(output, context) {
          return de_ConfirmDeviceCommand(output, context);
        }
      }
      ;
      class ConfirmForgotPasswordCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ConfirmForgotPasswordCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ConfirmForgotPasswordCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: ConfirmForgotPasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ConfirmForgotPasswordCommand(input, context);
        }
        deserialize(output, context) {
          return de_ConfirmForgotPasswordCommand(output, context);
        }
      }
      ;
      class ConfirmSignUpCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ConfirmSignUpCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ConfirmSignUpCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: ConfirmSignUpRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ConfirmSignUpCommand(input, context);
        }
        deserialize(output, context) {
          return de_ConfirmSignUpCommand(output, context);
        }
      }
      ;
      class CreateGroupCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, CreateGroupCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "CreateGroupCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_CreateGroupCommand(input, context);
        }
        deserialize(output, context) {
          return de_CreateGroupCommand(output, context);
        }
      }
      ;
      class CreateIdentityProviderCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, CreateIdentityProviderCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "CreateIdentityProviderCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_CreateIdentityProviderCommand(input, context);
        }
        deserialize(output, context) {
          return de_CreateIdentityProviderCommand(output, context);
        }
      }
      ;
      class CreateResourceServerCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, CreateResourceServerCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "CreateResourceServerCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_CreateResourceServerCommand(input, context);
        }
        deserialize(output, context) {
          return de_CreateResourceServerCommand(output, context);
        }
      }
      ;
      class CreateUserImportJobCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, CreateUserImportJobCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "CreateUserImportJobCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_CreateUserImportJobCommand(input, context);
        }
        deserialize(output, context) {
          return de_CreateUserImportJobCommand(output, context);
        }
      }
      ;
      class CreateUserPoolClientCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, CreateUserPoolClientCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "CreateUserPoolClientCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: CreateUserPoolClientResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_CreateUserPoolClientCommand(input, context);
        }
        deserialize(output, context) {
          return de_CreateUserPoolClientCommand(output, context);
        }
      }
      ;
      class CreateUserPoolCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, CreateUserPoolCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "CreateUserPoolCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_CreateUserPoolCommand(input, context);
        }
        deserialize(output, context) {
          return de_CreateUserPoolCommand(output, context);
        }
      }
      ;
      class CreateUserPoolDomainCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, CreateUserPoolDomainCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "CreateUserPoolDomainCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_CreateUserPoolDomainCommand(input, context);
        }
        deserialize(output, context) {
          return de_CreateUserPoolDomainCommand(output, context);
        }
      }
      ;
      class DeleteGroupCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DeleteGroupCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DeleteGroupCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DeleteGroupCommand(input, context);
        }
        deserialize(output, context) {
          return de_DeleteGroupCommand(output, context);
        }
      }
      ;
      class DeleteIdentityProviderCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DeleteIdentityProviderCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DeleteIdentityProviderCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DeleteIdentityProviderCommand(input, context);
        }
        deserialize(output, context) {
          return de_DeleteIdentityProviderCommand(output, context);
        }
      }
      ;
      class DeleteResourceServerCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DeleteResourceServerCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DeleteResourceServerCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DeleteResourceServerCommand(input, context);
        }
        deserialize(output, context) {
          return de_DeleteResourceServerCommand(output, context);
        }
      }
      ;
      class DeleteUserAttributesCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DeleteUserAttributesCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DeleteUserAttributesCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: DeleteUserAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DeleteUserAttributesCommand(input, context);
        }
        deserialize(output, context) {
          return de_DeleteUserAttributesCommand(output, context);
        }
      }
      ;
      class DeleteUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DeleteUserCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DeleteUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: DeleteUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DeleteUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_DeleteUserCommand(output, context);
        }
      }
      ;
      class DeleteUserPoolClientCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DeleteUserPoolClientCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DeleteUserPoolClientCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: DeleteUserPoolClientRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DeleteUserPoolClientCommand(input, context);
        }
        deserialize(output, context) {
          return de_DeleteUserPoolClientCommand(output, context);
        }
      }
      ;
      class DeleteUserPoolCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DeleteUserPoolCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DeleteUserPoolCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DeleteUserPoolCommand(input, context);
        }
        deserialize(output, context) {
          return de_DeleteUserPoolCommand(output, context);
        }
      }
      ;
      class DeleteUserPoolDomainCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DeleteUserPoolDomainCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DeleteUserPoolDomainCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DeleteUserPoolDomainCommand(input, context);
        }
        deserialize(output, context) {
          return de_DeleteUserPoolDomainCommand(output, context);
        }
      }
      ;
      class DescribeIdentityProviderCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DescribeIdentityProviderCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DescribeIdentityProviderCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DescribeIdentityProviderCommand(input, context);
        }
        deserialize(output, context) {
          return de_DescribeIdentityProviderCommand(output, context);
        }
      }
      ;
      class DescribeResourceServerCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DescribeResourceServerCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DescribeResourceServerCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DescribeResourceServerCommand(input, context);
        }
        deserialize(output, context) {
          return de_DescribeResourceServerCommand(output, context);
        }
      }
      ;
      class DescribeRiskConfigurationCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DescribeRiskConfigurationCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DescribeRiskConfigurationCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: DescribeRiskConfigurationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: DescribeRiskConfigurationResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DescribeRiskConfigurationCommand(input, context);
        }
        deserialize(output, context) {
          return de_DescribeRiskConfigurationCommand(output, context);
        }
      }
      ;
      class DescribeUserImportJobCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DescribeUserImportJobCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DescribeUserImportJobCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DescribeUserImportJobCommand(input, context);
        }
        deserialize(output, context) {
          return de_DescribeUserImportJobCommand(output, context);
        }
      }
      ;
      class DescribeUserPoolClientCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DescribeUserPoolClientCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DescribeUserPoolClientCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: DescribeUserPoolClientRequestFilterSensitiveLog,
            outputFilterSensitiveLog: DescribeUserPoolClientResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DescribeUserPoolClientCommand(input, context);
        }
        deserialize(output, context) {
          return de_DescribeUserPoolClientCommand(output, context);
        }
      }
      ;
      class DescribeUserPoolCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DescribeUserPoolCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DescribeUserPoolCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DescribeUserPoolCommand(input, context);
        }
        deserialize(output, context) {
          return de_DescribeUserPoolCommand(output, context);
        }
      }
      ;
      class DescribeUserPoolDomainCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, DescribeUserPoolDomainCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "DescribeUserPoolDomainCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_DescribeUserPoolDomainCommand(input, context);
        }
        deserialize(output, context) {
          return de_DescribeUserPoolDomainCommand(output, context);
        }
      }
      ;
      class ForgetDeviceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ForgetDeviceCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ForgetDeviceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: ForgetDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ForgetDeviceCommand(input, context);
        }
        deserialize(output, context) {
          return de_ForgetDeviceCommand(output, context);
        }
      }
      ;
      class ForgotPasswordCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ForgotPasswordCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ForgotPasswordCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: ForgotPasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ForgotPasswordCommand(input, context);
        }
        deserialize(output, context) {
          return de_ForgotPasswordCommand(output, context);
        }
      }
      ;
      class GetCSVHeaderCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetCSVHeaderCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetCSVHeaderCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetCSVHeaderCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetCSVHeaderCommand(output, context);
        }
      }
      ;
      class GetDeviceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetDeviceCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetDeviceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: GetDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: GetDeviceResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetDeviceCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetDeviceCommand(output, context);
        }
      }
      ;
      class GetGroupCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetGroupCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetGroupCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetGroupCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetGroupCommand(output, context);
        }
      }
      ;
      class GetIdentityProviderByIdentifierCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetIdentityProviderByIdentifierCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetIdentityProviderByIdentifierCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetIdentityProviderByIdentifierCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetIdentityProviderByIdentifierCommand(output, context);
        }
      }
      ;
      class GetLogDeliveryConfigurationCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetLogDeliveryConfigurationCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetLogDeliveryConfigurationCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetLogDeliveryConfigurationCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetLogDeliveryConfigurationCommand(output, context);
        }
      }
      ;
      class GetSigningCertificateCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetSigningCertificateCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetSigningCertificateCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetSigningCertificateCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetSigningCertificateCommand(output, context);
        }
      }
      ;
      class GetUICustomizationCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetUICustomizationCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetUICustomizationCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: GetUICustomizationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: GetUICustomizationResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetUICustomizationCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetUICustomizationCommand(output, context);
        }
      }
      ;
      class GetUserAttributeVerificationCodeCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetUserAttributeVerificationCodeCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetUserAttributeVerificationCodeCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: GetUserAttributeVerificationCodeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetUserAttributeVerificationCodeCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetUserAttributeVerificationCodeCommand(output, context);
        }
      }
      ;
      class GetUserCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetUserCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetUserCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: GetUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: GetUserResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetUserCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetUserCommand(output, context);
        }
      }
      ;
      class GetUserPoolMfaConfigCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GetUserPoolMfaConfigCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GetUserPoolMfaConfigCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GetUserPoolMfaConfigCommand(input, context);
        }
        deserialize(output, context) {
          return de_GetUserPoolMfaConfigCommand(output, context);
        }
      }
      ;
      class GlobalSignOutCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, GlobalSignOutCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "GlobalSignOutCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: GlobalSignOutRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_GlobalSignOutCommand(input, context);
        }
        deserialize(output, context) {
          return de_GlobalSignOutCommand(output, context);
        }
      }
      ;
      class InitiateAuthCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, InitiateAuthCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "InitiateAuthCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: InitiateAuthRequestFilterSensitiveLog,
            outputFilterSensitiveLog: InitiateAuthResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_InitiateAuthCommand(input, context);
        }
        deserialize(output, context) {
          return de_InitiateAuthCommand(output, context);
        }
      }
      ;
      class ListDevicesCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListDevicesCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListDevicesCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: ListDevicesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: ListDevicesResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListDevicesCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListDevicesCommand(output, context);
        }
      }
      ;
      class ListGroupsCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListGroupsCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListGroupsCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListGroupsCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListGroupsCommand(output, context);
        }
      }
      ;
      class ListIdentityProvidersCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListIdentityProvidersCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListIdentityProvidersCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListIdentityProvidersCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListIdentityProvidersCommand(output, context);
        }
      }
      ;
      class ListResourceServersCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListResourceServersCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListResourceServersCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListResourceServersCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListResourceServersCommand(output, context);
        }
      }
      ;
      class ListTagsForResourceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListTagsForResourceCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListTagsForResourceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListTagsForResourceCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListTagsForResourceCommand(output, context);
        }
      }
      ;
      class ListUserImportJobsCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListUserImportJobsCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListUserImportJobsCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListUserImportJobsCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListUserImportJobsCommand(output, context);
        }
      }
      ;
      class ListUserPoolClientsCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListUserPoolClientsCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListUserPoolClientsCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: ListUserPoolClientsResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListUserPoolClientsCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListUserPoolClientsCommand(output, context);
        }
      }
      ;
      class ListUserPoolsCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListUserPoolsCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListUserPoolsCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListUserPoolsCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListUserPoolsCommand(output, context);
        }
      }
      ;
      class ListUsersCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListUsersCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListUsersCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: ListUsersResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListUsersCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListUsersCommand(output, context);
        }
      }
      ;
      class ListUsersInGroupCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ListUsersInGroupCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ListUsersInGroupCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: ListUsersInGroupResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ListUsersInGroupCommand(input, context);
        }
        deserialize(output, context) {
          return de_ListUsersInGroupCommand(output, context);
        }
      }
      ;
      class ResendConfirmationCodeCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, ResendConfirmationCodeCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "ResendConfirmationCodeCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: ResendConfirmationCodeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_ResendConfirmationCodeCommand(input, context);
        }
        deserialize(output, context) {
          return de_ResendConfirmationCodeCommand(output, context);
        }
      }
      ;
      class RespondToAuthChallengeCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, RespondToAuthChallengeCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "RespondToAuthChallengeCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: RespondToAuthChallengeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: RespondToAuthChallengeResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_RespondToAuthChallengeCommand(input, context);
        }
        deserialize(output, context) {
          return de_RespondToAuthChallengeCommand(output, context);
        }
      }
      ;
      class RevokeTokenCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, RevokeTokenCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "RevokeTokenCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: RevokeTokenRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_RevokeTokenCommand(input, context);
        }
        deserialize(output, context) {
          return de_RevokeTokenCommand(output, context);
        }
      }
      ;
      class SetLogDeliveryConfigurationCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, SetLogDeliveryConfigurationCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "SetLogDeliveryConfigurationCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_SetLogDeliveryConfigurationCommand(input, context);
        }
        deserialize(output, context) {
          return de_SetLogDeliveryConfigurationCommand(output, context);
        }
      }
      ;
      class SetRiskConfigurationCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, SetRiskConfigurationCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "SetRiskConfigurationCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: SetRiskConfigurationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: SetRiskConfigurationResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_SetRiskConfigurationCommand(input, context);
        }
        deserialize(output, context) {
          return de_SetRiskConfigurationCommand(output, context);
        }
      }
      ;
      class SetUICustomizationCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, SetUICustomizationCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "SetUICustomizationCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: SetUICustomizationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: SetUICustomizationResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_SetUICustomizationCommand(input, context);
        }
        deserialize(output, context) {
          return de_SetUICustomizationCommand(output, context);
        }
      }
      ;
      class SetUserMFAPreferenceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, SetUserMFAPreferenceCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "SetUserMFAPreferenceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: SetUserMFAPreferenceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_SetUserMFAPreferenceCommand(input, context);
        }
        deserialize(output, context) {
          return de_SetUserMFAPreferenceCommand(output, context);
        }
      }
      ;
      class SetUserPoolMfaConfigCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, SetUserPoolMfaConfigCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "SetUserPoolMfaConfigCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_SetUserPoolMfaConfigCommand(input, context);
        }
        deserialize(output, context) {
          return de_SetUserPoolMfaConfigCommand(output, context);
        }
      }
      ;
      class SetUserSettingsCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, SetUserSettingsCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "SetUserSettingsCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: SetUserSettingsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_SetUserSettingsCommand(input, context);
        }
        deserialize(output, context) {
          return de_SetUserSettingsCommand(output, context);
        }
      }
      ;
      class SignUpCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, SignUpCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "SignUpCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: SignUpRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_SignUpCommand(input, context);
        }
        deserialize(output, context) {
          return de_SignUpCommand(output, context);
        }
      }
      ;
      class StartUserImportJobCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, StartUserImportJobCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "StartUserImportJobCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_StartUserImportJobCommand(input, context);
        }
        deserialize(output, context) {
          return de_StartUserImportJobCommand(output, context);
        }
      }
      ;
      class StopUserImportJobCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, StopUserImportJobCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "StopUserImportJobCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_StopUserImportJobCommand(input, context);
        }
        deserialize(output, context) {
          return de_StopUserImportJobCommand(output, context);
        }
      }
      ;
      class TagResourceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, TagResourceCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "TagResourceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_TagResourceCommand(input, context);
        }
        deserialize(output, context) {
          return de_TagResourceCommand(output, context);
        }
      }
      ;
      class UntagResourceCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UntagResourceCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UntagResourceCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UntagResourceCommand(input, context);
        }
        deserialize(output, context) {
          return de_UntagResourceCommand(output, context);
        }
      }
      ;
      class UpdateAuthEventFeedbackCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UpdateAuthEventFeedbackCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UpdateAuthEventFeedbackCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: UpdateAuthEventFeedbackRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UpdateAuthEventFeedbackCommand(input, context);
        }
        deserialize(output, context) {
          return de_UpdateAuthEventFeedbackCommand(output, context);
        }
      }
      ;
      class UpdateDeviceStatusCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UpdateDeviceStatusCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UpdateDeviceStatusCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: UpdateDeviceStatusRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UpdateDeviceStatusCommand(input, context);
        }
        deserialize(output, context) {
          return de_UpdateDeviceStatusCommand(output, context);
        }
      }
      ;
      class UpdateGroupCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UpdateGroupCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UpdateGroupCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UpdateGroupCommand(input, context);
        }
        deserialize(output, context) {
          return de_UpdateGroupCommand(output, context);
        }
      }
      ;
      class UpdateIdentityProviderCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UpdateIdentityProviderCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UpdateIdentityProviderCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UpdateIdentityProviderCommand(input, context);
        }
        deserialize(output, context) {
          return de_UpdateIdentityProviderCommand(output, context);
        }
      }
      ;
      class UpdateResourceServerCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UpdateResourceServerCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UpdateResourceServerCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UpdateResourceServerCommand(input, context);
        }
        deserialize(output, context) {
          return de_UpdateResourceServerCommand(output, context);
        }
      }
      ;
      class UpdateUserAttributesCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UpdateUserAttributesCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UpdateUserAttributesCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: UpdateUserAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UpdateUserAttributesCommand(input, context);
        }
        deserialize(output, context) {
          return de_UpdateUserAttributesCommand(output, context);
        }
      }
      ;
      class UpdateUserPoolClientCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UpdateUserPoolClientCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UpdateUserPoolClientCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: UpdateUserPoolClientRequestFilterSensitiveLog,
            outputFilterSensitiveLog: UpdateUserPoolClientResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UpdateUserPoolClientCommand(input, context);
        }
        deserialize(output, context) {
          return de_UpdateUserPoolClientCommand(output, context);
        }
      }
      ;
      class UpdateUserPoolCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UpdateUserPoolCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UpdateUserPoolCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UpdateUserPoolCommand(input, context);
        }
        deserialize(output, context) {
          return de_UpdateUserPoolCommand(output, context);
        }
      }
      ;
      class UpdateUserPoolDomainCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, UpdateUserPoolDomainCommand.getEndpointParameterInstructions()));
          this.middlewareStack.use(getAwsAuthPlugin(configuration));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "UpdateUserPoolDomainCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: _ => _,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_UpdateUserPoolDomainCommand(input, context);
        }
        deserialize(output, context) {
          return de_UpdateUserPoolDomainCommand(output, context);
        }
      }
      ;
      class VerifySoftwareTokenCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, VerifySoftwareTokenCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "VerifySoftwareTokenCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: VerifySoftwareTokenRequestFilterSensitiveLog,
            outputFilterSensitiveLog: VerifySoftwareTokenResponseFilterSensitiveLog
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_VerifySoftwareTokenCommand(input, context);
        }
        deserialize(output, context) {
          return de_VerifySoftwareTokenCommand(output, context);
        }
      }
      ;
      class VerifyUserAttributeCommand extends Command {
        static getEndpointParameterInstructions() {
          return {
            UseFIPS: {
              type: "builtInParams",
              name: "useFipsEndpoint"
            },
            Endpoint: {
              type: "builtInParams",
              name: "endpoint"
            },
            Region: {
              type: "builtInParams",
              name: "region"
            },
            UseDualStack: {
              type: "builtInParams",
              name: "useDualstackEndpoint"
            }
          };
        }
        constructor(input) {
          super();
          this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
          this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
          this.middlewareStack.use(getEndpointPlugin(configuration, VerifyUserAttributeCommand.getEndpointParameterInstructions()));
          const stack = clientStack.concat(this.middlewareStack);
          const {
            logger
          } = configuration;
          const clientName = "CognitoIdentityProviderClient";
          const commandName = "VerifyUserAttributeCommand";
          const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: VerifyUserAttributeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: _ => _
          };
          const {
            requestHandler
          } = configuration;
          return stack.resolve(request => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
          return se_VerifyUserAttributeCommand(input, context);
        }
        deserialize(output, context) {
          return de_VerifyUserAttributeCommand(output, context);
        }
      }
      ;
      const commands = {
        AddCustomAttributesCommand: AddCustomAttributesCommand,
        AdminAddUserToGroupCommand: AdminAddUserToGroupCommand,
        AdminConfirmSignUpCommand: AdminConfirmSignUpCommand,
        AdminCreateUserCommand: AdminCreateUserCommand,
        AdminDeleteUserCommand: AdminDeleteUserCommand,
        AdminDeleteUserAttributesCommand: AdminDeleteUserAttributesCommand,
        AdminDisableProviderForUserCommand: AdminDisableProviderForUserCommand,
        AdminDisableUserCommand: AdminDisableUserCommand,
        AdminEnableUserCommand: AdminEnableUserCommand,
        AdminForgetDeviceCommand: AdminForgetDeviceCommand,
        AdminGetDeviceCommand: AdminGetDeviceCommand,
        AdminGetUserCommand: AdminGetUserCommand,
        AdminInitiateAuthCommand: AdminInitiateAuthCommand,
        AdminLinkProviderForUserCommand: AdminLinkProviderForUserCommand,
        AdminListDevicesCommand: AdminListDevicesCommand,
        AdminListGroupsForUserCommand: AdminListGroupsForUserCommand,
        AdminListUserAuthEventsCommand: AdminListUserAuthEventsCommand,
        AdminRemoveUserFromGroupCommand: AdminRemoveUserFromGroupCommand,
        AdminResetUserPasswordCommand: AdminResetUserPasswordCommand,
        AdminRespondToAuthChallengeCommand: AdminRespondToAuthChallengeCommand,
        AdminSetUserMFAPreferenceCommand: AdminSetUserMFAPreferenceCommand,
        AdminSetUserPasswordCommand: AdminSetUserPasswordCommand,
        AdminSetUserSettingsCommand: AdminSetUserSettingsCommand,
        AdminUpdateAuthEventFeedbackCommand: AdminUpdateAuthEventFeedbackCommand,
        AdminUpdateDeviceStatusCommand: AdminUpdateDeviceStatusCommand,
        AdminUpdateUserAttributesCommand: AdminUpdateUserAttributesCommand,
        AdminUserGlobalSignOutCommand: AdminUserGlobalSignOutCommand,
        AssociateSoftwareTokenCommand: AssociateSoftwareTokenCommand,
        ChangePasswordCommand: ChangePasswordCommand,
        ConfirmDeviceCommand: ConfirmDeviceCommand,
        ConfirmForgotPasswordCommand: ConfirmForgotPasswordCommand,
        ConfirmSignUpCommand: ConfirmSignUpCommand,
        CreateGroupCommand: CreateGroupCommand,
        CreateIdentityProviderCommand: CreateIdentityProviderCommand,
        CreateResourceServerCommand: CreateResourceServerCommand,
        CreateUserImportJobCommand: CreateUserImportJobCommand,
        CreateUserPoolCommand: CreateUserPoolCommand,
        CreateUserPoolClientCommand: CreateUserPoolClientCommand,
        CreateUserPoolDomainCommand: CreateUserPoolDomainCommand,
        DeleteGroupCommand: DeleteGroupCommand,
        DeleteIdentityProviderCommand: DeleteIdentityProviderCommand,
        DeleteResourceServerCommand: DeleteResourceServerCommand,
        DeleteUserCommand: DeleteUserCommand,
        DeleteUserAttributesCommand: DeleteUserAttributesCommand,
        DeleteUserPoolCommand: DeleteUserPoolCommand,
        DeleteUserPoolClientCommand: DeleteUserPoolClientCommand,
        DeleteUserPoolDomainCommand: DeleteUserPoolDomainCommand,
        DescribeIdentityProviderCommand: DescribeIdentityProviderCommand,
        DescribeResourceServerCommand: DescribeResourceServerCommand,
        DescribeRiskConfigurationCommand: DescribeRiskConfigurationCommand,
        DescribeUserImportJobCommand: DescribeUserImportJobCommand,
        DescribeUserPoolCommand: DescribeUserPoolCommand,
        DescribeUserPoolClientCommand: DescribeUserPoolClientCommand,
        DescribeUserPoolDomainCommand: DescribeUserPoolDomainCommand,
        ForgetDeviceCommand: ForgetDeviceCommand,
        ForgotPasswordCommand: ForgotPasswordCommand,
        GetCSVHeaderCommand: GetCSVHeaderCommand,
        GetDeviceCommand: GetDeviceCommand,
        GetGroupCommand: GetGroupCommand,
        GetIdentityProviderByIdentifierCommand: GetIdentityProviderByIdentifierCommand,
        GetLogDeliveryConfigurationCommand: GetLogDeliveryConfigurationCommand,
        GetSigningCertificateCommand: GetSigningCertificateCommand,
        GetUICustomizationCommand: GetUICustomizationCommand,
        GetUserCommand: GetUserCommand,
        GetUserAttributeVerificationCodeCommand: GetUserAttributeVerificationCodeCommand,
        GetUserPoolMfaConfigCommand: GetUserPoolMfaConfigCommand,
        GlobalSignOutCommand: GlobalSignOutCommand,
        InitiateAuthCommand: InitiateAuthCommand,
        ListDevicesCommand: ListDevicesCommand,
        ListGroupsCommand: ListGroupsCommand,
        ListIdentityProvidersCommand: ListIdentityProvidersCommand,
        ListResourceServersCommand: ListResourceServersCommand,
        ListTagsForResourceCommand: ListTagsForResourceCommand,
        ListUserImportJobsCommand: ListUserImportJobsCommand,
        ListUserPoolClientsCommand: ListUserPoolClientsCommand,
        ListUserPoolsCommand: ListUserPoolsCommand,
        ListUsersCommand: ListUsersCommand,
        ListUsersInGroupCommand: ListUsersInGroupCommand,
        ResendConfirmationCodeCommand: ResendConfirmationCodeCommand,
        RespondToAuthChallengeCommand: RespondToAuthChallengeCommand,
        RevokeTokenCommand: RevokeTokenCommand,
        SetLogDeliveryConfigurationCommand: SetLogDeliveryConfigurationCommand,
        SetRiskConfigurationCommand: SetRiskConfigurationCommand,
        SetUICustomizationCommand: SetUICustomizationCommand,
        SetUserMFAPreferenceCommand: SetUserMFAPreferenceCommand,
        SetUserPoolMfaConfigCommand: SetUserPoolMfaConfigCommand,
        SetUserSettingsCommand: SetUserSettingsCommand,
        SignUpCommand: SignUpCommand,
        StartUserImportJobCommand: StartUserImportJobCommand,
        StopUserImportJobCommand: StopUserImportJobCommand,
        TagResourceCommand: TagResourceCommand,
        UntagResourceCommand: UntagResourceCommand,
        UpdateAuthEventFeedbackCommand: UpdateAuthEventFeedbackCommand,
        UpdateDeviceStatusCommand: UpdateDeviceStatusCommand,
        UpdateGroupCommand: UpdateGroupCommand,
        UpdateIdentityProviderCommand: UpdateIdentityProviderCommand,
        UpdateResourceServerCommand: UpdateResourceServerCommand,
        UpdateUserAttributesCommand: UpdateUserAttributesCommand,
        UpdateUserPoolCommand: UpdateUserPoolCommand,
        UpdateUserPoolClientCommand: UpdateUserPoolClientCommand,
        UpdateUserPoolDomainCommand: UpdateUserPoolDomainCommand,
        VerifySoftwareTokenCommand: VerifySoftwareTokenCommand,
        VerifyUserAttributeCommand: VerifyUserAttributeCommand
      };
      class CognitoIdentityProvider extends CognitoIdentityProviderClient {}
      createAggregatedClient(commands, CognitoIdentityProvider);
      ;
      ;
      const makePagedClientRequest = async (client, input, ...args) => {
        return await client.send(new AdminListGroupsForUserCommand(input), ...args);
      };
      async function* paginateAdminListGroupsForUser(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
          input.NextToken = token;
          input["Limit"] = config.pageSize;
          if (config.client instanceof CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
          } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
          }
          yield page;
          const prevToken = token;
          token = page.NextToken;
          hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
      }
      ;
      const AdminListUserAuthEventsPaginator_makePagedClientRequest = async (client, input, ...args) => {
        return await client.send(new AdminListUserAuthEventsCommand(input), ...args);
      };
      async function* paginateAdminListUserAuthEvents(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
          input.NextToken = token;
          input["MaxResults"] = config.pageSize;
          if (config.client instanceof CognitoIdentityProviderClient) {
            page = await AdminListUserAuthEventsPaginator_makePagedClientRequest(config.client, input, ...additionalArguments);
          } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
          }
          yield page;
          const prevToken = token;
          token = page.NextToken;
          hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
      }
      ;
      const ListGroupsPaginator_makePagedClientRequest = async (client, input, ...args) => {
        return await client.send(new ListGroupsCommand(input), ...args);
      };
      async function* paginateListGroups(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
          input.NextToken = token;
          input["Limit"] = config.pageSize;
          if (config.client instanceof CognitoIdentityProviderClient) {
            page = await ListGroupsPaginator_makePagedClientRequest(config.client, input, ...additionalArguments);
          } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
          }
          yield page;
          const prevToken = token;
          token = page.NextToken;
          hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
      }
      ;
      const ListIdentityProvidersPaginator_makePagedClientRequest = async (client, input, ...args) => {
        return await client.send(new ListIdentityProvidersCommand(input), ...args);
      };
      async function* paginateListIdentityProviders(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
          input.NextToken = token;
          input["MaxResults"] = config.pageSize;
          if (config.client instanceof CognitoIdentityProviderClient) {
            page = await ListIdentityProvidersPaginator_makePagedClientRequest(config.client, input, ...additionalArguments);
          } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
          }
          yield page;
          const prevToken = token;
          token = page.NextToken;
          hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
      }
      ;
      const ListResourceServersPaginator_makePagedClientRequest = async (client, input, ...args) => {
        return await client.send(new ListResourceServersCommand(input), ...args);
      };
      async function* paginateListResourceServers(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
          input.NextToken = token;
          input["MaxResults"] = config.pageSize;
          if (config.client instanceof CognitoIdentityProviderClient) {
            page = await ListResourceServersPaginator_makePagedClientRequest(config.client, input, ...additionalArguments);
          } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
          }
          yield page;
          const prevToken = token;
          token = page.NextToken;
          hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
      }
      ;
      const ListUserPoolClientsPaginator_makePagedClientRequest = async (client, input, ...args) => {
        return await client.send(new ListUserPoolClientsCommand(input), ...args);
      };
      async function* paginateListUserPoolClients(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
          input.NextToken = token;
          input["MaxResults"] = config.pageSize;
          if (config.client instanceof CognitoIdentityProviderClient) {
            page = await ListUserPoolClientsPaginator_makePagedClientRequest(config.client, input, ...additionalArguments);
          } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
          }
          yield page;
          const prevToken = token;
          token = page.NextToken;
          hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
      }
      ;
      const ListUserPoolsPaginator_makePagedClientRequest = async (client, input, ...args) => {
        return await client.send(new ListUserPoolsCommand(input), ...args);
      };
      async function* paginateListUserPools(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
          input.NextToken = token;
          input["MaxResults"] = config.pageSize;
          if (config.client instanceof CognitoIdentityProviderClient) {
            page = await ListUserPoolsPaginator_makePagedClientRequest(config.client, input, ...additionalArguments);
          } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
          }
          yield page;
          const prevToken = token;
          token = page.NextToken;
          hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
      }
      ;
      const ListUsersInGroupPaginator_makePagedClientRequest = async (client, input, ...args) => {
        return await client.send(new ListUsersInGroupCommand(input), ...args);
      };
      async function* paginateListUsersInGroup(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
          input.NextToken = token;
          input["Limit"] = config.pageSize;
          if (config.client instanceof CognitoIdentityProviderClient) {
            page = await ListUsersInGroupPaginator_makePagedClientRequest(config.client, input, ...additionalArguments);
          } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
          }
          yield page;
          const prevToken = token;
          token = page.NextToken;
          hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
      }
      ;
      const ListUsersPaginator_makePagedClientRequest = async (client, input, ...args) => {
        return await client.send(new ListUsersCommand(input), ...args);
      };
      async function* paginateListUsers(config, input, ...additionalArguments) {
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
          input.PaginationToken = token;
          input["Limit"] = config.pageSize;
          if (config.client instanceof CognitoIdentityProviderClient) {
            page = await ListUsersPaginator_makePagedClientRequest(config.client, input, ...additionalArguments);
          } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
          }
          yield page;
          const prevToken = token;
          token = page.PaginationToken;
          hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
      }
      ;
      ;
      ;
    },
    8281: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        locateWindow: () => locateWindow
      });
      const fallbackWindow = {};
      function locateWindow() {
        if (typeof window !== "undefined") {
          return window;
        } else if (typeof self !== "undefined") {
          return self;
        }
        return fallbackWindow;
      }
    },
    6778: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        fromUtf8: () => dist_es_fromUtf8,
        toUtf8: () => dist_es_toUtf8
      });
      ;
      const fromUtf8 = input => {
        const bytes = [];
        for (let i = 0, len = input.length; i < len; i++) {
          const value = input.charCodeAt(i);
          if (value < 0x80) {
            bytes.push(value);
          } else if (value < 0x800) {
            bytes.push(value >> 6 | 0b11000000, value & 0b111111 | 0b10000000);
          } else if (i + 1 < input.length && (value & 0xfc00) === 0xd800 && (input.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            const surrogatePair = 0x10000 + ((value & 0b1111111111) << 10) + (input.charCodeAt(++i) & 0b1111111111);
            bytes.push(surrogatePair >> 18 | 0b11110000, surrogatePair >> 12 & 0b111111 | 0b10000000, surrogatePair >> 6 & 0b111111 | 0b10000000, surrogatePair & 0b111111 | 0b10000000);
          } else {
            bytes.push(value >> 12 | 0b11100000, value >> 6 & 0b111111 | 0b10000000, value & 0b111111 | 0b10000000);
          }
        }
        return Uint8Array.from(bytes);
      };
      const toUtf8 = input => {
        let decoded = "";
        for (let i = 0, len = input.length; i < len; i++) {
          const byte = input[i];
          if (byte < 0x80) {
            decoded += String.fromCharCode(byte);
          } else if (0b11000000 <= byte && byte < 0b11100000) {
            const nextByte = input[++i];
            decoded += String.fromCharCode((byte & 0b11111) << 6 | nextByte & 0b111111);
          } else if (0b11110000 <= byte && byte < 0b101101101) {
            const surrogatePair = [byte, input[++i], input[++i], input[++i]];
            const encoded = "%" + surrogatePair.map(byteValue => byteValue.toString(16)).join("%");
            decoded += decodeURIComponent(encoded);
          } else {
            decoded += String.fromCharCode((byte & 0b1111) << 12 | (input[++i] & 0b111111) << 6 | input[++i] & 0b111111);
          }
        }
        return decoded;
      };
      ;
      function whatwgEncodingApi_fromUtf8(input) {
        return new TextEncoder().encode(input);
      }
      function whatwgEncodingApi_toUtf8(input) {
        return new TextDecoder("utf-8").decode(input);
      }
      ;
      const dist_es_fromUtf8 = input => typeof TextEncoder === "function" ? whatwgEncodingApi_fromUtf8(input) : fromUtf8(input);
      const dist_es_toUtf8 = input => typeof TextDecoder === "function" ? whatwgEncodingApi_toUtf8(input) : toUtf8(input);
    },
    1279: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            }
          };
        }
        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });
      var __importStar = this && this.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.envs = void 0;
      const prodSpec = __importStar(__webpack_require__(1174));
      const gammaSpec = __importStar(__webpack_require__(2987));
      const betaSpec = __importStar(__webpack_require__(3817));
      exports.envs = {
        prod: prodSpec["Dev-CubeSignerStack"],
        gamma: gammaSpec["Dev-CubeSignerStack"],
        beta: betaSpec["Dev-CubeSignerStack"]
      };
    },
    717: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var Buffer = __webpack_require__(8834)["lW"];
      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _Signer_address, _Signer_key, _Signer_signerSession;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Signer = void 0;
      const ethers_1 = __webpack_require__(3589);
      class Signer extends ethers_1.ethers.AbstractSigner {
        constructor(address, signerSession, provider) {
          super(provider);
          _Signer_address.set(this, void 0);
          _Signer_key.set(this, void 0);
          _Signer_signerSession.set(this, void 0);
          __classPrivateFieldSet(this, _Signer_address, address, "f");
          __classPrivateFieldSet(this, _Signer_signerSession, signerSession, "f");
        }
        async getAddress() {
          return __classPrivateFieldGet(this, _Signer_address, "f");
        }
        connect(provider) {
          return new Signer(__classPrivateFieldGet(this, _Signer_address, "f"), __classPrivateFieldGet(this, _Signer_signerSession, "f"), provider);
        }
        async signTransaction(tx) {
          let chainId = tx.chainId;
          if (chainId === undefined) {
            const network = await this.provider?.getNetwork();
            chainId = network?.chainId?.toString() ?? "1";
          }
          const rpcTx = this.provider instanceof ethers_1.JsonRpcApiProvider ? this.provider.getRpcTransaction(tx) : ethers_1.JsonRpcApiProvider.prototype.getRpcTransaction.call(null, tx);
          rpcTx.type = (0, ethers_1.toBeHex)(tx.type ?? 0x02, 1);
          const req = {
            chain_id: Number(chainId),
            tx: rpcTx
          };
          const sig = await __classPrivateFieldGet(this, _Signer_signerSession, "f").signEvm(__classPrivateFieldGet(this, _Signer_address, "f"), req);
          return sig.data().rlp_signed_tx;
        }
        async signMessage(message) {
          const digest = ethers_1.ethers.hashMessage(message);
          return this.signBlob(digest);
        }
        async signTypedData(domain, types, value) {
          const digest = ethers_1.TypedDataEncoder.hash(domain, types, value);
          return this.signBlob(digest);
        }
        async signBlob(digest) {
          const blobReq = {
            message_base64: Buffer.from((0, ethers_1.getBytes)(digest)).toString("base64")
          };
          if (__classPrivateFieldGet(this, _Signer_key, "f") === undefined) {
            const key = (await __classPrivateFieldGet(this, _Signer_signerSession, "f").keys()).find(k => k.materialId === __classPrivateFieldGet(this, _Signer_address, "f"));
            if (key === undefined) {
              throw new Error(`Cannot access key '${__classPrivateFieldGet(this, _Signer_address, "f")}'`);
            }
            __classPrivateFieldSet(this, _Signer_key, key, "f");
          }
          const result = await __classPrivateFieldGet(this, _Signer_signerSession, "f").signBlob(__classPrivateFieldGet(this, _Signer_key, "f"), blobReq);
          return result.data().signature;
        }
      }
      exports.Signer = Signer;
      _Signer_address = new WeakMap(), _Signer_key = new WeakMap(), _Signer_signerSession = new WeakMap();
    },
    4102: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            }
          };
        }
        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });
      var __importStar = this && this.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = this && this.__exportStar || function (m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      };
      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var _CubeSigner_env;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ethers = exports.CubeSigner = void 0;
      const env_1 = __webpack_require__(1279);
      const org_1 = __webpack_require__(2650);
      const session_storage_1 = __webpack_require__(3857);
      const signer_session_1 = __webpack_require__(7794);
      const management_session_manager_1 = __webpack_require__(1705);
      const oidc_session_manager_1 = __webpack_require__(8836);
      const util_1 = __webpack_require__(6926);
      const path = __importStar(__webpack_require__(1023));
      class CubeSigner {
        get env() {
          return __classPrivateFieldGet(this, _CubeSigner_env, "f");
        }
        static async loadManagementSession(storage) {
          const defaultFilePath = path.join((0, util_1.configDir)(), "management-session.json");
          const sessionMgr = await management_session_manager_1.ManagementSessionManager.loadFromStorage(storage ?? new session_storage_1.JsonFileSessionStorage(defaultFilePath));
          return new CubeSigner({
            sessionMgr
          });
        }
        static async loadSignerSession(storage) {
          const defaultFilePath = path.join((0, util_1.configDir)(), "signer-session.json");
          const sss = storage ?? new session_storage_1.JsonFileSessionStorage(defaultFilePath);
          const env = (await sss.retrieve()).env["Dev-CubeSignerStack"];
          return await signer_session_1.SignerSession.loadSignerSession(new CubeSigner({
            env
          }), sss);
        }
        static async loadOidcSession(storage) {
          const env = (await storage.retrieve()).env;
          return await signer_session_1.SignerSession.loadOidcSession(new CubeSigner({
            env
          }), storage);
        }
        constructor(options) {
          _CubeSigner_env.set(this, void 0);
          let env = options.env;
          if (options.sessionMgr) {
            this.sessionMgr = options.sessionMgr;
            env = env ?? this.sessionMgr.env;
          }
          __classPrivateFieldSet(this, _CubeSigner_env, env ?? env_1.envs["gamma"], "f");
        }
        async createOidcManager(oidcToken, orgId, scopes, storage) {
          return await oidc_session_manager_1.OidcSessionManager.create(this.env, storage || new session_storage_1.MemorySessionStorage(), oidcToken, orgId, scopes);
        }
        async createOidcSession(oidcToken, orgId, scopes, storage) {
          const mgr = await this.createOidcManager(oidcToken, orgId, scopes, storage);
          return await CubeSigner.loadOidcSession(mgr.storage);
        }
        async aboutMe() {
          const resp = await (await this.management()).get("/v0/about_me", {
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return data;
        }
        async resetTotp() {
          const resp = await (await this.management()).patch("/v0/totp", {
            parseAs: "json"
          });
          return (0, util_1.assertOk)(resp);
        }
        async verifyTotp(code) {
          const resp = await (await this.management()).get("/v0/totp/verify/{code}", {
            params: {
              path: {
                code
              }
            },
            parseAs: "json"
          });
          (0, util_1.assertOk)(resp);
        }
        async getOrg(orgId) {
          const resp = await (await this.management()).get("/v0/org/{org_id}", {
            params: {
              path: {
                org_id: orgId
              }
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return new org_1.Org(this, data);
        }
        async management() {
          if (!this.sessionMgr) {
            throw new Error("No management session loaded");
          }
          return await this.sessionMgr.client();
        }
      }
      exports.CubeSigner = CubeSigner;
      _CubeSigner_env = new WeakMap();
      __exportStar(__webpack_require__(2650), exports);
      __exportStar(__webpack_require__(6461), exports);
      __exportStar(__webpack_require__(9135), exports);
      __exportStar(__webpack_require__(1279), exports);
      __exportStar(__webpack_require__(7794), exports);
      __exportStar(__webpack_require__(3857), exports);
      __exportStar(__webpack_require__(6070), exports);
      __exportStar(__webpack_require__(1705), exports);
      __exportStar(__webpack_require__(8836), exports);
      __exportStar(__webpack_require__(9216), exports);
      exports.ethers = __importStar(__webpack_require__(717));
    },
    6461: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _Key_cs;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Key = exports.Ed25519 = exports.BLS = exports.Secp256k1 = void 0;
      const util_1 = __webpack_require__(6926);
      var Secp256k1;
      (function (Secp256k1) {
        Secp256k1["Evm"] = "SecpEthAddr";
        Secp256k1["Btc"] = "SecpBtc";
        Secp256k1["BtcTest"] = "SecpBtcTest";
      })(Secp256k1 || (exports.Secp256k1 = Secp256k1 = {}));
      var BLS;
      (function (BLS) {
        BLS["Eth2Deposited"] = "BlsPub";
        BLS["Eth2Inactive"] = "BlsInactive";
      })(BLS || (exports.BLS = BLS = {}));
      var Ed25519;
      (function (Ed25519) {
        Ed25519["Solana"] = "Ed25519SolanaAddr";
        Ed25519["Sui"] = "Ed25519SuiAddr";
        Ed25519["Aptos"] = "Ed25519AptosAddr";
      })(Ed25519 || (exports.Ed25519 = Ed25519 = {}));
      class Key {
        async enabled() {
          const data = await this.fetch();
          return data.enabled;
        }
        async enable() {
          await this.update({
            enabled: true
          });
        }
        async disable() {
          await this.update({
            enabled: false
          });
        }
        async setPolicy(policy) {
          await this.update({
            policy: policy
          });
        }
        async appendPolicy(policy) {
          const existing = await this.policy();
          await this.setPolicy([...existing, ...policy]);
        }
        async policy() {
          const data = await this.fetch();
          return data.policy ?? [];
        }
        async owner() {
          const data = await this.fetch();
          return data.owner;
        }
        async setOwner(owner) {
          await this.update({
            owner
          });
        }
        constructor(cs, orgId, data) {
          _Key_cs.set(this, void 0);
          __classPrivateFieldSet(this, _Key_cs, cs, "f");
          this.orgId = orgId;
          this.id = data.key_id;
          this.type = fromSchemaKeyType(data.key_type);
          this.materialId = data.material_id;
          this.publicKey = data.public_key;
        }
        async update(request) {
          const resp = await (await __classPrivateFieldGet(this, _Key_cs, "f").management()).patch("/v0/org/{org_id}/keys/{key_id}", {
            params: {
              path: {
                org_id: this.orgId,
                key_id: this.id
              }
            },
            body: request,
            parseAs: "json"
          });
          return (0, util_1.assertOk)(resp);
        }
        static async createKeys(cs, orgId, keyType, count, ownerId) {
          const chain_id = 0;
          const resp = await (await cs.management()).post("/v0/org/{org_id}/keys", {
            params: {
              path: {
                org_id: orgId
              }
            },
            body: {
              count,
              chain_id,
              key_type: keyType,
              owner: ownerId || null
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return data.keys.map(k => new Key(cs, orgId, k));
        }
        static async getKey(cs, orgId, keyId) {
          const resp = await (await cs.management()).get("/v0/org/{org_id}/keys/{key_id}", {
            params: {
              path: {
                org_id: orgId,
                key_id: keyId
              }
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return new Key(cs, orgId, data);
        }
        async fetch() {
          const resp = await (await __classPrivateFieldGet(this, _Key_cs, "f").management()).get("/v0/org/{org_id}/keys/{key_id}", {
            params: {
              path: {
                org_id: this.orgId,
                key_id: this.id
              }
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return data;
        }
      }
      exports.Key = Key;
      _Key_cs = new WeakMap();
      function fromSchemaKeyType(ty) {
        switch (ty) {
          case "SecpEthAddr":
            return Secp256k1.Evm;
          case "SecpBtc":
            return Secp256k1.Btc;
          case "SecpBtcTest":
            return Secp256k1.BtcTest;
          case "BlsPub":
            return BLS.Eth2Deposited;
          case "BlsInactive":
            return BLS.Eth2Inactive;
          case "Ed25519SolanaAddr":
            return Ed25519.Solana;
          case "Ed25519SuiAddr":
            return Ed25519.Sui;
          case "Ed25519AptosAddr":
            return Ed25519.Aptos;
          default:
            throw new Error(`Unknown key type: ${ty}`);
        }
      }
    },
    2650: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var _Org_cs, _Org_id;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Org = void 0;
      const util_1 = __webpack_require__(6926);
      const key_1 = __webpack_require__(6461);
      const role_1 = __webpack_require__(9135);
      class Org {
        get id() {
          return __classPrivateFieldGet(this, _Org_id, "f");
        }
        async name() {
          const data = await this.fetch();
          return data.name ?? undefined;
        }
        async setName(name) {
          if (!/^[a-zA-Z0-9_]{3,30}$/.test(name)) {
            throw new Error("Org name must be alphanumeric and between 3 and 30 characters");
          }
          await this.update({
            name
          });
        }
        async enabled() {
          const data = await this.fetch();
          return data.enabled;
        }
        async enable() {
          await this.update({
            enabled: true
          });
        }
        async disable() {
          await this.update({
            enabled: false
          });
        }
        async policy() {
          const data = await this.fetch();
          return data.policy ?? [];
        }
        async setPolicy(policy) {
          const p = policy;
          await this.update({
            policy: p
          });
        }
        async createKey(type, ownerId) {
          return (await key_1.Key.createKeys(__classPrivateFieldGet(this, _Org_cs, "f"), this.id, type, 1, ownerId))[0];
        }
        async createKeys(type, count, ownerId) {
          return key_1.Key.createKeys(__classPrivateFieldGet(this, _Org_cs, "f"), this.id, type, count, ownerId);
        }
        async createUser(email, name) {
          const resp = await (await __classPrivateFieldGet(this, _Org_cs, "f").management()).post("/v0/org/{org_id}/invite", {
            params: {
              path: {
                org_id: this.id
              }
            },
            body: {
              email,
              name,
              skip_email: false
            },
            parseAs: "json"
          });
          (0, util_1.assertOk)(resp);
        }
        async createOidcUser(identity, memberRole) {
          const resp = await (await __classPrivateFieldGet(this, _Org_cs, "f").management()).post("/v0/org/{org_id}/users", {
            params: {
              path: {
                org_id: this.id
              }
            },
            body: {
              identity,
              role: memberRole
            },
            parseAs: "json"
          });
          return (0, util_1.assertOk)(resp).user_id;
        }
        async users() {
          const resp = await (await __classPrivateFieldGet(this, _Org_cs, "f").management()).get("/v0/org/{org_id}/users", {
            params: {
              path: {
                org_id: this.id
              }
            },
            parseAs: "json"
          });
          return (0, util_1.assertOk)(resp).users;
        }
        async getKey(keyId) {
          return await key_1.Key.getKey(__classPrivateFieldGet(this, _Org_cs, "f"), this.id, keyId);
        }
        async keys(type) {
          const resp = await (await __classPrivateFieldGet(this, _Org_cs, "f").management()).get("/v0/org/{org_id}/keys", {
            params: {
              path: {
                org_id: this.id
              },
              query: type ? {
                key_type: type
              } : undefined
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return data.keys.map(k => new key_1.Key(__classPrivateFieldGet(this, _Org_cs, "f"), this.id, k));
        }
        async createRole(name) {
          return role_1.Role.createRole(__classPrivateFieldGet(this, _Org_cs, "f"), this.id, name);
        }
        async getRole(roleId) {
          return role_1.Role.getRole(__classPrivateFieldGet(this, _Org_cs, "f"), this.id, roleId);
        }
        async list() {
          return Org.roles(__classPrivateFieldGet(this, _Org_cs, "f"), this.id);
        }
        async mfaGet(mfaId) {
          const resp = await (await __classPrivateFieldGet(this, _Org_cs, "f").management()).get("/v0/org/{org_id}/mfa/{mfa_id}", {
            params: {
              path: {
                org_id: __classPrivateFieldGet(this, _Org_id, "f"),
                mfa_id: mfaId
              }
            }
          });
          return (0, util_1.assertOk)(resp);
        }
        async mfaApprove(mfaId) {
          return Org.mfaApprove(__classPrivateFieldGet(this, _Org_cs, "f"), __classPrivateFieldGet(this, _Org_id, "f"), mfaId);
        }
        constructor(cs, data) {
          _Org_cs.set(this, void 0);
          _Org_id.set(this, void 0);
          __classPrivateFieldSet(this, _Org_cs, cs, "f");
          __classPrivateFieldSet(this, _Org_id, data.org_id, "f");
        }
        static async mfaApprove(cs, orgId, mfaId) {
          const resp = await (await cs.management()).patch("/v0/org/{org_id}/mfa/{mfa_id}", {
            params: {
              path: {
                org_id: orgId,
                mfa_id: mfaId
              }
            }
          });
          return (0, util_1.assertOk)(resp);
        }
        async fetch() {
          const resp = await (await __classPrivateFieldGet(this, _Org_cs, "f").management()).get("/v0/org/{org_id}", {
            params: {
              path: {
                org_id: this.id
              }
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return data;
        }
        async update(request) {
          const resp = await (await __classPrivateFieldGet(this, _Org_cs, "f").management()).patch("/v0/org/{org_id}", {
            params: {
              path: {
                org_id: this.id
              }
            },
            body: request,
            parseAs: "json"
          });
          return (0, util_1.assertOk)(resp);
        }
        static async roles(cs, orgId) {
          const resp = await (await cs.management()).get("/v0/org/{org_id}/roles", {
            params: {
              path: {
                org_id: orgId
              }
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return data.roles.map(r => new role_1.Role(cs, orgId, r));
        }
      }
      exports.Org = Org;
      _Org_cs = new WeakMap(), _Org_id = new WeakMap();
    },
    9135: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var _KeyWithPolicies_cs, _KeyWithPolicies_orgId, _Role_cs, _Role_orgId;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Role = exports.KeyWithPolicies = exports.OperationKind = exports.DepositContract = void 0;
      const _1 = __webpack_require__(4102);
      const util_1 = __webpack_require__(6926);
      var DepositContract;
      (function (DepositContract) {
        DepositContract[DepositContract["Canonical"] = 0] = "Canonical";
        DepositContract[DepositContract["Wrapper"] = 1] = "Wrapper";
      })(DepositContract || (exports.DepositContract = DepositContract = {}));
      var OperationKind;
      (function (OperationKind) {
        OperationKind["BlobSign"] = "BlobSign";
        OperationKind["EvmSign"] = "Eth1Sign";
        OperationKind["Eth2Sign"] = "Eth2Sign";
        OperationKind["Eth2Stake"] = "Eth2Stake";
        OperationKind["Eth2Unstake"] = "Eth2Unstake";
        OperationKind["SolanaSign"] = "SolanaSign";
      })(OperationKind || (exports.OperationKind = OperationKind = {}));
      class KeyWithPolicies {
        async getKey() {
          return await _1.Key.getKey(__classPrivateFieldGet(this, _KeyWithPolicies_cs, "f"), __classPrivateFieldGet(this, _KeyWithPolicies_orgId, "f"), this.keyId);
        }
        constructor(cs, orgId, keyWithPolicies) {
          _KeyWithPolicies_cs.set(this, void 0);
          _KeyWithPolicies_orgId.set(this, void 0);
          __classPrivateFieldSet(this, _KeyWithPolicies_cs, cs, "f");
          __classPrivateFieldSet(this, _KeyWithPolicies_orgId, orgId, "f");
          this.keyId = keyWithPolicies.key_id;
          this.policy = keyWithPolicies.policy;
        }
      }
      exports.KeyWithPolicies = KeyWithPolicies;
      _KeyWithPolicies_cs = new WeakMap(), _KeyWithPolicies_orgId = new WeakMap();
      class Role {
        async delete() {
          await Role.deleteRole(__classPrivateFieldGet(this, _Role_cs, "f"), __classPrivateFieldGet(this, _Role_orgId, "f"), this.id);
        }
        async enabled() {
          const data = await this.fetch();
          return data.enabled;
        }
        async enable() {
          await this.update({
            enabled: true
          });
        }
        async disable() {
          await this.update({
            enabled: false
          });
        }
        async users() {
          const data = await this.fetch();
          return data.users;
        }
        async addUser(userId) {
          const resp = await (await __classPrivateFieldGet(this, _Role_cs, "f").management()).put("/v0/org/{org_id}/roles/{role_id}/add_user/{user_id}", {
            params: {
              path: {
                org_id: __classPrivateFieldGet(this, _Role_orgId, "f"),
                role_id: this.id,
                user_id: userId
              }
            },
            parseAs: "json"
          });
          (0, util_1.assertOk)(resp, "Failed to add user to role");
        }
        async keys() {
          const data = await this.fetch();
          return data.keys.map(k => new KeyWithPolicies(__classPrivateFieldGet(this, _Role_cs, "f"), __classPrivateFieldGet(this, _Role_orgId, "f"), k));
        }
        async addKeys(keys, policy) {
          const resp = await (await __classPrivateFieldGet(this, _Role_cs, "f").management()).put("/v0/org/{org_id}/roles/{role_id}/add_keys", {
            params: {
              path: {
                org_id: __classPrivateFieldGet(this, _Role_orgId, "f"),
                role_id: this.id
              }
            },
            body: {
              key_ids: keys.map(k => k.id),
              policy: policy ?? null
            },
            parseAs: "json"
          });
          (0, util_1.assertOk)(resp, "Failed to add keys to role");
        }
        async addKey(key, policy) {
          return await this.addKeys([key], policy);
        }
        async removeKey(key) {
          const resp = await (await __classPrivateFieldGet(this, _Role_cs, "f").management()).del("/v0/org/{org_id}/roles/{role_id}/keys/{key_id}", {
            params: {
              path: {
                org_id: __classPrivateFieldGet(this, _Role_orgId, "f"),
                role_id: this.id,
                key_id: key.id
              }
            },
            parseAs: "json"
          });
          (0, util_1.assertOk)(resp, "Failed to remove key from role");
        }
        async createSession(storage, purpose, ttl) {
          const manager = await _1.SignerSessionManager.create(__classPrivateFieldGet(this, _Role_cs, "f"), storage, __classPrivateFieldGet(this, _Role_orgId, "f"), this.id, purpose, ttl);
          return new _1.SignerSession(__classPrivateFieldGet(this, _Role_cs, "f"), manager);
        }
        async sessions() {
          const resp = await (await __classPrivateFieldGet(this, _Role_cs, "f").management()).get("/v0/org/{org_id}/roles/{role_id}/tokens", {
            params: {
              path: {
                org_id: __classPrivateFieldGet(this, _Role_orgId, "f"),
                role_id: this.id
              }
            }
          });
          const data = (0, util_1.assertOk)(resp);
          return data.tokens.map(t => new _1.SignerSessionInfo(__classPrivateFieldGet(this, _Role_cs, "f"), __classPrivateFieldGet(this, _Role_orgId, "f"), this.id, t.hash, t.purpose));
        }
        constructor(cs, orgId, data) {
          _Role_cs.set(this, void 0);
          _Role_orgId.set(this, void 0);
          __classPrivateFieldSet(this, _Role_cs, cs, "f");
          __classPrivateFieldSet(this, _Role_orgId, orgId, "f");
          this.id = data.role_id;
          this.name = data.name ?? undefined;
        }
        async update(request) {
          const resp = await (await __classPrivateFieldGet(this, _Role_cs, "f").management()).patch("/v0/org/{org_id}/roles/{role_id}", {
            params: {
              path: {
                org_id: __classPrivateFieldGet(this, _Role_orgId, "f"),
                role_id: this.id
              }
            },
            body: request,
            parseAs: "json"
          });
          (0, util_1.assertOk)(resp);
        }
        static async createRole(cs, orgId, name) {
          const resp = await (await cs.management()).post("/v0/org/{org_id}/roles", {
            params: {
              path: {
                org_id: orgId
              }
            },
            body: name ? {
              name
            } : undefined,
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return await Role.getRole(cs, orgId, data.role_id);
        }
        static async getRole(cs, orgId, roleId) {
          const resp = await (await cs.management()).get("/v0/org/{org_id}/roles/{role_id}", {
            params: {
              path: {
                org_id: orgId,
                role_id: roleId
              }
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return new Role(cs, orgId, data);
        }
        async fetch() {
          const resp = await (await __classPrivateFieldGet(this, _Role_cs, "f").management()).get("/v0/org/{org_id}/roles/{role_id}", {
            params: {
              path: {
                org_id: __classPrivateFieldGet(this, _Role_orgId, "f"),
                role_id: this.id
              }
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return data;
        }
        static async deleteRole(cs, orgId, roleId) {
          const resp = await (await cs.management()).del("/v0/org/{org_id}/roles/{role_id}", {
            params: {
              path: {
                org_id: orgId,
                role_id: roleId
              }
            },
            parseAs: "json"
          });
          (0, util_1.assertOk)(resp);
        }
      }
      exports.Role = Role;
      _Role_cs = new WeakMap(), _Role_orgId = new WeakMap();
    },
    1705: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var _ManagementSessionManager_client;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ManagementSessionManager = void 0;
      const session_manager_1 = __webpack_require__(6070);
      class ManagementSessionManager extends session_manager_1.SessionManager {
        async token() {
          const session = await this.storage.retrieve();
          return session.id_token;
        }
        async client() {
          this.refreshIfNeeded();
          return __classPrivateFieldGet(this, _ManagementSessionManager_client, "f");
        }
        async revoke() {
          const idp = __webpack_require__(3123);
          const session = await this.storage.retrieve();
          const client = new idp.CognitoIdentityProviderClient({
            region: this.env.Region,
            signer: {
              sign: async request => request
            }
          });
          const input = {
            Token: session.refresh_token,
            ClientId: this.env.ClientId
          };
          await client.send(new idp.RevokeTokenCommand(input));
        }
        async isStale() {
          const session = await this.storage.retrieve();
          return this.hasExpired(new Date(session.expiration).getTime());
        }
        async refresh() {
          const idp = __webpack_require__(3123);
          const session = await this.storage.retrieve();
          const client = new idp.CognitoIdentityProviderClient({
            region: this.env.Region
          });
          const resp = await client.send(new idp.InitiateAuthCommand({
            AuthFlow: "REFRESH_TOKEN_AUTH",
            AuthParameters: {
              REFRESH_TOKEN: session.refresh_token
            },
            ClientId: this.env.ClientId
          }));
          if (!resp.AuthenticationResult || !resp.AuthenticationResult.ExpiresIn || !resp.AuthenticationResult.IdToken) {
            throw new Error("Refresh failed");
          }
          const expiresInMs = resp.AuthenticationResult.ExpiresIn * 1000;
          const expiration = new Date(new Date().getTime() + expiresInMs).toISOString();
          const idToken = resp.AuthenticationResult.IdToken;
          await this.storage.save({
            ...session,
            id_token: idToken,
            access_token: resp.AuthenticationResult.AccessToken,
            expiration
          });
          __classPrivateFieldSet(this, _ManagementSessionManager_client, this.createClient(idToken), "f");
        }
        static async loadFromStorage(storage) {
          const sessionInfo = await storage.retrieve();
          return new ManagementSessionManager(sessionInfo.env["Dev-CubeSignerStack"], sessionInfo.id_token, storage);
        }
        constructor(env, token, storage) {
          super(env, storage);
          _ManagementSessionManager_client.set(this, void 0);
          __classPrivateFieldSet(this, _ManagementSessionManager_client, this.createClient(token), "f");
        }
      }
      exports.ManagementSessionManager = ManagementSessionManager;
      _ManagementSessionManager_client = new WeakMap();
    },
    8836: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };
      var _a, _OidcSessionManager_client, _OidcSessionManager_exchangeToken;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OidcSessionManager = void 0;
      const util_1 = __webpack_require__(6926);
      const session_manager_1 = __webpack_require__(6070);
      const openapi_fetch_1 = __importDefault(__webpack_require__(192));
      const OIDC_TOKEN_EXP_SECS = 300;
      class OidcSessionManager extends session_manager_1.OrgSessionManager {
        async token() {
          const session = await this.storage.retrieve();
          return session.token;
        }
        async client() {
          await this.refreshIfNeeded();
          return __classPrivateFieldGet(this, _OidcSessionManager_client, "f");
        }
        async revoke() {
          this.unsupported("revoke");
        }
        async refresh() {
          const session = await this.storage.retrieve();
          const [token, tokenExp] = await __classPrivateFieldGet(OidcSessionManager, _a, "m", _OidcSessionManager_exchangeToken).call(OidcSessionManager, session.env, session.oidc_token, session.org_id, session.scopes);
          await this.storage.save({
            ...session,
            token: token,
            token_exp: tokenExp
          });
          __classPrivateFieldSet(this, _OidcSessionManager_client, this.createClient(token), "f");
        }
        async isStale() {
          const session = await this.storage.retrieve();
          return this.hasExpired(session.token_exp);
        }
        async refreshIfNeeded() {
          if (await this.isStale()) {
            await this.refresh();
            return true;
          }
          return false;
        }
        static async create(env, storage, oidcToken, orgId, scopes) {
          const [token, tokenExp] = await __classPrivateFieldGet(OidcSessionManager, _a, "m", _OidcSessionManager_exchangeToken).call(OidcSessionManager, env, oidcToken, orgId, scopes);
          await storage.save({
            env,
            org_id: orgId,
            oidc_token: oidcToken,
            token,
            token_exp: tokenExp,
            scopes
          });
          return new OidcSessionManager(env, orgId, token, storage);
        }
        static async loadFromStorage(storage) {
          const info = await storage.retrieve();
          return new OidcSessionManager(info.env, info.org_id, info.token, storage);
        }
        constructor(env, orgId, token, storage) {
          super(env, orgId, storage);
          _OidcSessionManager_client.set(this, void 0);
          __classPrivateFieldSet(this, _OidcSessionManager_client, this.createClient(token), "f");
        }
      }
      exports.OidcSessionManager = OidcSessionManager;
      _a = OidcSessionManager, _OidcSessionManager_client = new WeakMap(), _OidcSessionManager_exchangeToken = async function _OidcSessionManager_exchangeToken(env, oidcToken, orgId, scopes) {
        const client = (0, openapi_fetch_1.default)({
          baseUrl: env.SignerApiRoot,
          headers: {
            Authorization: oidcToken
          }
        });
        const resp = await client.post("/v0/org/{org_id}/oidc", {
          params: {
            path: {
              org_id: orgId
            }
          },
          body: {
            scopes
          },
          parseAs: "json"
        });
        const data = (0, util_1.assertOk)(resp);
        return [data.token, new Date().getTime() / 1000 + OIDC_TOKEN_EXP_SECS];
      };
    },
    6070: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OrgSessionManager = exports.SessionManager = void 0;
      const openapi_fetch_1 = __importDefault(__webpack_require__(192));
      const DEFAULT_EXPIRATION_BUFFER_SECS = 30;
      class SessionManager {
        async refreshIfNeeded() {
          if (await this.isStale()) {
            await this.refresh();
            return true;
          }
          return false;
        }
        constructor(env, storage) {
          this.env = env;
          this.storage = storage;
        }
        createClient(token) {
          return (0, openapi_fetch_1.default)({
            baseUrl: this.env.SignerApiRoot,
            headers: {
              Authorization: token
            }
          });
        }
        hasExpired(exp, buffer) {
          return exp < new Date().getTime() / 1000 + (buffer || DEFAULT_EXPIRATION_BUFFER_SECS);
        }
        unsupported(name) {
          throw new Error(`'${name}' not supported`);
        }
      }
      exports.SessionManager = SessionManager;
      class OrgSessionManager extends SessionManager {
        constructor(env, orgId, storage) {
          super(env, storage);
          this.orgId = orgId;
        }
      }
      exports.OrgSessionManager = OrgSessionManager;
    },
    3857: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _MemorySessionStorage_data, _JsonFileSessionStorage_filePath;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.JsonFileSessionStorage = exports.MemorySessionStorage = void 0;
      const fs_1 = __webpack_require__(2466);
      class MemorySessionStorage {
        async save(data) {
          __classPrivateFieldSet(this, _MemorySessionStorage_data, data, "f");
        }
        async retrieve() {
          if (!__classPrivateFieldGet(this, _MemorySessionStorage_data, "f")) {
            throw new Error("Missing session information");
          }
          return __classPrivateFieldGet(this, _MemorySessionStorage_data, "f");
        }
        constructor(data) {
          _MemorySessionStorage_data.set(this, void 0);
          __classPrivateFieldSet(this, _MemorySessionStorage_data, data, "f");
        }
      }
      exports.MemorySessionStorage = MemorySessionStorage;
      _MemorySessionStorage_data = new WeakMap();
      class JsonFileSessionStorage {
        async save(data) {
          await fs_1.promises.writeFile(__classPrivateFieldGet(this, _JsonFileSessionStorage_filePath, "f"), JSON.stringify(data), "utf-8");
        }
        async retrieve() {
          return JSON.parse(await fs_1.promises.readFile(__classPrivateFieldGet(this, _JsonFileSessionStorage_filePath, "f"), "utf-8"));
        }
        constructor(filePath) {
          _JsonFileSessionStorage_filePath.set(this, void 0);
          __classPrivateFieldSet(this, _JsonFileSessionStorage_filePath, filePath, "f");
        }
      }
      exports.JsonFileSessionStorage = JsonFileSessionStorage;
      _JsonFileSessionStorage_filePath = new WeakMap();
    },
    9216: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var _SignerSessionManager_client;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SignerSessionManager = void 0;
      const util_1 = __webpack_require__(6926);
      const session_manager_1 = __webpack_require__(6070);
      const defaultSignerSessionLifetime = {
        session: 604800,
        auth: 300,
        refresh: 86400
      };
      class SignerSessionManager extends session_manager_1.OrgSessionManager {
        async token() {
          const session = await this.storage.retrieve();
          return session.token;
        }
        async client() {
          await this.refreshIfNeeded();
          return __classPrivateFieldGet(this, _SignerSessionManager_client, "f");
        }
        async revoke() {
          if (!this.cs) {
            throw new Error("No management session available");
          }
          const session = await this.storage.retrieve();
          const resp = await (await this.cs.management()).del("/v0/org/{org_id}/roles/{role_id}/tokens/{session_id}", {
            params: {
              path: {
                org_id: session.org_id,
                role_id: session.role_id,
                session_id: session.session_info.session_id
              }
            },
            parseAs: "json"
          });
          (0, util_1.assertOk)(resp);
        }
        async isStale() {
          const session = await this.storage.retrieve();
          return this.hasExpired(session.session_info.auth_token_exp);
        }
        async refresh() {
          const session = await this.storage.retrieve();
          const csi = session.session_info;
          const resp = await __classPrivateFieldGet(this, _SignerSessionManager_client, "f").patch("/v1/org/{org_id}/token/refresh", {
            params: {
              path: {
                org_id: session.org_id
              }
            },
            body: {
              epoch_num: csi.epoch,
              epoch_token: csi.epoch_token,
              other_token: csi.refresh_token
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          await this.storage.save({
            ...session,
            session_info: data.session_info,
            token: data.token
          });
          __classPrivateFieldSet(this, _SignerSessionManager_client, this.createClient(data.token), "f");
        }
        static async create(cs, storage, orgId, roleId, purpose, ttl) {
          const resp = await (await cs.management()).post("/v0/org/{org_id}/roles/{role_id}/tokens", {
            params: {
              path: {
                org_id: orgId,
                role_id: roleId
              }
            },
            body: {
              purpose,
              auth_lifetime: ttl?.auth || defaultSignerSessionLifetime.auth,
              refresh_lifetime: ttl?.refresh || defaultSignerSessionLifetime.refresh,
              session_lifetime: ttl?.session || defaultSignerSessionLifetime.session
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          const session_info = data.session_info;
          if (!session_info) {
            throw new Error("Signer session info missing");
          }
          await storage.save({
            org_id: orgId,
            role_id: roleId,
            purpose,
            token: data.token,
            session_info,
            env: {
              ["Dev-CubeSignerStack"]: cs.env
            }
          });
          return new SignerSessionManager(cs, orgId, roleId, data.token, storage);
        }
        static async loadFromStorage(cs, storage) {
          const session = await storage.retrieve();
          return new SignerSessionManager(cs, session.org_id, session.role_id, session.token, storage);
        }
        constructor(cs, orgId, roleId, token, storage) {
          super(cs.env, orgId, storage);
          _SignerSessionManager_client.set(this, void 0);
          this.cs = cs;
          this.roleId = roleId;
          __classPrivateFieldSet(this, _SignerSessionManager_client, this.createClient(token), "f");
        }
      }
      exports.SignerSessionManager = SignerSessionManager;
      _SignerSessionManager_client = new WeakMap();
    },
    7794: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };
      var _SignResponse_instances, _SignResponse_cs, _SignResponse_orgId, _SignResponse_signFn, _SignResponse_resp, _SignResponse_signWithMfaApproval, _SignResponse_mfaId, _SignerSessionInfo_cs, _SignerSessionInfo_orgId, _SignerSessionInfo_roleId, _SignerSessionInfo_sessionId, _SignerSession_orgId;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SignerSession = exports.SignerSessionInfo = exports.SignResponse = void 0;
      const assert_1 = __importDefault(__webpack_require__(1696));
      const _1 = __webpack_require__(4102);
      const util_1 = __webpack_require__(6926);
      const signer_session_manager_1 = __webpack_require__(9216);
      class SignResponse {
        requiresMfa() {
          return __classPrivateFieldGet(this, _SignResponse_resp, "f").accepted?.MfaRequired !== undefined;
        }
        data() {
          return __classPrivateFieldGet(this, _SignResponse_resp, "f");
        }
        async approveTotp(session, code) {
          const mfaId = __classPrivateFieldGet(this, _SignResponse_instances, "m", _SignResponse_mfaId).call(this);
          const mfaApproval = await session.totpApprove(mfaId, code);
          (0, assert_1.default)(mfaApproval.id === mfaId);
          const mfaConf = mfaApproval.receipt?.confirmation;
          if (!mfaConf) {
            throw new Error("MfaRequest has not been approved yet");
          }
          return await __classPrivateFieldGet(this, _SignResponse_instances, "m", _SignResponse_signWithMfaApproval).call(this, mfaConf);
        }
        async approve() {
          const mfaId = __classPrivateFieldGet(this, _SignResponse_instances, "m", _SignResponse_mfaId).call(this);
          const mfaApproval = await _1.Org.mfaApprove(__classPrivateFieldGet(this, _SignResponse_cs, "f"), __classPrivateFieldGet(this, _SignResponse_orgId, "f"), mfaId);
          (0, assert_1.default)(mfaApproval.id === mfaId);
          const mfaConf = mfaApproval.receipt?.confirmation;
          if (!mfaConf) {
            throw new Error("MfaRequest has not been approved yet");
          }
          return await __classPrivateFieldGet(this, _SignResponse_instances, "m", _SignResponse_signWithMfaApproval).call(this, mfaConf);
        }
        constructor(cs, orgId, signFn, resp) {
          _SignResponse_instances.add(this);
          _SignResponse_cs.set(this, void 0);
          _SignResponse_orgId.set(this, void 0);
          _SignResponse_signFn.set(this, void 0);
          _SignResponse_resp.set(this, void 0);
          __classPrivateFieldSet(this, _SignResponse_cs, cs, "f");
          __classPrivateFieldSet(this, _SignResponse_orgId, orgId, "f");
          __classPrivateFieldSet(this, _SignResponse_signFn, signFn, "f");
          __classPrivateFieldSet(this, _SignResponse_resp, resp, "f");
        }
      }
      exports.SignResponse = SignResponse;
      _SignResponse_cs = new WeakMap(), _SignResponse_orgId = new WeakMap(), _SignResponse_signFn = new WeakMap(), _SignResponse_resp = new WeakMap(), _SignResponse_instances = new WeakSet(), _SignResponse_signWithMfaApproval = async function _SignResponse_signWithMfaApproval(mfaConf) {
        const mfaId = __classPrivateFieldGet(this, _SignResponse_instances, "m", _SignResponse_mfaId).call(this);
        const headers = {
          "x-cubist-mfa-id": mfaId,
          "x-cubist-mfa-confirmation": mfaConf
        };
        return new SignResponse(__classPrivateFieldGet(this, _SignResponse_cs, "f"), __classPrivateFieldGet(this, _SignResponse_orgId, "f"), __classPrivateFieldGet(this, _SignResponse_signFn, "f"), await __classPrivateFieldGet(this, _SignResponse_signFn, "f").call(this, headers));
      }, _SignResponse_mfaId = function _SignResponse_mfaId() {
        const mfaRequired = __classPrivateFieldGet(this, _SignResponse_resp, "f").accepted?.MfaRequired;
        if (!mfaRequired) {
          throw new Error("Request does not require MFA approval");
        }
        return mfaRequired.id;
      };
      class SignerSessionInfo {
        async revoke() {
          await SignerSession.revoke(__classPrivateFieldGet(this, _SignerSessionInfo_cs, "f"), __classPrivateFieldGet(this, _SignerSessionInfo_orgId, "f"), __classPrivateFieldGet(this, _SignerSessionInfo_roleId, "f"), __classPrivateFieldGet(this, _SignerSessionInfo_sessionId, "f"));
        }
        constructor(cs, orgId, roleId, hash, purpose) {
          _SignerSessionInfo_cs.set(this, void 0);
          _SignerSessionInfo_orgId.set(this, void 0);
          _SignerSessionInfo_roleId.set(this, void 0);
          _SignerSessionInfo_sessionId.set(this, void 0);
          __classPrivateFieldSet(this, _SignerSessionInfo_cs, cs, "f");
          __classPrivateFieldSet(this, _SignerSessionInfo_orgId, orgId, "f");
          __classPrivateFieldSet(this, _SignerSessionInfo_roleId, roleId, "f");
          __classPrivateFieldSet(this, _SignerSessionInfo_sessionId, hash, "f");
          this.purpose = purpose;
        }
      }
      exports.SignerSessionInfo = SignerSessionInfo;
      _SignerSessionInfo_cs = new WeakMap(), _SignerSessionInfo_orgId = new WeakMap(), _SignerSessionInfo_roleId = new WeakMap(), _SignerSessionInfo_sessionId = new WeakMap();
      class SignerSession {
        async keys() {
          const resp = await (await this.sessionMgr.client()).get("/v0/org/{org_id}/token/keys", {
            params: {
              path: {
                org_id: __classPrivateFieldGet(this, _SignerSession_orgId, "f")
              }
            },
            parseAs: "json"
          });
          const data = (0, util_1.assertOk)(resp);
          return data.keys.map(k => new _1.Key(this.cs, __classPrivateFieldGet(this, _SignerSession_orgId, "f"), k));
        }
        async totpApprove(mfaId, code) {
          const resp = await (await this.sessionMgr.client()).patch("/v0/org/{org_id}/mfa/{mfa_id}/totp", {
            params: {
              path: {
                org_id: __classPrivateFieldGet(this, _SignerSession_orgId, "f"),
                mfa_id: mfaId
              }
            },
            body: {
              code
            },
            parseAs: "json"
          });
          return (0, util_1.assertOk)(resp);
        }
        async signEvm(key, req) {
          const pubkey = typeof key === "string" ? key : key.materialId;
          const sign = async headers => {
            const resp = await (await this.sessionMgr.client()).post("/v1/org/{org_id}/eth1/sign/{pubkey}", {
              params: {
                path: {
                  org_id: __classPrivateFieldGet(this, _SignerSession_orgId, "f"),
                  pubkey
                }
              },
              body: req,
              headers,
              parseAs: "json"
            });
            return (0, util_1.assertOk)(resp);
          };
          return new SignResponse(this.cs, __classPrivateFieldGet(this, _SignerSession_orgId, "f"), sign, await sign());
        }
        async signEth2(key, req) {
          const pubkey = typeof key === "string" ? key : key.materialId;
          const sign = async headers => {
            const resp = await (await this.sessionMgr.client()).post("/v1/org/{org_id}/eth2/sign/{pubkey}", {
              params: {
                path: {
                  org_id: __classPrivateFieldGet(this, _SignerSession_orgId, "f"),
                  pubkey
                }
              },
              body: req,
              headers,
              parseAs: "json"
            });
            return (0, util_1.assertOk)(resp);
          };
          return new SignResponse(this.cs, __classPrivateFieldGet(this, _SignerSession_orgId, "f"), sign, await sign());
        }
        async stake(req) {
          const sign = async headers => {
            const resp = await (await this.sessionMgr.client()).post("/v1/org/{org_id}/eth2/stake", {
              params: {
                path: {
                  org_id: __classPrivateFieldGet(this, _SignerSession_orgId, "f")
                }
              },
              body: req,
              headers,
              parseAs: "json"
            });
            return (0, util_1.assertOk)(resp);
          };
          return new SignResponse(this.cs, __classPrivateFieldGet(this, _SignerSession_orgId, "f"), sign, await sign());
        }
        async unstake(key, req) {
          const pubkey = typeof key === "string" ? key : key.materialId;
          const sign = async headers => {
            const resp = await (await this.sessionMgr.client()).post("/v1/org/{org_id}/eth2/unstake/{pubkey}", {
              params: {
                path: {
                  org_id: __classPrivateFieldGet(this, _SignerSession_orgId, "f"),
                  pubkey
                }
              },
              body: req,
              headers,
              parseAs: "json"
            });
            return (0, util_1.assertOk)(resp);
          };
          return new SignResponse(this.cs, __classPrivateFieldGet(this, _SignerSession_orgId, "f"), sign, await sign());
        }
        async signBlob(key, req) {
          const key_id = typeof key === "string" ? key : key.id;
          const sign = async headers => {
            const resp = await (await this.sessionMgr.client()).post("/v1/org/{org_id}/blob/sign/{key_id}", {
              params: {
                path: {
                  org_id: __classPrivateFieldGet(this, _SignerSession_orgId, "f"),
                  key_id
                }
              },
              body: req,
              headers,
              parseAs: "json"
            });
            return (0, util_1.assertOk)(resp);
          };
          return new SignResponse(this.cs, __classPrivateFieldGet(this, _SignerSession_orgId, "f"), sign, await sign());
        }
        async signBtc(key, req) {
          const pubkey = typeof key === "string" ? key : key.materialId;
          const sign = async headers => {
            const resp = await (await this.sessionMgr.client()).post("/v0/org/{org_id}/btc/sign/{pubkey}", {
              params: {
                path: {
                  org_id: __classPrivateFieldGet(this, _SignerSession_orgId, "f"),
                  pubkey
                }
              },
              body: req,
              headers: headers,
              parseAs: "json"
            });
            return (0, util_1.assertOk)(resp);
          };
          return new SignResponse(this.cs, __classPrivateFieldGet(this, _SignerSession_orgId, "f"), sign, await sign());
        }
        async signSolana(key, req) {
          const pubkey = typeof key === "string" ? key : key.materialId;
          const sign = async headers => {
            const resp = await (await this.sessionMgr.client()).post("/v1/org/{org_id}/solana/sign/{pubkey}", {
              params: {
                path: {
                  org_id: __classPrivateFieldGet(this, _SignerSession_orgId, "f"),
                  pubkey
                }
              },
              body: req,
              headers,
              parseAs: "json"
            });
            return (0, util_1.assertOk)(resp);
          };
          return new SignResponse(this.cs, __classPrivateFieldGet(this, _SignerSession_orgId, "f"), sign, await sign());
        }
        static async loadSignerSession(cs, storage) {
          const manager = await signer_session_manager_1.SignerSessionManager.loadFromStorage(cs, storage);
          return new SignerSession(cs, manager);
        }
        static async loadOidcSession(cs, storage) {
          const manager = await _1.OidcSessionManager.loadFromStorage(storage);
          return new SignerSession(cs, manager);
        }
        constructor(cs, sessionMgr) {
          _SignerSession_orgId.set(this, void 0);
          this.cs = cs;
          this.sessionMgr = sessionMgr;
          __classPrivateFieldSet(this, _SignerSession_orgId, sessionMgr.orgId, "f");
        }
        static async revoke(cs, orgId, roleId, sessionId) {
          const resp = await (await cs.management()).del("/v0/org/{org_id}/roles/{role_id}/tokens/{session_id}", {
            params: {
              path: {
                org_id: orgId,
                role_id: roleId,
                session_id: sessionId
              }
            },
            parseAs: "json"
          });
          (0, util_1.assertOk)(resp);
        }
      }
      exports.SignerSession = SignerSession;
      _SignerSession_orgId = new WeakMap();
    },
    6926: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            }
          };
        }
        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });
      var __importStar = this && this.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertOk = exports.ErrResponse = exports.configDir = void 0;
      const path = __importStar(__webpack_require__(1023));
      function configDir() {
        const configDir = {
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        }.platform === "darwin" ? `${{
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        }.env.HOME}/Library/Application Support` : `${{
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        }.env.HOME}/.config`;
        return path.join(configDir, "cubesigner");
      }
      exports.configDir = configDir;
      class ErrResponse extends Error {
        constructor(init) {
          super(init.message);
          Object.assign(this, init);
        }
      }
      exports.ErrResponse = ErrResponse;
      function assertOk(resp, description) {
        if (resp.error) {
          throw new ErrResponse({
            description,
            message: resp.error.message,
            statusText: resp.response?.statusText,
            status: resp.response?.status
          });
        }
        if (resp.data === undefined) {
          throw new Error("Response data is undefined");
        }
        return resp.data;
      }
      exports.assertOk = assertOk;
    },
    8856: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.EthereumProviderError = exports.JsonRpcError = void 0;
      const utils_1 = __webpack_require__(5554);
      const fast_safe_stringify_1 = __importDefault(__webpack_require__(6920));
      const utils_2 = __webpack_require__(7962);
      class JsonRpcError extends Error {
        constructor(code, message, data) {
          if (!Number.isInteger(code)) {
            throw new Error('"code" must be an integer.');
          }
          if (!message || typeof message !== 'string') {
            throw new Error('"message" must be a non-empty string.');
          }
          super(message);
          this.code = code;
          if (data !== undefined) {
            this.data = data;
          }
        }
        serialize() {
          const serialized = {
            code: this.code,
            message: this.message
          };
          if (this.data !== undefined) {
            serialized.data = this.data;
            if ((0, utils_1.isPlainObject)(this.data)) {
              serialized.data.cause = (0, utils_2.serializeCause)(this.data.cause);
            }
          }
          if (this.stack) {
            serialized.stack = this.stack;
          }
          return serialized;
        }
        toString() {
          return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);
        }
      }
      exports.JsonRpcError = JsonRpcError;
      class EthereumProviderError extends JsonRpcError {
        constructor(code, message, data) {
          if (!isValidEthProviderCode(code)) {
            throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
          }
          super(code, message, data);
        }
      }
      exports.EthereumProviderError = EthereumProviderError;
      function isValidEthProviderCode(code) {
        return Number.isInteger(code) && code >= 1000 && code <= 4999;
      }
      function stringifyReplacer(_, value) {
        if (value === '[Circular]') {
          return undefined;
        }
        return value;
      }
    },
    5191: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.errorValues = exports.errorCodes = void 0;
      exports.errorCodes = {
        rpc: {
          invalidInput: -32000,
          resourceNotFound: -32001,
          resourceUnavailable: -32002,
          transactionRejected: -32003,
          methodNotSupported: -32004,
          limitExceeded: -32005,
          parse: -32700,
          invalidRequest: -32600,
          methodNotFound: -32601,
          invalidParams: -32602,
          internal: -32603
        },
        provider: {
          userRejectedRequest: 4001,
          unauthorized: 4100,
          unsupportedMethod: 4200,
          disconnected: 4900,
          chainDisconnected: 4901
        }
      };
      exports.errorValues = {
        '-32700': {
          standard: 'JSON RPC 2.0',
          message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.'
        },
        '-32600': {
          standard: 'JSON RPC 2.0',
          message: 'The JSON sent is not a valid Request object.'
        },
        '-32601': {
          standard: 'JSON RPC 2.0',
          message: 'The method does not exist / is not available.'
        },
        '-32602': {
          standard: 'JSON RPC 2.0',
          message: 'Invalid method parameter(s).'
        },
        '-32603': {
          standard: 'JSON RPC 2.0',
          message: 'Internal JSON-RPC error.'
        },
        '-32000': {
          standard: 'EIP-1474',
          message: 'Invalid input.'
        },
        '-32001': {
          standard: 'EIP-1474',
          message: 'Resource not found.'
        },
        '-32002': {
          standard: 'EIP-1474',
          message: 'Resource unavailable.'
        },
        '-32003': {
          standard: 'EIP-1474',
          message: 'Transaction rejected.'
        },
        '-32004': {
          standard: 'EIP-1474',
          message: 'Method not supported.'
        },
        '-32005': {
          standard: 'EIP-1474',
          message: 'Request limit exceeded.'
        },
        '4001': {
          standard: 'EIP-1193',
          message: 'User rejected the request.'
        },
        '4100': {
          standard: 'EIP-1193',
          message: 'The requested account and/or method has not been authorized by the user.'
        },
        '4200': {
          standard: 'EIP-1193',
          message: 'The requested method is not supported by this Ethereum provider.'
        },
        '4900': {
          standard: 'EIP-1193',
          message: 'The provider is disconnected from all chains.'
        },
        '4901': {
          standard: 'EIP-1193',
          message: 'The provider is disconnected from the specified chain.'
        }
      };
    },
    6748: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.providerErrors = exports.rpcErrors = void 0;
      const classes_1 = __webpack_require__(8856);
      const error_constants_1 = __webpack_require__(5191);
      const utils_1 = __webpack_require__(7962);
      exports.rpcErrors = {
        parse: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        invalidRequest: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        invalidParams: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        methodNotFound: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        internal: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        server: opts => {
          if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
            throw new Error('Ethereum RPC Server errors must provide single object argument.');
          }
          const {
            code
          } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getJsonRpcError(code, opts);
        },
        invalidInput: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        resourceNotFound: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        resourceUnavailable: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        transactionRejected: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        methodNotSupported: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        limitExceeded: arg => getJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      };
      exports.providerErrors = {
        userRejectedRequest: arg => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        unauthorized: arg => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        unsupportedMethod: arg => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        disconnected: arg => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        chainDisconnected: arg => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        custom: opts => {
          if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
            throw new Error('Ethereum Provider custom errors must provide single object argument.');
          }
          const {
            code,
            message,
            data
          } = opts;
          if (!message || typeof message !== 'string') {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      };
      function getJsonRpcError(code, arg) {
        const [message, data] = parseOpts(arg);
        return new classes_1.JsonRpcError(code, message ?? (0, utils_1.getMessageFromCode)(code), data);
      }
      function getEthProviderError(code, arg) {
        const [message, data] = parseOpts(arg);
        return new classes_1.EthereumProviderError(code, message ?? (0, utils_1.getMessageFromCode)(code), data);
      }
      function parseOpts(arg) {
        if (arg) {
          if (typeof arg === 'string') {
            return [arg];
          } else if (typeof arg === 'object' && !Array.isArray(arg)) {
            const {
              message,
              data
            } = arg;
            if (message && typeof message !== 'string') {
              throw new Error('Must specify string message.');
            }
            return [message ?? undefined, data];
          }
        }
        return [];
      }
    },
    774: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.errorCodes = exports.providerErrors = exports.rpcErrors = exports.getMessageFromCode = exports.serializeError = exports.serializeCause = exports.EthereumProviderError = exports.JsonRpcError = void 0;
      var classes_1 = __webpack_require__(8856);
      Object.defineProperty(exports, "JsonRpcError", {
        enumerable: true,
        get: function () {
          return classes_1.JsonRpcError;
        }
      });
      Object.defineProperty(exports, "EthereumProviderError", {
        enumerable: true,
        get: function () {
          return classes_1.EthereumProviderError;
        }
      });
      var utils_1 = __webpack_require__(7962);
      Object.defineProperty(exports, "serializeCause", {
        enumerable: true,
        get: function () {
          return utils_1.serializeCause;
        }
      });
      Object.defineProperty(exports, "serializeError", {
        enumerable: true,
        get: function () {
          return utils_1.serializeError;
        }
      });
      Object.defineProperty(exports, "getMessageFromCode", {
        enumerable: true,
        get: function () {
          return utils_1.getMessageFromCode;
        }
      });
      var errors_1 = __webpack_require__(6748);
      Object.defineProperty(exports, "rpcErrors", {
        enumerable: true,
        get: function () {
          return errors_1.rpcErrors;
        }
      });
      Object.defineProperty(exports, "providerErrors", {
        enumerable: true,
        get: function () {
          return errors_1.providerErrors;
        }
      });
      var error_constants_1 = __webpack_require__(5191);
      Object.defineProperty(exports, "errorCodes", {
        enumerable: true,
        get: function () {
          return error_constants_1.errorCodes;
        }
      });
    },
    7962: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.serializeCause = exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
      const utils_1 = __webpack_require__(5554);
      const error_constants_1 = __webpack_require__(5191);
      const FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
      const FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';
      const FALLBACK_ERROR = {
        code: FALLBACK_ERROR_CODE,
        message: getMessageFromCode(FALLBACK_ERROR_CODE)
      };
      exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';
      function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
        if (isValidCode(code)) {
          const codeString = code.toString();
          if ((0, utils_1.hasProperty)(error_constants_1.errorValues, codeString)) {
            return error_constants_1.errorValues[codeString].message;
          }
          if (isJsonRpcServerError(code)) {
            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
          }
        }
        return fallbackMessage;
      }
      exports.getMessageFromCode = getMessageFromCode;
      function isValidCode(code) {
        return Number.isInteger(code);
      }
      exports.isValidCode = isValidCode;
      function serializeError(error, {
        fallbackError = FALLBACK_ERROR,
        shouldIncludeStack = true
      } = {}) {
        if (!(0, utils_1.isJsonRpcError)(fallbackError)) {
          throw new Error('Must provide fallback error with integer number code and string message.');
        }
        const serialized = buildError(error, fallbackError);
        if (!shouldIncludeStack) {
          delete serialized.stack;
        }
        return serialized;
      }
      exports.serializeError = serializeError;
      function buildError(error, fallbackError) {
        if (error && typeof error === 'object' && 'serialize' in error && typeof error.serialize === 'function') {
          return error.serialize();
        }
        if ((0, utils_1.isJsonRpcError)(error)) {
          return error;
        }
        const cause = serializeCause(error);
        const fallbackWithCause = {
          ...fallbackError,
          data: {
            cause
          }
        };
        return fallbackWithCause;
      }
      function isJsonRpcServerError(code) {
        return code >= -32099 && code <= -32000;
      }
      function serializeCause(error) {
        if (Array.isArray(error)) {
          return error.map(entry => {
            if ((0, utils_1.isValidJson)(entry)) {
              return entry;
            } else if ((0, utils_1.isObject)(entry)) {
              return serializeObject(entry);
            }
            return null;
          });
        } else if ((0, utils_1.isObject)(error)) {
          return serializeObject(error);
        }
        if ((0, utils_1.isValidJson)(error)) {
          return error;
        }
        return null;
      }
      exports.serializeCause = serializeCause;
      function serializeObject(object) {
        return Object.getOwnPropertyNames(object).reduce((acc, key) => {
          const value = object[key];
          if ((0, utils_1.isValidJson)(value)) {
            acc[key] = value;
          }
          return acc;
        }, {});
      }
    },
    1817: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.text = exports.spinner = exports.panel = exports.heading = exports.divider = exports.copyable = void 0;
      const utils_1 = __webpack_require__(5554);
      const nodes_1 = __webpack_require__(9812);
      function createBuilder(type, struct, keys = []) {
        return (...args) => {
          if (args.length === 1 && (0, utils_1.isPlainObject)(args[0])) {
            const node = {
              ...args[0],
              type
            };
            (0, utils_1.assertStruct)(node, struct, `Invalid ${type} component`);
            return node;
          }
          const node = keys.reduce((partialNode, key, index) => {
            return {
              ...partialNode,
              [key]: args[index]
            };
          }, {
            type
          });
          (0, utils_1.assertStruct)(node, struct, `Invalid ${type} component`);
          return node;
        };
      }
      exports.copyable = createBuilder(nodes_1.NodeType.Copyable, nodes_1.CopyableStruct, ['value']);
      exports.divider = createBuilder(nodes_1.NodeType.Divider, nodes_1.DividerStruct);
      exports.heading = createBuilder(nodes_1.NodeType.Heading, nodes_1.HeadingStruct, ['value']);
      exports.panel = createBuilder(nodes_1.NodeType.Panel, nodes_1.PanelStruct, ['children']);
      exports.spinner = createBuilder(nodes_1.NodeType.Spinner, nodes_1.SpinnerStruct);
      exports.text = createBuilder(nodes_1.NodeType.Text, nodes_1.TextStruct, ['value']);
    },
    3961: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            }
          };
        }
        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = this && this.__exportStar || function (m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      };
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      __exportStar(__webpack_require__(1817), exports);
      __exportStar(__webpack_require__(9812), exports);
      __exportStar(__webpack_require__(5667), exports);
    },
    9812: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ComponentStruct = exports.TextStruct = exports.SpinnerStruct = exports.PanelStruct = exports.HeadingStruct = exports.DividerStruct = exports.CopyableStruct = exports.NodeType = void 0;
      const superstruct_1 = __webpack_require__(9249);
      const NodeStruct = (0, superstruct_1.object)({
        type: (0, superstruct_1.string)()
      });
      const ParentStruct = (0, superstruct_1.assign)(NodeStruct, (0, superstruct_1.object)({
        children: (0, superstruct_1.array)((0, superstruct_1.lazy)(() => exports.ComponentStruct))
      }));
      const LiteralStruct = (0, superstruct_1.assign)(NodeStruct, (0, superstruct_1.object)({
        value: (0, superstruct_1.unknown)()
      }));
      var NodeType;
      (function (NodeType) {
        NodeType["Copyable"] = "copyable";
        NodeType["Divider"] = "divider";
        NodeType["Heading"] = "heading";
        NodeType["Panel"] = "panel";
        NodeType["Spinner"] = "spinner";
        NodeType["Text"] = "text";
      })(NodeType = exports.NodeType || (exports.NodeType = {}));
      exports.CopyableStruct = (0, superstruct_1.assign)(LiteralStruct, (0, superstruct_1.object)({
        type: (0, superstruct_1.literal)(NodeType.Copyable),
        value: (0, superstruct_1.string)()
      }));
      exports.DividerStruct = (0, superstruct_1.assign)(NodeStruct, (0, superstruct_1.object)({
        type: (0, superstruct_1.literal)(NodeType.Divider)
      }));
      exports.HeadingStruct = (0, superstruct_1.assign)(LiteralStruct, (0, superstruct_1.object)({
        type: (0, superstruct_1.literal)(NodeType.Heading),
        value: (0, superstruct_1.string)()
      }));
      exports.PanelStruct = (0, superstruct_1.assign)(ParentStruct, (0, superstruct_1.object)({
        type: (0, superstruct_1.literal)(NodeType.Panel)
      }));
      exports.SpinnerStruct = (0, superstruct_1.assign)(NodeStruct, (0, superstruct_1.object)({
        type: (0, superstruct_1.literal)(NodeType.Spinner)
      }));
      exports.TextStruct = (0, superstruct_1.assign)(LiteralStruct, (0, superstruct_1.object)({
        type: (0, superstruct_1.literal)(NodeType.Text),
        value: (0, superstruct_1.string)()
      }));
      exports.ComponentStruct = (0, superstruct_1.union)([exports.CopyableStruct, exports.DividerStruct, exports.HeadingStruct, exports.PanelStruct, exports.SpinnerStruct, exports.TextStruct]);
    },
    5667: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertIsComponent = exports.isComponent = void 0;
      const utils_1 = __webpack_require__(5554);
      const superstruct_1 = __webpack_require__(9249);
      const nodes_1 = __webpack_require__(9812);
      function isComponent(value) {
        return (0, superstruct_1.is)(value, nodes_1.ComponentStruct);
      }
      exports.isComponent = isComponent;
      function assertIsComponent(value) {
        (0, utils_1.assertStruct)(value, nodes_1.ComponentStruct, 'Invalid component');
      }
      exports.assertIsComponent = assertIsComponent;
    },
    2875: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
      const superstruct_1 = __webpack_require__(9249);
      function isErrorWithMessage(error) {
        return typeof error === 'object' && error !== null && 'message' in error;
      }
      function isConstructable(fn) {
        var _a, _b;
        return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
      }
      function getErrorMessage(error) {
        const message = isErrorWithMessage(error) ? error.message : String(error);
        if (message.endsWith('.')) {
          return message.slice(0, -1);
        }
        return message;
      }
      function getError(ErrorWrapper, message) {
        if (isConstructable(ErrorWrapper)) {
          return new ErrorWrapper({
            message
          });
        }
        return ErrorWrapper({
          message
        });
      }
      class AssertionError extends Error {
        constructor(options) {
          super(options.message);
          this.code = 'ERR_ASSERTION';
        }
      }
      exports.AssertionError = AssertionError;
      function assert(value, message = 'Assertion failed.', ErrorWrapper = AssertionError) {
        if (!value) {
          if (message instanceof Error) {
            throw message;
          }
          throw getError(ErrorWrapper, message);
        }
      }
      exports.assert = assert;
      function assertStruct(value, struct, errorPrefix = 'Assertion failed', ErrorWrapper = AssertionError) {
        try {
          (0, superstruct_1.assert)(value, struct);
        } catch (error) {
          throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
        }
      }
      exports.assertStruct = assertStruct;
      function assertExhaustive(_object) {
        throw new Error('Invalid branch reached. Should be detected during compilation.');
      }
      exports.assertExhaustive = assertExhaustive;
    },
    7552: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.base64 = void 0;
      const superstruct_1 = __webpack_require__(9249);
      const assert_1 = __webpack_require__(2875);
      const base64 = (struct, options = {}) => {
        var _a, _b;
        const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
        const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
        let letters;
        if (characterSet === 'base64') {
          letters = String.raw`[A-Za-z0-9+\/]`;
        } else {
          (0, assert_1.assert)(characterSet === 'base64url');
          letters = String.raw`[-_A-Za-z0-9]`;
        }
        let re;
        if (paddingRequired) {
          re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
        } else {
          re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
        }
        return (0, superstruct_1.pattern)(struct, re);
      };
      exports.base64 = base64;
    },
    638: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      var Buffer = __webpack_require__(8834)["lW"];
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
      const assert_1 = __webpack_require__(2875);
      const hex_1 = __webpack_require__(7657);
      const HEX_MINIMUM_NUMBER_CHARACTER = 48;
      const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
      const HEX_CHARACTER_OFFSET = 87;
      function getPrecomputedHexValuesBuilder() {
        const lookupTable = [];
        return () => {
          if (lookupTable.length === 0) {
            for (let i = 0; i < 256; i++) {
              lookupTable.push(i.toString(16).padStart(2, '0'));
            }
          }
          return lookupTable;
        };
      }
      const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
      function isBytes(value) {
        return value instanceof Uint8Array;
      }
      exports.isBytes = isBytes;
      function assertIsBytes(value) {
        (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');
      }
      exports.assertIsBytes = assertIsBytes;
      function bytesToHex(bytes) {
        assertIsBytes(bytes);
        if (bytes.length === 0) {
          return '0x';
        }
        const lookupTable = getPrecomputedHexValues();
        const hexadecimal = new Array(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
          hexadecimal[i] = lookupTable[bytes[i]];
        }
        return (0, hex_1.add0x)(hexadecimal.join(''));
      }
      exports.bytesToHex = bytesToHex;
      function bytesToBigInt(bytes) {
        assertIsBytes(bytes);
        const hexadecimal = bytesToHex(bytes);
        return BigInt(hexadecimal);
      }
      exports.bytesToBigInt = bytesToBigInt;
      function bytesToSignedBigInt(bytes) {
        assertIsBytes(bytes);
        let value = BigInt(0);
        for (const byte of bytes) {
          value = (value << BigInt(8)) + BigInt(byte);
        }
        return BigInt.asIntN(bytes.length * 8, value);
      }
      exports.bytesToSignedBigInt = bytesToSignedBigInt;
      function bytesToNumber(bytes) {
        assertIsBytes(bytes);
        const bigint = bytesToBigInt(bytes);
        (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
        return Number(bigint);
      }
      exports.bytesToNumber = bytesToNumber;
      function bytesToString(bytes) {
        assertIsBytes(bytes);
        return new TextDecoder().decode(bytes);
      }
      exports.bytesToString = bytesToString;
      function hexToBytes(value) {
        var _a;
        if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
          return new Uint8Array();
        }
        (0, hex_1.assertIsHexString)(value);
        const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
        const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
        const bytes = new Uint8Array(normalizedValue.length / 2);
        for (let i = 0; i < bytes.length; i++) {
          const c1 = normalizedValue.charCodeAt(i * 2);
          const c2 = normalizedValue.charCodeAt(i * 2 + 1);
          const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
          const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
          bytes[i] = n1 * 16 + n2;
        }
        return bytes;
      }
      exports.hexToBytes = hexToBytes;
      function bigIntToBytes(value) {
        (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
        (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
        const hexadecimal = value.toString(16);
        return hexToBytes(hexadecimal);
      }
      exports.bigIntToBytes = bigIntToBytes;
      function bigIntFits(value, bytes) {
        (0, assert_1.assert)(bytes > 0);
        const mask = value >> BigInt(31);
        return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));
      }
      function signedBigIntToBytes(value, byteLength) {
        (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
        (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
        (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');
        (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
        let numberValue = value;
        const bytes = new Uint8Array(byteLength);
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = Number(BigInt.asUintN(8, numberValue));
          numberValue >>= BigInt(8);
        }
        return bytes.reverse();
      }
      exports.signedBigIntToBytes = signedBigIntToBytes;
      function numberToBytes(value) {
        (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
        (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
        (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
        const hexadecimal = value.toString(16);
        return hexToBytes(hexadecimal);
      }
      exports.numberToBytes = numberToBytes;
      function stringToBytes(value) {
        (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');
        return new TextEncoder().encode(value);
      }
      exports.stringToBytes = stringToBytes;
      function valueToBytes(value) {
        if (typeof value === 'bigint') {
          return bigIntToBytes(value);
        }
        if (typeof value === 'number') {
          return numberToBytes(value);
        }
        if (typeof value === 'string') {
          if (value.startsWith('0x')) {
            return hexToBytes(value);
          }
          return stringToBytes(value);
        }
        if (isBytes(value)) {
          return value;
        }
        throw new TypeError(`Unsupported value type: "${typeof value}".`);
      }
      exports.valueToBytes = valueToBytes;
      function concatBytes(values) {
        const normalizedValues = new Array(values.length);
        let byteLength = 0;
        for (let i = 0; i < values.length; i++) {
          const value = valueToBytes(values[i]);
          normalizedValues[i] = value;
          byteLength += value.length;
        }
        const bytes = new Uint8Array(byteLength);
        for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
          bytes.set(normalizedValues[i], offset);
          offset += normalizedValues[i].length;
        }
        return bytes;
      }
      exports.concatBytes = concatBytes;
      function createDataView(bytes) {
        if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
          const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
          return new DataView(buffer);
        }
        return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      }
      exports.createDataView = createDataView;
    },
    2793: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ChecksumStruct = void 0;
      const superstruct_1 = __webpack_require__(9249);
      const base64_1 = __webpack_require__(7552);
      exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), {
        paddingRequired: true
      }), 44, 44);
    },
    5740: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
      const superstruct_1 = __webpack_require__(9249);
      const assert_1 = __webpack_require__(2875);
      const bytes_1 = __webpack_require__(638);
      const hex_1 = __webpack_require__(7657);
      const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
      const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
      const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
      const BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
      const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
      const HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
      function createNumber(value) {
        try {
          const result = (0, superstruct_1.create)(value, NumberCoercer);
          (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
          return result;
        } catch (error) {
          if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
          }
          throw error;
        }
      }
      exports.createNumber = createNumber;
      function createBigInt(value) {
        try {
          return (0, superstruct_1.create)(value, BigIntCoercer);
        } catch (error) {
          if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
          }
          throw error;
        }
      }
      exports.createBigInt = createBigInt;
      function createBytes(value) {
        if (typeof value === 'string' && value.toLowerCase() === '0x') {
          return new Uint8Array();
        }
        try {
          return (0, superstruct_1.create)(value, BytesCoercer);
        } catch (error) {
          if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
          }
          throw error;
        }
      }
      exports.createBytes = createBytes;
      function createHex(value) {
        if (value instanceof Uint8Array && value.length === 0 || typeof value === 'string' && value.toLowerCase() === '0x') {
          return '0x';
        }
        try {
          return (0, superstruct_1.create)(value, HexCoercer);
        } catch (error) {
          if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
          }
          throw error;
        }
      }
      exports.createHex = createHex;
    },
    6618: function (__unused_webpack_module, exports) {
      "use strict";

      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _FrozenMap_map, _FrozenSet_set;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FrozenSet = exports.FrozenMap = void 0;
      class FrozenMap {
        constructor(entries) {
          _FrozenMap_map.set(this, void 0);
          __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
          Object.freeze(this);
        }
        get size() {
          return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
        }
        [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
          return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
        }
        entries() {
          return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
        }
        forEach(callbackfn, thisArg) {
          return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
        }
        get(key) {
          return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
        }
        has(key) {
          return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
        }
        keys() {
          return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
        }
        values() {
          return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
        }
        toString() {
          return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([key, value]) => `${String(key)} => ${String(value)}`).join(', ')} ` : ''}}`;
        }
      }
      exports.FrozenMap = FrozenMap;
      class FrozenSet {
        constructor(values) {
          _FrozenSet_set.set(this, void 0);
          __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
          Object.freeze(this);
        }
        get size() {
          return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
        }
        [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
          return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
        }
        entries() {
          return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
        }
        forEach(callbackfn, thisArg) {
          return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
        }
        has(value) {
          return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
        }
        keys() {
          return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
        }
        values() {
          return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
        }
        toString() {
          return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map(member => String(member)).join(', ')} ` : ''}}`;
        }
      }
      exports.FrozenSet = FrozenSet;
      Object.freeze(FrozenMap);
      Object.freeze(FrozenMap.prototype);
      Object.freeze(FrozenSet);
      Object.freeze(FrozenSet.prototype);
    },
    4559: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    },
    7657: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
      const superstruct_1 = __webpack_require__(9249);
      const assert_1 = __webpack_require__(2875);
      exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
      exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
      function isHexString(value) {
        return (0, superstruct_1.is)(value, exports.HexStruct);
      }
      exports.isHexString = isHexString;
      function isStrictHexString(value) {
        return (0, superstruct_1.is)(value, exports.StrictHexStruct);
      }
      exports.isStrictHexString = isStrictHexString;
      function assertIsHexString(value) {
        (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
      }
      exports.assertIsHexString = assertIsHexString;
      function assertIsStrictHexString(value) {
        (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
      }
      exports.assertIsStrictHexString = assertIsStrictHexString;
      function add0x(hexadecimal) {
        if (hexadecimal.startsWith('0x')) {
          return hexadecimal;
        }
        if (hexadecimal.startsWith('0X')) {
          return `0x${hexadecimal.substring(2)}`;
        }
        return `0x${hexadecimal}`;
      }
      exports.add0x = add0x;
      function remove0x(hexadecimal) {
        if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
          return hexadecimal.substring(2);
        }
        return hexadecimal;
      }
      exports.remove0x = remove0x;
    },
    5554: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            }
          };
        }
        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = this && this.__exportStar || function (m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
      };
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      __exportStar(__webpack_require__(2875), exports);
      __exportStar(__webpack_require__(7552), exports);
      __exportStar(__webpack_require__(638), exports);
      __exportStar(__webpack_require__(2793), exports);
      __exportStar(__webpack_require__(5740), exports);
      __exportStar(__webpack_require__(6618), exports);
      __exportStar(__webpack_require__(4559), exports);
      __exportStar(__webpack_require__(7657), exports);
      __exportStar(__webpack_require__(9545), exports);
      __exportStar(__webpack_require__(8183), exports);
      __exportStar(__webpack_require__(3621), exports);
      __exportStar(__webpack_require__(758), exports);
      __exportStar(__webpack_require__(4030), exports);
      __exportStar(__webpack_require__(368), exports);
      __exportStar(__webpack_require__(2968), exports);
      __exportStar(__webpack_require__(7717), exports);
      __exportStar(__webpack_require__(3191), exports);
    },
    9545: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = void 0;
      const superstruct_1 = __webpack_require__(9249);
      const assert_1 = __webpack_require__(2875);
      const finiteNumber = () => (0, superstruct_1.define)('finite number', value => {
        return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);
      });
      exports.UnsafeJsonStruct = (0, superstruct_1.union)([(0, superstruct_1.literal)(null), (0, superstruct_1.boolean)(), finiteNumber(), (0, superstruct_1.string)(), (0, superstruct_1.array)((0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)), (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct))]);
      exports.JsonStruct = (0, superstruct_1.define)('Json', (value, context) => {
        function checkStruct(innerValue, struct) {
          const iterator = struct.validator(innerValue, context);
          const errors = [...iterator];
          if (errors.length > 0) {
            return errors;
          }
          return true;
        }
        try {
          const unsafeResult = checkStruct(value, exports.UnsafeJsonStruct);
          if (unsafeResult !== true) {
            return unsafeResult;
          }
          return checkStruct(JSON.parse(JSON.stringify(value)), exports.UnsafeJsonStruct);
        } catch (error) {
          if (error instanceof RangeError) {
            return 'Circular reference detected';
          }
          return false;
        }
      });
      function isValidJson(value) {
        return (0, superstruct_1.is)(value, exports.JsonStruct);
      }
      exports.isValidJson = isValidJson;
      function getJsonSize(value) {
        (0, assert_1.assertStruct)(value, exports.JsonStruct, 'Invalid JSON value');
        const json = JSON.stringify(value);
        return new TextEncoder().encode(json).byteLength;
      }
      exports.getJsonSize = getJsonSize;
      exports.jsonrpc2 = '2.0';
      exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
      exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
      exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
        code: (0, superstruct_1.integer)(),
        message: (0, superstruct_1.string)(),
        data: (0, superstruct_1.optional)(exports.JsonStruct),
        stack: (0, superstruct_1.optional)((0, superstruct_1.string)())
      });
      exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
      exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
        id: exports.JsonRpcIdStruct,
        jsonrpc: exports.JsonRpcVersionStruct,
        method: (0, superstruct_1.string)(),
        params: exports.JsonRpcParamsStruct
      });
      exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
      function isJsonRpcNotification(value) {
        return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
      }
      exports.isJsonRpcNotification = isJsonRpcNotification;
      function assertIsJsonRpcNotification(value, ErrorWrapper) {
        (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
      }
      exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
      function isJsonRpcRequest(value) {
        return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
      }
      exports.isJsonRpcRequest = isJsonRpcRequest;
      function assertIsJsonRpcRequest(value, ErrorWrapper) {
        (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
      }
      exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
      exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
        id: exports.JsonRpcIdStruct,
        jsonrpc: exports.JsonRpcVersionStruct,
        result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
        error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct)
      });
      exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
        id: exports.JsonRpcIdStruct,
        jsonrpc: exports.JsonRpcVersionStruct,
        result: exports.JsonStruct
      });
      exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
        id: exports.JsonRpcIdStruct,
        jsonrpc: exports.JsonRpcVersionStruct,
        error: exports.JsonRpcErrorStruct
      });
      exports.JsonRpcResponseStruct = (0, superstruct_1.union)([exports.JsonRpcSuccessStruct, exports.JsonRpcFailureStruct]);
      function isPendingJsonRpcResponse(response) {
        return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
      }
      exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
      function assertIsPendingJsonRpcResponse(response, ErrorWrapper) {
        (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
      }
      exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
      function isJsonRpcResponse(response) {
        return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
      }
      exports.isJsonRpcResponse = isJsonRpcResponse;
      function assertIsJsonRpcResponse(value, ErrorWrapper) {
        (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
      }
      exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
      function isJsonRpcSuccess(value) {
        return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
      }
      exports.isJsonRpcSuccess = isJsonRpcSuccess;
      function assertIsJsonRpcSuccess(value, ErrorWrapper) {
        (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
      }
      exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
      function isJsonRpcFailure(value) {
        return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
      }
      exports.isJsonRpcFailure = isJsonRpcFailure;
      function assertIsJsonRpcFailure(value, ErrorWrapper) {
        (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
      }
      exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
      function isJsonRpcError(value) {
        return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
      }
      exports.isJsonRpcError = isJsonRpcError;
      function assertIsJsonRpcError(value, ErrorWrapper) {
        (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
      }
      exports.assertIsJsonRpcError = assertIsJsonRpcError;
      function getJsonRpcIdValidator(options) {
        const {
          permitEmptyString,
          permitFractions,
          permitNull
        } = Object.assign({
          permitEmptyString: true,
          permitFractions: false,
          permitNull: true
        }, options);
        const isValidJsonRpcId = id => {
          return Boolean(typeof id === 'number' && (permitFractions || Number.isInteger(id)) || typeof id === 'string' && (permitEmptyString || id.length > 0) || permitNull && id === null);
        };
        return isValidJsonRpcId;
      }
      exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
    },
    8183: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    },
    3621: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __importDefault = this && this.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createModuleLogger = exports.createProjectLogger = void 0;
      const debug_1 = __importDefault(__webpack_require__(5130));
      const globalLogger = (0, debug_1.default)('metamask');
      function createProjectLogger(projectName) {
        return globalLogger.extend(projectName);
      }
      exports.createProjectLogger = createProjectLogger;
      function createModuleLogger(projectLogger, moduleName) {
        return projectLogger.extend(moduleName);
      }
      exports.createModuleLogger = createModuleLogger;
    },
    758: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
      function isNonEmptyArray(value) {
        return Array.isArray(value) && value.length > 0;
      }
      exports.isNonEmptyArray = isNonEmptyArray;
      function isNullOrUndefined(value) {
        return value === null || value === undefined;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isObject(value) {
        return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
      }
      exports.isObject = isObject;
      const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
      exports.hasProperty = hasProperty;
      var JsonSize;
      (function (JsonSize) {
        JsonSize[JsonSize["Null"] = 4] = "Null";
        JsonSize[JsonSize["Comma"] = 1] = "Comma";
        JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
        JsonSize[JsonSize["True"] = 4] = "True";
        JsonSize[JsonSize["False"] = 5] = "False";
        JsonSize[JsonSize["Quote"] = 1] = "Quote";
        JsonSize[JsonSize["Colon"] = 1] = "Colon";
        JsonSize[JsonSize["Date"] = 24] = "Date";
      })(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
      exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
      function isPlainObject(value) {
        if (typeof value !== 'object' || value === null) {
          return false;
        }
        try {
          let proto = value;
          while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
          }
          return Object.getPrototypeOf(value) === proto;
        } catch (_) {
          return false;
        }
      }
      exports.isPlainObject = isPlainObject;
      function isASCII(character) {
        return character.charCodeAt(0) <= 127;
      }
      exports.isASCII = isASCII;
      function calculateStringSize(value) {
        var _a;
        const size = value.split('').reduce((total, character) => {
          if (isASCII(character)) {
            return total + 1;
          }
          return total + 2;
        }, 0);
        return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
      }
      exports.calculateStringSize = calculateStringSize;
      function calculateNumberSize(value) {
        return value.toString().length;
      }
      exports.calculateNumberSize = calculateNumberSize;
    },
    4030: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
      const assert_1 = __webpack_require__(2875);
      const hex_1 = __webpack_require__(7657);
      const numberToHex = value => {
        (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
        (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
        (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
        return (0, hex_1.add0x)(value.toString(16));
      };
      exports.numberToHex = numberToHex;
      const bigIntToHex = value => {
        (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
        (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
        return (0, hex_1.add0x)(value.toString(16));
      };
      exports.bigIntToHex = bigIntToHex;
      const hexToNumber = value => {
        (0, hex_1.assertIsHexString)(value);
        const numberValue = parseInt(value, 16);
        (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
        return numberValue;
      };
      exports.hexToNumber = hexToNumber;
      const hexToBigInt = value => {
        (0, hex_1.assertIsHexString)(value);
        return BigInt((0, hex_1.add0x)(value));
      };
      exports.hexToBigInt = hexToBigInt;
    },
    368: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    },
    2968: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
      var Duration;
      (function (Duration) {
        Duration[Duration["Millisecond"] = 1] = "Millisecond";
        Duration[Duration["Second"] = 1000] = "Second";
        Duration[Duration["Minute"] = 60000] = "Minute";
        Duration[Duration["Hour"] = 3600000] = "Hour";
        Duration[Duration["Day"] = 86400000] = "Day";
        Duration[Duration["Week"] = 604800000] = "Week";
        Duration[Duration["Year"] = 31536000000] = "Year";
      })(Duration = exports.Duration || (exports.Duration = {}));
      const isNonNegativeInteger = number => Number.isInteger(number) && number >= 0;
      const assertIsNonNegativeInteger = (number, name) => {
        if (!isNonNegativeInteger(number)) {
          throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
        }
      };
      function inMilliseconds(count, duration) {
        assertIsNonNegativeInteger(count, 'count');
        return count * duration;
      }
      exports.inMilliseconds = inMilliseconds;
      function timeSince(timestamp) {
        assertIsNonNegativeInteger(timestamp, 'timestamp');
        return Date.now() - timestamp;
      }
      exports.timeSince = timeSince;
    },
    7717: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    },
    3191: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
      const semver_1 = __webpack_require__(7699);
      const superstruct_1 = __webpack_require__(9249);
      const assert_1 = __webpack_require__(2875);
      exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', value => {
        if ((0, semver_1.valid)(value) === null) {
          return `Expected SemVer version, got "${value}"`;
        }
        return true;
      });
      exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', value => {
        if ((0, semver_1.validRange)(value) === null) {
          return `Expected SemVer range, got "${value}"`;
        }
        return true;
      });
      function isValidSemVerVersion(version) {
        return (0, superstruct_1.is)(version, exports.VersionStruct);
      }
      exports.isValidSemVerVersion = isValidSemVerVersion;
      function isValidSemVerRange(versionRange) {
        return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
      }
      exports.isValidSemVerRange = isValidSemVerRange;
      function assertIsSemVerVersion(version) {
        (0, assert_1.assertStruct)(version, exports.VersionStruct);
      }
      exports.assertIsSemVerVersion = assertIsSemVerVersion;
      function assertIsSemVerRange(range) {
        (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
      }
      exports.assertIsSemVerRange = assertIsSemVerRange;
      function gtVersion(version1, version2) {
        return (0, semver_1.gt)(version1, version2);
      }
      exports.gtVersion = gtVersion;
      function gtRange(version, range) {
        return (0, semver_1.gtr)(version, range);
      }
      exports.gtRange = gtRange;
      function satisfiesVersionRange(version, versionRange) {
        return (0, semver_1.satisfies)(version, versionRange, {
          includePrerelease: true
        });
      }
      exports.satisfiesVersionRange = satisfiesVersionRange;
    },
    6698: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;
      const nodeCrypto = __webpack_require__(7695);
      const _0n = BigInt(0);
      const _1n = BigInt(1);
      const _2n = BigInt(2);
      const _3n = BigInt(3);
      const _8n = BigInt(8);
      const CURVE = Object.freeze({
        a: _0n,
        b: BigInt(7),
        P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
        n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
        h: _1n,
        Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
        Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')
      });
      exports.CURVE = CURVE;
      const divNearest = (a, b) => (a + b / _2n) / b;
      const endo = {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar(k) {
          const {
            n
          } = CURVE;
          const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
          const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
          const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
          const b2 = a1;
          const POW_2_128 = BigInt('0x100000000000000000000000000000000');
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = mod(k - c1 * a1 - c2 * a2, n);
          let k2 = mod(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg) k1 = n - k1;
          if (k2neg) k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
          }
          return {
            k1neg,
            k1,
            k2neg,
            k2
          };
        }
      };
      const fieldLen = 32;
      const groupLen = 32;
      const hashLen = 32;
      const compressedLen = fieldLen + 1;
      const uncompressedLen = 2 * fieldLen + 1;
      function weierstrass(x) {
        const {
          a,
          b
        } = CURVE;
        const x2 = mod(x * x);
        const x3 = mod(x2 * x);
        return mod(x3 + a * x + b);
      }
      const USE_ENDOMORPHISM = CURVE.a === _0n;
      class ShaError extends Error {
        constructor(message) {
          super(message);
        }
      }
      function assertJacPoint(other) {
        if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');
      }
      class JacobianPoint {
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        static fromAffine(p) {
          if (!(p instanceof Point)) {
            throw new TypeError('JacobianPoint#fromAffine: expected Point');
          }
          if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;
          return new JacobianPoint(p.x, p.y, _1n);
        }
        static toAffineBatch(points) {
          const toInv = invertBatch(points.map(p => p.z));
          return points.map((p, i) => p.toAffine(toInv[i]));
        }
        static normalizeZ(points) {
          return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
        }
        equals(other) {
          assertJacPoint(other);
          const {
            x: X1,
            y: Y1,
            z: Z1
          } = this;
          const {
            x: X2,
            y: Y2,
            z: Z2
          } = other;
          const Z1Z1 = mod(Z1 * Z1);
          const Z2Z2 = mod(Z2 * Z2);
          const U1 = mod(X1 * Z2Z2);
          const U2 = mod(X2 * Z1Z1);
          const S1 = mod(mod(Y1 * Z2) * Z2Z2);
          const S2 = mod(mod(Y2 * Z1) * Z1Z1);
          return U1 === U2 && S1 === S2;
        }
        negate() {
          return new JacobianPoint(this.x, mod(-this.y), this.z);
        }
        double() {
          const {
            x: X1,
            y: Y1,
            z: Z1
          } = this;
          const A = mod(X1 * X1);
          const B = mod(Y1 * Y1);
          const C = mod(B * B);
          const x1b = X1 + B;
          const D = mod(_2n * (mod(x1b * x1b) - A - C));
          const E = mod(_3n * A);
          const F = mod(E * E);
          const X3 = mod(F - _2n * D);
          const Y3 = mod(E * (D - X3) - _8n * C);
          const Z3 = mod(_2n * Y1 * Z1);
          return new JacobianPoint(X3, Y3, Z3);
        }
        add(other) {
          assertJacPoint(other);
          const {
            x: X1,
            y: Y1,
            z: Z1
          } = this;
          const {
            x: X2,
            y: Y2,
            z: Z2
          } = other;
          if (X2 === _0n || Y2 === _0n) return this;
          if (X1 === _0n || Y1 === _0n) return other;
          const Z1Z1 = mod(Z1 * Z1);
          const Z2Z2 = mod(Z2 * Z2);
          const U1 = mod(X1 * Z2Z2);
          const U2 = mod(X2 * Z1Z1);
          const S1 = mod(mod(Y1 * Z2) * Z2Z2);
          const S2 = mod(mod(Y2 * Z1) * Z1Z1);
          const H = mod(U2 - U1);
          const r = mod(S2 - S1);
          if (H === _0n) {
            if (r === _0n) {
              return this.double();
            } else {
              return JacobianPoint.ZERO;
            }
          }
          const HH = mod(H * H);
          const HHH = mod(H * HH);
          const V = mod(U1 * HH);
          const X3 = mod(r * r - HHH - _2n * V);
          const Y3 = mod(r * (V - X3) - S1 * HHH);
          const Z3 = mod(Z1 * Z2 * H);
          return new JacobianPoint(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        multiplyUnsafe(scalar) {
          const P0 = JacobianPoint.ZERO;
          if (typeof scalar === 'bigint' && scalar === _0n) return P0;
          let n = normalizeScalar(scalar);
          if (n === _1n) return this;
          if (!USE_ENDOMORPHISM) {
            let p = P0;
            let d = this;
            while (n > _0n) {
              if (n & _1n) p = p.add(d);
              d = d.double();
              n >>= _1n;
            }
            return p;
          }
          let {
            k1neg,
            k1,
            k2neg,
            k2
          } = endo.splitScalar(n);
          let k1p = P0;
          let k2p = P0;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n) k1p = k1p.add(d);
            if (k2 & _1n) k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg) k1p = k1p.negate();
          if (k2neg) k2p = k2p.negate();
          k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
          return k1p.add(k2p);
        }
        precomputeWindow(W) {
          const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
          const points = [];
          let p = this;
          let base = p;
          for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            for (let i = 1; i < 2 ** (W - 1); i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        }
        wNAF(n, affinePoint) {
          if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;
          const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
          if (256 % W) {
            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
          }
          let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
          if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
              precomputes = JacobianPoint.normalizeZ(precomputes);
              pointPrecomputes.set(affinePoint, precomputes);
            }
          }
          let p = JacobianPoint.ZERO;
          let f = JacobianPoint.BASE;
          const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
          const windowSize = 2 ** (W - 1);
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return {
            p,
            f
          };
        }
        multiply(scalar, affinePoint) {
          let n = normalizeScalar(scalar);
          let point;
          let fake;
          if (USE_ENDOMORPHISM) {
            const {
              k1neg,
              k1,
              k2neg,
              k2
            } = endo.splitScalar(n);
            let {
              p: k1p,
              f: f1p
            } = this.wNAF(k1, affinePoint);
            let {
              p: k2p,
              f: f2p
            } = this.wNAF(k2, affinePoint);
            k1p = constTimeNegate(k1neg, k1p);
            k2p = constTimeNegate(k2neg, k2p);
            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const {
              p,
              f
            } = this.wNAF(n, affinePoint);
            point = p;
            fake = f;
          }
          return JacobianPoint.normalizeZ([point, fake])[0];
        }
        toAffine(invZ) {
          const {
            x,
            y,
            z
          } = this;
          const is0 = this.equals(JacobianPoint.ZERO);
          if (invZ == null) invZ = is0 ? _8n : invert(z);
          const iz1 = invZ;
          const iz2 = mod(iz1 * iz1);
          const iz3 = mod(iz2 * iz1);
          const ax = mod(x * iz2);
          const ay = mod(y * iz3);
          const zz = mod(z * iz1);
          if (is0) return Point.ZERO;
          if (zz !== _1n) throw new Error('invZ was invalid');
          return new Point(ax, ay);
        }
      }
      JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
      JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
      function constTimeNegate(condition, item) {
        const neg = item.negate();
        return condition ? neg : item;
      }
      const pointPrecomputes = new WeakMap();
      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        hasEvenY() {
          return this.y % _2n === _0n;
        }
        static fromCompressedHex(bytes) {
          const isShort = bytes.length === 32;
          const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
          if (!isValidFieldElement(x)) throw new Error('Point is not on curve');
          const y2 = weierstrass(x);
          let y = sqrtMod(y2);
          const isYOdd = (y & _1n) === _1n;
          if (isShort) {
            if (isYOdd) y = mod(-y);
          } else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd) y = mod(-y);
          }
          const point = new Point(x, y);
          point.assertValidity();
          return point;
        }
        static fromUncompressedHex(bytes) {
          const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
          const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
          const point = new Point(x, y);
          point.assertValidity();
          return point;
        }
        static fromHex(hex) {
          const bytes = ensureBytes(hex);
          const len = bytes.length;
          const header = bytes[0];
          if (len === fieldLen) return this.fromCompressedHex(bytes);
          if (len === compressedLen && (header === 0x02 || header === 0x03)) {
            return this.fromCompressedHex(bytes);
          }
          if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);
          throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
        }
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normalizePrivateKey(privateKey));
        }
        static fromSignature(msgHash, signature, recovery) {
          const {
            r,
            s
          } = normalizeSignature(signature);
          if (![0, 1, 2, 3].includes(recovery)) throw new Error('Cannot recover: invalid recovery bit');
          const h = truncateHash(ensureBytes(msgHash));
          const {
            n
          } = CURVE;
          const radj = recovery === 2 || recovery === 3 ? r + n : r;
          const rinv = invert(radj, n);
          const u1 = mod(-h * rinv, n);
          const u2 = mod(s * rinv, n);
          const prefix = recovery & 1 ? '03' : '02';
          const R = Point.fromHex(prefix + numTo32bStr(radj));
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q) throw new Error('Cannot recover signature: point at infinify');
          Q.assertValidity();
          return Q;
        }
        toRawBytes(isCompressed = false) {
          return hexToBytes(this.toHex(isCompressed));
        }
        toHex(isCompressed = false) {
          const x = numTo32bStr(this.x);
          if (isCompressed) {
            const prefix = this.hasEvenY() ? '02' : '03';
            return `${prefix}${x}`;
          } else {
            return `04${x}${numTo32bStr(this.y)}`;
          }
        }
        toHexX() {
          return this.toHex(true).slice(2);
        }
        toRawX() {
          return this.toRawBytes(true).slice(1);
        }
        assertValidity() {
          const msg = 'Point is not on elliptic curve';
          const {
            x,
            y
          } = this;
          if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);
          const left = mod(y * y);
          const right = weierstrass(x);
          if (mod(left - right) !== _0n) throw new Error(msg);
        }
        equals(other) {
          return this.x === other.x && this.y === other.y;
        }
        negate() {
          return new Point(this.x, mod(-this.y));
        }
        double() {
          return JacobianPoint.fromAffine(this).double().toAffine();
        }
        add(other) {
          return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
        }
        subtract(other) {
          return this.add(other.negate());
        }
        multiply(scalar) {
          return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
        }
        multiplyAndAddUnsafe(Q, a, b) {
          const P = JacobianPoint.fromAffine(this);
          const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
          const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
          const sum = aP.add(bQ);
          return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
        }
      }
      exports.Point = Point;
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
      Point.ZERO = new Point(_0n, _0n);
      function sliceDER(s) {
        return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
      }
      function parseDERInt(data) {
        if (data.length < 2 || data[0] !== 0x02) {
          throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
        }
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len) {
          throw new Error(`Invalid signature integer: wrong length`);
        }
        if (res[0] === 0x00 && res[1] <= 0x7f) {
          throw new Error('Invalid signature integer: trailing length');
        }
        return {
          data: bytesToNumber(res),
          left: data.subarray(len + 2)
        };
      }
      function parseDERSignature(data) {
        if (data.length < 2 || data[0] != 0x30) {
          throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
        }
        if (data[1] !== data.length - 2) {
          throw new Error('Invalid signature: incorrect length');
        }
        const {
          data: r,
          left: sBytes
        } = parseDERInt(data.subarray(2));
        const {
          data: s,
          left: rBytesLeft
        } = parseDERInt(sBytes);
        if (rBytesLeft.length) {
          throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
        }
        return {
          r,
          s
        };
      }
      class Signature {
        constructor(r, s) {
          this.r = r;
          this.s = s;
          this.assertValidity();
        }
        static fromCompact(hex) {
          const arr = hex instanceof Uint8Array;
          const name = 'Signature.fromCompact';
          if (typeof hex !== 'string' && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);
          const str = arr ? bytesToHex(hex) : hex;
          if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);
          return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
        }
        static fromDER(hex) {
          const arr = hex instanceof Uint8Array;
          if (typeof hex !== 'string' && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
          const {
            r,
            s
          } = parseDERSignature(arr ? hex : hexToBytes(hex));
          return new Signature(r, s);
        }
        static fromHex(hex) {
          return this.fromDER(hex);
        }
        assertValidity() {
          const {
            r,
            s
          } = this;
          if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');
          if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');
        }
        hasHighS() {
          const HALF = CURVE.n >> _1n;
          return this.s > HALF;
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
        }
        toDERRawBytes() {
          return hexToBytes(this.toDERHex());
        }
        toDERHex() {
          const sHex = sliceDER(numberToHexUnpadded(this.s));
          const rHex = sliceDER(numberToHexUnpadded(this.r));
          const sHexL = sHex.length / 2;
          const rHexL = rHex.length / 2;
          const sLen = numberToHexUnpadded(sHexL);
          const rLen = numberToHexUnpadded(rHexL);
          const length = numberToHexUnpadded(rHexL + sHexL + 4);
          return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
        }
        toRawBytes() {
          return this.toDERRawBytes();
        }
        toHex() {
          return this.toDERHex();
        }
        toCompactRawBytes() {
          return hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numTo32bStr(this.r) + numTo32bStr(this.s);
        }
      }
      exports.Signature = Signature;
      function concatBytes(...arrays) {
        if (!arrays.every(b => b instanceof Uint8Array)) throw new Error('Uint8Array list expected');
        if (arrays.length === 1) return arrays[0];
        const length = arrays.reduce((a, arr) => a + arr.length, 0);
        const result = new Uint8Array(length);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const arr = arrays[i];
          result.set(arr, pad);
          pad += arr.length;
        }
        return result;
      }
      const hexes = Array.from({
        length: 256
      }, (v, i) => i.toString(16).padStart(2, '0'));
      function bytesToHex(uint8a) {
        if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');
        let hex = '';
        for (let i = 0; i < uint8a.length; i++) {
          hex += hexes[uint8a[i]];
        }
        return hex;
      }
      const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
      function numTo32bStr(num) {
        if (typeof num !== 'bigint') throw new Error('Expected bigint');
        if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number 0 <= n < 2^256');
        return num.toString(16).padStart(64, '0');
      }
      function numTo32b(num) {
        const b = hexToBytes(numTo32bStr(num));
        if (b.length !== 32) throw new Error('Error: expected 32 bytes');
        return b;
      }
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      function hexToNumber(hex) {
        if (typeof hex !== 'string') {
          throw new TypeError('hexToNumber: expected string, got ' + typeof hex);
        }
        return BigInt(`0x${hex}`);
      }
      function hexToBytes(hex) {
        if (typeof hex !== 'string') {
          throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
        }
        if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
        const array = new Uint8Array(hex.length / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');
          array[i] = byte;
        }
        return array;
      }
      function bytesToNumber(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      function ensureBytes(hex) {
        return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
      }
      function normalizeScalar(num) {
        if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);
        if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;
        throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
      }
      function mod(a, b = CURVE.P) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      function pow2(x, power) {
        const {
          P
        } = CURVE;
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= P;
        }
        return res;
      }
      function sqrtMod(x) {
        const {
          P
        } = CURVE;
        const _6n = BigInt(6);
        const _11n = BigInt(11);
        const _22n = BigInt(22);
        const _23n = BigInt(23);
        const _44n = BigInt(44);
        const _88n = BigInt(88);
        const b2 = x * x * x % P;
        const b3 = b2 * b2 * x % P;
        const b6 = pow2(b3, _3n) * b3 % P;
        const b9 = pow2(b6, _3n) * b3 % P;
        const b11 = pow2(b9, _2n) * b2 % P;
        const b22 = pow2(b11, _11n) * b11 % P;
        const b44 = pow2(b22, _22n) * b22 % P;
        const b88 = pow2(b44, _44n) * b44 % P;
        const b176 = pow2(b88, _88n) * b88 % P;
        const b220 = pow2(b176, _44n) * b44 % P;
        const b223 = pow2(b220, _3n) * b3 % P;
        const t1 = pow2(b223, _23n) * b22 % P;
        const t2 = pow2(t1, _6n) * b2 % P;
        const rt = pow2(t2, _2n);
        const xc = rt * rt % P;
        if (xc !== x) throw new Error('Cannot find square root');
        return rt;
      }
      function invert(number, modulo = CURVE.P) {
        if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n,
          y = _1n,
          u = _1n,
          v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n) throw new Error('invert: does not exist');
        return mod(x, modulo);
      }
      function invertBatch(nums, p = CURVE.P) {
        const scratch = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (num === _0n) return acc;
          scratch[i] = acc;
          return mod(acc * num, p);
        }, _1n);
        const inverted = invert(lastMultiplied, p);
        nums.reduceRight((acc, num, i) => {
          if (num === _0n) return acc;
          scratch[i] = mod(acc * scratch[i], p);
          return mod(acc * num, p);
        }, inverted);
        return scratch;
      }
      function bits2int_2(bytes) {
        const delta = bytes.length * 8 - groupLen * 8;
        const num = bytesToNumber(bytes);
        return delta > 0 ? num >> BigInt(delta) : num;
      }
      function truncateHash(hash, truncateOnly = false) {
        const h = bits2int_2(hash);
        if (truncateOnly) return h;
        const {
          n
        } = CURVE;
        return h >= n ? h - n : h;
      }
      let _sha256Sync;
      let _hmacSha256Sync;
      class HmacDrbg {
        constructor(hashLen, qByteLen) {
          this.hashLen = hashLen;
          this.qByteLen = qByteLen;
          if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
          if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
          this.v = new Uint8Array(hashLen).fill(1);
          this.k = new Uint8Array(hashLen).fill(0);
          this.counter = 0;
        }
        hmac(...values) {
          return exports.utils.hmacSha256(this.k, ...values);
        }
        hmacSync(...values) {
          return _hmacSha256Sync(this.k, ...values);
        }
        checkSync() {
          if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');
        }
        incr() {
          if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');
          this.counter += 1;
        }
        async reseed(seed = new Uint8Array()) {
          this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);
          this.v = await this.hmac(this.v);
          if (seed.length === 0) return;
          this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);
          this.v = await this.hmac(this.v);
        }
        reseedSync(seed = new Uint8Array()) {
          this.checkSync();
          this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);
          this.v = this.hmacSync(this.v);
          if (seed.length === 0) return;
          this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);
          this.v = this.hmacSync(this.v);
        }
        async generate() {
          this.incr();
          let len = 0;
          const out = [];
          while (len < this.qByteLen) {
            this.v = await this.hmac(this.v);
            const sl = this.v.slice();
            out.push(sl);
            len += this.v.length;
          }
          return concatBytes(...out);
        }
        generateSync() {
          this.checkSync();
          this.incr();
          let len = 0;
          const out = [];
          while (len < this.qByteLen) {
            this.v = this.hmacSync(this.v);
            const sl = this.v.slice();
            out.push(sl);
            len += this.v.length;
          }
          return concatBytes(...out);
        }
      }
      function isWithinCurveOrder(num) {
        return _0n < num && num < CURVE.n;
      }
      function isValidFieldElement(num) {
        return _0n < num && num < CURVE.P;
      }
      function kmdToSig(kBytes, m, d, lowS = true) {
        const {
          n
        } = CURVE;
        const k = truncateHash(kBytes, true);
        if (!isWithinCurveOrder(k)) return;
        const kinv = invert(k, n);
        const q = Point.BASE.multiply(k);
        const r = mod(q.x, n);
        if (r === _0n) return;
        const s = mod(kinv * mod(m + d * r, n), n);
        if (s === _0n) return;
        let sig = new Signature(r, s);
        let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
        if (lowS && sig.hasHighS()) {
          sig = sig.normalizeS();
          recovery ^= 1;
        }
        return {
          sig,
          recovery
        };
      }
      function normalizePrivateKey(key) {
        let num;
        if (typeof key === 'bigint') {
          num = key;
        } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
          num = BigInt(key);
        } else if (typeof key === 'string') {
          if (key.length !== 2 * groupLen) throw new Error('Expected 32 bytes of private key');
          num = hexToNumber(key);
        } else if (key instanceof Uint8Array) {
          if (key.length !== groupLen) throw new Error('Expected 32 bytes of private key');
          num = bytesToNumber(key);
        } else {
          throw new TypeError('Expected valid private key');
        }
        if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');
        return num;
      }
      function normalizePublicKey(publicKey) {
        if (publicKey instanceof Point) {
          publicKey.assertValidity();
          return publicKey;
        } else {
          return Point.fromHex(publicKey);
        }
      }
      function normalizeSignature(signature) {
        if (signature instanceof Signature) {
          signature.assertValidity();
          return signature;
        }
        try {
          return Signature.fromDER(signature);
        } catch (error) {
          return Signature.fromCompact(signature);
        }
      }
      function getPublicKey(privateKey, isCompressed = false) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      exports.getPublicKey = getPublicKey;
      function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
        return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
      }
      exports.recoverPublicKey = recoverPublicKey;
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr) return len === compressedLen || len === uncompressedLen;
        if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;
        if (item instanceof Point) return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = false) {
        if (isProbPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');
        if (!isProbPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');
        const b = normalizePublicKey(publicB);
        b.assertValidity();
        return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
      }
      exports.getSharedSecret = getSharedSecret;
      function bits2int(bytes) {
        const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
        return bytesToNumber(slice);
      }
      function bits2octets(bytes) {
        const z1 = bits2int(bytes);
        const z2 = mod(z1, CURVE.n);
        return int2octets(z2 < _0n ? z1 : z2);
      }
      function int2octets(num) {
        return numTo32b(num);
      }
      function initSigArgs(msgHash, privateKey, extraEntropy) {
        if (msgHash == null) throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
        const h1 = ensureBytes(msgHash);
        const d = normalizePrivateKey(privateKey);
        const seedArgs = [int2octets(d), bits2octets(h1)];
        if (extraEntropy != null) {
          if (extraEntropy === true) extraEntropy = exports.utils.randomBytes(fieldLen);
          const e = ensureBytes(extraEntropy);
          if (e.length !== fieldLen) throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
          seedArgs.push(e);
        }
        const seed = concatBytes(...seedArgs);
        const m = bits2int(h1);
        return {
          seed,
          m,
          d
        };
      }
      function finalizeSig(recSig, opts) {
        const {
          sig,
          recovery
        } = recSig;
        const {
          der,
          recovered
        } = Object.assign({
          canonical: true,
          der: true
        }, opts);
        const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
        return recovered ? [hashed, recovery] : hashed;
      }
      async function sign(msgHash, privKey, opts = {}) {
        const {
          seed,
          m,
          d
        } = initSigArgs(msgHash, privKey, opts.extraEntropy);
        const drbg = new HmacDrbg(hashLen, groupLen);
        await drbg.reseed(seed);
        let sig;
        while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical))) await drbg.reseed();
        return finalizeSig(sig, opts);
      }
      exports.sign = sign;
      function signSync(msgHash, privKey, opts = {}) {
        const {
          seed,
          m,
          d
        } = initSigArgs(msgHash, privKey, opts.extraEntropy);
        const drbg = new HmacDrbg(hashLen, groupLen);
        drbg.reseedSync(seed);
        let sig;
        while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical))) drbg.reseedSync();
        return finalizeSig(sig, opts);
      }
      exports.signSync = signSync;
      const vopts = {
        strict: true
      };
      function verify(signature, msgHash, publicKey, opts = vopts) {
        let sig;
        try {
          sig = normalizeSignature(signature);
          msgHash = ensureBytes(msgHash);
        } catch (error) {
          return false;
        }
        const {
          r,
          s
        } = sig;
        if (opts.strict && sig.hasHighS()) return false;
        const h = truncateHash(msgHash);
        let P;
        try {
          P = normalizePublicKey(publicKey);
        } catch (error) {
          return false;
        }
        const {
          n
        } = CURVE;
        const sinv = invert(s, n);
        const u1 = mod(h * sinv, n);
        const u2 = mod(r * sinv, n);
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
        if (!R) return false;
        const v = mod(R.x, n);
        return v === r;
      }
      exports.verify = verify;
      function schnorrChallengeFinalize(ch) {
        return mod(bytesToNumber(ch), CURVE.n);
      }
      class SchnorrSignature {
        constructor(r, s) {
          this.r = r;
          this.s = s;
          this.assertValidity();
        }
        static fromHex(hex) {
          const bytes = ensureBytes(hex);
          if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
          const r = bytesToNumber(bytes.subarray(0, 32));
          const s = bytesToNumber(bytes.subarray(32, 64));
          return new SchnorrSignature(r, s);
        }
        assertValidity() {
          const {
            r,
            s
          } = this;
          if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');
        }
        toHex() {
          return numTo32bStr(this.r) + numTo32bStr(this.s);
        }
        toRawBytes() {
          return hexToBytes(this.toHex());
        }
      }
      function schnorrGetPublicKey(privateKey) {
        return Point.fromPrivateKey(privateKey).toRawX();
      }
      class InternalSchnorrSignature {
        constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {
          if (message == null) throw new TypeError(`sign: Expected valid message, not "${message}"`);
          this.m = ensureBytes(message);
          const {
            x,
            scalar
          } = this.getScalar(normalizePrivateKey(privateKey));
          this.px = x;
          this.d = scalar;
          this.rand = ensureBytes(auxRand);
          if (this.rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');
        }
        getScalar(priv) {
          const point = Point.fromPrivateKey(priv);
          const scalar = point.hasEvenY() ? priv : CURVE.n - priv;
          return {
            point,
            scalar,
            x: point.toRawX()
          };
        }
        initNonce(d, t0h) {
          return numTo32b(d ^ bytesToNumber(t0h));
        }
        finalizeNonce(k0h) {
          const k0 = mod(bytesToNumber(k0h), CURVE.n);
          if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');
          const {
            point: R,
            x: rx,
            scalar: k
          } = this.getScalar(k0);
          return {
            R,
            rx,
            k
          };
        }
        finalizeSig(R, k, e, d) {
          return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
        }
        error() {
          throw new Error('sign: Invalid signature produced');
        }
        async calc() {
          const {
            m,
            d,
            px,
            rand
          } = this;
          const tag = exports.utils.taggedHash;
          const t = this.initNonce(d, await tag(TAGS.aux, rand));
          const {
            R,
            rx,
            k
          } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));
          const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));
          const sig = this.finalizeSig(R, k, e, d);
          if (!(await schnorrVerify(sig, m, px))) this.error();
          return sig;
        }
        calcSync() {
          const {
            m,
            d,
            px,
            rand
          } = this;
          const tag = exports.utils.taggedHashSync;
          const t = this.initNonce(d, tag(TAGS.aux, rand));
          const {
            R,
            rx,
            k
          } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));
          const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));
          const sig = this.finalizeSig(R, k, e, d);
          if (!schnorrVerifySync(sig, m, px)) this.error();
          return sig;
        }
      }
      async function schnorrSign(msg, privKey, auxRand) {
        return new InternalSchnorrSignature(msg, privKey, auxRand).calc();
      }
      function schnorrSignSync(msg, privKey, auxRand) {
        return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
      }
      function initSchnorrVerify(signature, message, publicKey) {
        const raw = signature instanceof SchnorrSignature;
        const sig = raw ? signature : SchnorrSignature.fromHex(signature);
        if (raw) sig.assertValidity();
        return {
          ...sig,
          m: ensureBytes(message),
          P: normalizePublicKey(publicKey)
        };
      }
      function finalizeSchnorrVerify(r, P, s, e) {
        const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
        if (!R || !R.hasEvenY() || R.x !== r) return false;
        return true;
      }
      async function schnorrVerify(signature, message, publicKey) {
        try {
          const {
            r,
            s,
            m,
            P
          } = initSchnorrVerify(signature, message, publicKey);
          const e = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
          return finalizeSchnorrVerify(r, P, s, e);
        } catch (error) {
          return false;
        }
      }
      function schnorrVerifySync(signature, message, publicKey) {
        try {
          const {
            r,
            s,
            m,
            P
          } = initSchnorrVerify(signature, message, publicKey);
          const e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
          return finalizeSchnorrVerify(r, P, s, e);
        } catch (error) {
          if (error instanceof ShaError) throw error;
          return false;
        }
      }
      exports.schnorr = {
        Signature: SchnorrSignature,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        signSync: schnorrSignSync,
        verifySync: schnorrVerifySync
      };
      Point.BASE._setWindowSize(8);
      const crypto = {
        node: nodeCrypto,
        web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined
      };
      const TAGS = {
        challenge: 'BIP0340/challenge',
        aux: 'BIP0340/aux',
        nonce: 'BIP0340/nonce'
      };
      const TAGGED_HASH_PREFIXES = {};
      exports.utils = {
        bytesToHex,
        hexToBytes,
        concatBytes,
        mod,
        invert,
        isValidPrivateKey(privateKey) {
          try {
            normalizePrivateKey(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        _bigintTo32Bytes: numTo32b,
        _normalizePrivateKey: normalizePrivateKey,
        hashToPrivateKey: hash => {
          hash = ensureBytes(hash);
          const minLen = groupLen + 8;
          if (hash.length < minLen || hash.length > 1024) {
            throw new Error(`Expected valid bytes of private key as per FIPS 186`);
          }
          const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
          return numTo32b(num);
        },
        randomBytes: (bytesLength = 32) => {
          if (crypto.web) {
            return crypto.web.getRandomValues(new Uint8Array(bytesLength));
          } else if (crypto.node) {
            const {
              randomBytes
            } = crypto.node;
            return Uint8Array.from(randomBytes(bytesLength));
          } else {
            throw new Error("The environment doesn't have randomBytes function");
          }
        },
        randomPrivateKey: () => exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8)),
        precompute(windowSize = 8, point = Point.BASE) {
          const cached = point === Point.BASE ? point : new Point(point.x, point.y);
          cached._setWindowSize(windowSize);
          cached.multiply(_3n);
          return cached;
        },
        sha256: async (...messages) => {
          if (crypto.web) {
            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));
            return new Uint8Array(buffer);
          } else if (crypto.node) {
            const {
              createHash
            } = crypto.node;
            const hash = createHash('sha256');
            messages.forEach(m => hash.update(m));
            return Uint8Array.from(hash.digest());
          } else {
            throw new Error("The environment doesn't have sha256 function");
          }
        },
        hmacSha256: async (key, ...messages) => {
          if (crypto.web) {
            const ckey = await crypto.web.subtle.importKey('raw', key, {
              name: 'HMAC',
              hash: {
                name: 'SHA-256'
              }
            }, false, ['sign']);
            const message = concatBytes(...messages);
            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);
            return new Uint8Array(buffer);
          } else if (crypto.node) {
            const {
              createHmac
            } = crypto.node;
            const hash = createHmac('sha256', key);
            messages.forEach(m => hash.update(m));
            return Uint8Array.from(hash.digest());
          } else {
            throw new Error("The environment doesn't have hmac-sha256 function");
          }
        },
        sha256Sync: undefined,
        hmacSha256Sync: undefined,
        taggedHash: async (tag, ...messages) => {
          let tagP = TAGGED_HASH_PREFIXES[tag];
          if (tagP === undefined) {
            const tagH = await exports.utils.sha256(Uint8Array.from(tag, c => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
          }
          return exports.utils.sha256(tagP, ...messages);
        },
        taggedHashSync: (tag, ...messages) => {
          if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');
          let tagP = TAGGED_HASH_PREFIXES[tag];
          if (tagP === undefined) {
            const tagH = _sha256Sync(Uint8Array.from(tag, c => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
          }
          return _sha256Sync(tagP, ...messages);
        },
        _JacobianPoint: JacobianPoint
      };
      Object.defineProperties(exports.utils, {
        sha256Sync: {
          configurable: false,
          get() {
            return _sha256Sync;
          },
          set(val) {
            if (!_sha256Sync) _sha256Sync = val;
          }
        },
        hmacSha256Sync: {
          configurable: false,
          get() {
            return _hmacSha256Sync;
          },
          set(val) {
            if (!_hmacSha256Sync) _hmacSha256Sync = val;
          }
        }
      });
    },
    1696: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      function _typeof(o) {
        "@babel/helpers - typeof";

        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
          return typeof o;
        } : function (o) {
          return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
        }, _typeof(o);
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== undefined) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _require = __webpack_require__(7515),
        _require$codes = _require.codes,
        ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
        ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
        ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
        ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var AssertionError = __webpack_require__(4082);
      var _require2 = __webpack_require__(3335),
        inspect = _require2.inspect;
      var _require$types = __webpack_require__(3335).types,
        isPromise = _require$types.isPromise,
        isRegExp = _require$types.isRegExp;
      var objectAssign = __webpack_require__(3347)();
      var objectIs = __webpack_require__(8070)();
      var RegExpPrototypeTest = __webpack_require__(2680)('RegExp.prototype.test');
      var errorCache = new Map();
      var isDeepEqual;
      var isDeepStrictEqual;
      var parseExpressionAt;
      var findNodeAround;
      var decoder;
      function lazyLoadComparison() {
        var comparison = __webpack_require__(6796);
        isDeepEqual = comparison.isDeepEqual;
        isDeepStrictEqual = comparison.isDeepStrictEqual;
      }
      var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
      var meta = null && ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];
      var escapeFn = function escapeFn(str) {
        return meta[str.charCodeAt(0)];
      };
      var warned = false;
      var assert = module.exports = ok;
      var NO_EXCEPTION_SENTINEL = {};
      function innerFail(obj) {
        if (obj.message instanceof Error) throw obj.message;
        throw new AssertionError(obj);
      }
      function fail(actual, expected, message, operator, stackStartFn) {
        var argsLen = arguments.length;
        var internalMessage;
        if (argsLen === 0) {
          internalMessage = 'Failed';
        } else if (argsLen === 1) {
          message = actual;
          actual = undefined;
        } else {
          if (warned === false) {
            warned = true;
            var warn = {
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.emitWarning ? {
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.emitWarning : console.warn.bind(console);
            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
          }
          if (argsLen === 2) operator = '!=';
        }
        if (message instanceof Error) throw message;
        var errArgs = {
          actual: actual,
          expected: expected,
          operator: operator === undefined ? 'fail' : operator,
          stackStartFn: stackStartFn || fail
        };
        if (message !== undefined) {
          errArgs.message = message;
        }
        var err = new AssertionError(errArgs);
        if (internalMessage) {
          err.message = internalMessage;
          err.generatedMessage = true;
        }
        throw err;
      }
      assert.fail = fail;
      assert.AssertionError = AssertionError;
      function innerOk(fn, argLen, value, message) {
        if (!value) {
          var generatedMessage = false;
          if (argLen === 0) {
            generatedMessage = true;
            message = 'No value argument passed to `assert.ok()`';
          } else if (message instanceof Error) {
            throw message;
          }
          var err = new AssertionError({
            actual: value,
            expected: true,
            message: message,
            operator: '==',
            stackStartFn: fn
          });
          err.generatedMessage = generatedMessage;
          throw err;
        }
      }
      function ok() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        innerOk.apply(void 0, [ok, args.length].concat(args));
      }
      assert.ok = ok;
      assert.equal = function equal(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS('actual', 'expected');
        }
        if (actual != expected) {
          innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: '==',
            stackStartFn: equal
          });
        }
      };
      assert.notEqual = function notEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS('actual', 'expected');
        }
        if (actual == expected) {
          innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: '!=',
            stackStartFn: notEqual
          });
        }
      };
      assert.deepEqual = function deepEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS('actual', 'expected');
        }
        if (isDeepEqual === undefined) lazyLoadComparison();
        if (!isDeepEqual(actual, expected)) {
          innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: 'deepEqual',
            stackStartFn: deepEqual
          });
        }
      };
      assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS('actual', 'expected');
        }
        if (isDeepEqual === undefined) lazyLoadComparison();
        if (isDeepEqual(actual, expected)) {
          innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: 'notDeepEqual',
            stackStartFn: notDeepEqual
          });
        }
      };
      assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS('actual', 'expected');
        }
        if (isDeepEqual === undefined) lazyLoadComparison();
        if (!isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: 'deepStrictEqual',
            stackStartFn: deepStrictEqual
          });
        }
      };
      assert.notDeepStrictEqual = notDeepStrictEqual;
      function notDeepStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS('actual', 'expected');
        }
        if (isDeepEqual === undefined) lazyLoadComparison();
        if (isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: 'notDeepStrictEqual',
            stackStartFn: notDeepStrictEqual
          });
        }
      }
      assert.strictEqual = function strictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS('actual', 'expected');
        }
        if (!objectIs(actual, expected)) {
          innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: 'strictEqual',
            stackStartFn: strictEqual
          });
        }
      };
      assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS('actual', 'expected');
        }
        if (objectIs(actual, expected)) {
          innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: 'notStrictEqual',
            stackStartFn: notStrictEqual
          });
        }
      };
      var Comparison = _createClass(function Comparison(obj, keys, actual) {
        var _this = this;
        _classCallCheck(this, Comparison);
        keys.forEach(function (key) {
          if (key in obj) {
            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
              _this[key] = actual[key];
            } else {
              _this[key] = obj[key];
            }
          }
        });
      });
      function compareExceptionKey(actual, expected, key, message, keys, fn) {
        if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
          if (!message) {
            var a = new Comparison(actual, keys);
            var b = new Comparison(expected, keys, actual);
            var err = new AssertionError({
              actual: a,
              expected: b,
              operator: 'deepStrictEqual',
              stackStartFn: fn
            });
            err.actual = actual;
            err.expected = expected;
            err.operator = fn.name;
            throw err;
          }
          innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: fn.name,
            stackStartFn: fn
          });
        }
      }
      function expectedException(actual, expected, msg, fn) {
        if (typeof expected !== 'function') {
          if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
          if (arguments.length === 2) {
            throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
          }
          if (_typeof(actual) !== 'object' || actual === null) {
            var err = new AssertionError({
              actual: actual,
              expected: expected,
              message: msg,
              operator: 'deepStrictEqual',
              stackStartFn: fn
            });
            err.operator = fn.name;
            throw err;
          }
          var keys = Object.keys(expected);
          if (expected instanceof Error) {
            keys.push('name', 'message');
          } else if (keys.length === 0) {
            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
          }
          if (isDeepEqual === undefined) lazyLoadComparison();
          keys.forEach(function (key) {
            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
              return;
            }
            compareExceptionKey(actual, expected, key, msg, keys, fn);
          });
          return true;
        }
        if (expected.prototype !== undefined && actual instanceof expected) {
          return true;
        }
        if (Error.isPrototypeOf(expected)) {
          return false;
        }
        return expected.call({}, actual) === true;
      }
      function getActual(fn) {
        if (typeof fn !== 'function') {
          throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
        }
        try {
          fn();
        } catch (e) {
          return e;
        }
        return NO_EXCEPTION_SENTINEL;
      }
      function checkIsPromise(obj) {
        return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
      }
      function waitForActual(promiseFn) {
        return Promise.resolve().then(function () {
          var resultPromise;
          if (typeof promiseFn === 'function') {
            resultPromise = promiseFn();
            if (!checkIsPromise(resultPromise)) {
              throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
            }
          } else if (checkIsPromise(promiseFn)) {
            resultPromise = promiseFn;
          } else {
            throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
          }
          return Promise.resolve().then(function () {
            return resultPromise;
          }).then(function () {
            return NO_EXCEPTION_SENTINEL;
          }).catch(function (e) {
            return e;
          });
        });
      }
      function expectsError(stackStartFn, actual, error, message) {
        if (typeof error === 'string') {
          if (arguments.length === 4) {
            throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
          }
          if (_typeof(actual) === 'object' && actual !== null) {
            if (actual.message === error) {
              throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
            }
          } else if (actual === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
          }
          message = error;
          error = undefined;
        } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
          throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
        }
        if (actual === NO_EXCEPTION_SENTINEL) {
          var details = '';
          if (error && error.name) {
            details += " (".concat(error.name, ")");
          }
          details += message ? ": ".concat(message) : '.';
          var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
          innerFail({
            actual: undefined,
            expected: error,
            operator: stackStartFn.name,
            message: "Missing expected ".concat(fnType).concat(details),
            stackStartFn: stackStartFn
          });
        }
        if (error && !expectedException(actual, error, message, stackStartFn)) {
          throw actual;
        }
      }
      function expectsNoError(stackStartFn, actual, error, message) {
        if (actual === NO_EXCEPTION_SENTINEL) return;
        if (typeof error === 'string') {
          message = error;
          error = undefined;
        }
        if (!error || expectedException(actual, error)) {
          var details = message ? ": ".concat(message) : '.';
          var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
          innerFail({
            actual: actual,
            expected: error,
            operator: stackStartFn.name,
            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
            stackStartFn: stackStartFn
          });
        }
        throw actual;
      }
      assert.throws = function throws(promiseFn) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
      };
      assert.rejects = function rejects(promiseFn) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        return waitForActual(promiseFn).then(function (result) {
          return expectsError.apply(void 0, [rejects, result].concat(args));
        });
      };
      assert.doesNotThrow = function doesNotThrow(fn) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
      };
      assert.doesNotReject = function doesNotReject(fn) {
        for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          args[_key5 - 1] = arguments[_key5];
        }
        return waitForActual(fn).then(function (result) {
          return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
        });
      };
      assert.ifError = function ifError(err) {
        if (err !== null && err !== undefined) {
          var message = 'ifError got unwanted exception: ';
          if (_typeof(err) === 'object' && typeof err.message === 'string') {
            if (err.message.length === 0 && err.constructor) {
              message += err.constructor.name;
            } else {
              message += err.message;
            }
          } else {
            message += inspect(err);
          }
          var newErr = new AssertionError({
            actual: err,
            expected: null,
            operator: 'ifError',
            message: message,
            stackStartFn: ifError
          });
          var origStack = err.stack;
          if (typeof origStack === 'string') {
            var tmp2 = origStack.split('\n');
            tmp2.shift();
            var tmp1 = newErr.stack.split('\n');
            for (var i = 0; i < tmp2.length; i++) {
              var pos = tmp1.indexOf(tmp2[i]);
              if (pos !== -1) {
                tmp1 = tmp1.slice(0, pos);
                break;
              }
            }
            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
          }
          throw newErr;
        }
      };
      function internalMatch(string, regexp, message, fn, fnName) {
        if (!isRegExp(regexp)) {
          throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);
        }
        var match = fnName === 'match';
        if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {
          if (message instanceof Error) {
            throw message;
          }
          var generatedMessage = !message;
          message = message || (typeof string !== 'string' ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
          var err = new AssertionError({
            actual: string,
            expected: regexp,
            message: message,
            operator: fnName,
            stackStartFn: fn
          });
          err.generatedMessage = generatedMessage;
          throw err;
        }
      }
      assert.match = function match(string, regexp, message) {
        internalMatch(string, regexp, message, match, 'match');
      };
      assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
        internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');
      };
      function strict() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        innerOk.apply(void 0, [strict, args.length].concat(args));
      }
      assert.strict = objectAssign(strict, assert, {
        equal: assert.strictEqual,
        deepEqual: assert.deepStrictEqual,
        notEqual: assert.notStrictEqual,
        notDeepEqual: assert.notDeepStrictEqual
      });
      assert.strict.strict = assert.strict;
    },
    4082: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function (r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
            _defineProperty(e, r, t[r]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
          });
        }
        return e;
      }
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== undefined) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        Object.defineProperty(subClass, "prototype", {
          writable: false
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
            result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized(self);
      }
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? new Map() : undefined;
        _wrapNativeSuper = function _wrapNativeSuper(Class) {
          if (Class === null || !_isNativeFunction(Class)) return Class;
          if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
          }
          function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class);
        };
        return _wrapNativeSuper(Class);
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
        return _setPrototypeOf(o, p);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      function _typeof(o) {
        "@babel/helpers - typeof";

        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
          return typeof o;
        } : function (o) {
          return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
        }, _typeof(o);
      }
      var _require = __webpack_require__(3335),
        inspect = _require.inspect;
      var _require2 = __webpack_require__(7515),
        ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
      function endsWith(str, search, this_len) {
        if (this_len === undefined || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function repeat(str, count) {
        count = Math.floor(count);
        if (str.length == 0 || count == 0) return '';
        var maxCount = str.length * count;
        count = Math.floor(Math.log(count) / Math.log(2));
        while (count) {
          str += str;
          count--;
        }
        str += str.substring(0, maxCount - str.length);
        return str;
      }
      var blue = '';
      var green = '';
      var red = '';
      var white = '';
      var kReadableOperator = {
        deepStrictEqual: 'Expected values to be strictly deep-equal:',
        strictEqual: 'Expected values to be strictly equal:',
        strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
        deepEqual: 'Expected values to be loosely deep-equal:',
        equal: 'Expected values to be loosely equal:',
        notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
        notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
        notEqual: 'Expected "actual" to be loosely unequal to:',
        notIdentical: 'Values identical but not reference-equal:'
      };
      var kMaxShortLength = 10;
      function copyError(source) {
        var keys = Object.keys(source);
        var target = Object.create(Object.getPrototypeOf(source));
        keys.forEach(function (key) {
          target[key] = source[key];
        });
        Object.defineProperty(target, 'message', {
          value: source.message
        });
        return target;
      }
      function inspectValue(val) {
        return inspect(val, {
          compact: false,
          customInspect: false,
          depth: 1000,
          maxArrayLength: Infinity,
          showHidden: false,
          breakLength: Infinity,
          showProxy: false,
          sorted: true,
          getters: true
        });
      }
      function createErrDiff(actual, expected, operator) {
        var other = '';
        var res = '';
        var lastPos = 0;
        var end = '';
        var skipped = false;
        var actualInspected = inspectValue(actual);
        var actualLines = actualInspected.split('\n');
        var expectedLines = inspectValue(expected).split('\n');
        var i = 0;
        var indicator = '';
        if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
          operator = 'strictEqualObject';
        }
        if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
          var inputLength = actualLines[0].length + expectedLines[0].length;
          if (inputLength <= kMaxShortLength) {
            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
              return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
            }
          } else if (operator !== 'strictEqualObject') {
            var maxLength = {
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.stderr && {
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.stderr.isTTY ? {
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.stderr.columns : 80;
            if (inputLength < maxLength) {
              while (actualLines[0][i] === expectedLines[0][i]) {
                i++;
              }
              if (i > 2) {
                indicator = "\n  ".concat(repeat(' ', i), "^");
                i = 0;
              }
            }
          }
        }
        var a = actualLines[actualLines.length - 1];
        var b = expectedLines[expectedLines.length - 1];
        while (a === b) {
          if (i++ < 2) {
            end = "\n  ".concat(a).concat(end);
          } else {
            other = a;
          }
          actualLines.pop();
          expectedLines.pop();
          if (actualLines.length === 0 || expectedLines.length === 0) break;
          a = actualLines[actualLines.length - 1];
          b = expectedLines[expectedLines.length - 1];
        }
        var maxLines = Math.max(actualLines.length, expectedLines.length);
        if (maxLines === 0) {
          var _actualLines = actualInspected.split('\n');
          if (_actualLines.length > 30) {
            _actualLines[26] = "".concat(blue, "...").concat(white);
            while (_actualLines.length > 27) {
              _actualLines.pop();
            }
          }
          return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
        }
        if (i > 3) {
          end = "\n".concat(blue, "...").concat(white).concat(end);
          skipped = true;
        }
        if (other !== '') {
          end = "\n  ".concat(other).concat(end);
          other = '';
        }
        var printedLines = 0;
        var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
        var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
        for (i = 0; i < maxLines; i++) {
          var cur = i - lastPos;
          if (actualLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(expectedLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(expectedLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
            printedLines++;
          } else if (expectedLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
            printedLines++;
          } else {
            var expectedLine = expectedLines[i];
            var actualLine = actualLines[i];
            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);
            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
              divergingLines = false;
              actualLine += ',';
            }
            if (divergingLines) {
              if (cur > 1 && i > 2) {
                if (cur > 4) {
                  res += "\n".concat(blue, "...").concat(white);
                  skipped = true;
                } else if (cur > 3) {
                  res += "\n  ".concat(actualLines[i - 2]);
                  printedLines++;
                }
                res += "\n  ".concat(actualLines[i - 1]);
                printedLines++;
              }
              lastPos = i;
              res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
              other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
              printedLines += 2;
            } else {
              res += other;
              other = '';
              if (cur === 1 || i === 0) {
                res += "\n  ".concat(actualLine);
                printedLines++;
              }
            }
          }
          if (printedLines > 20 && i < maxLines - 2) {
            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
          }
        }
        return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
      }
      var AssertionError = function (_Error, _inspect$custom) {
        _inherits(AssertionError, _Error);
        var _super = _createSuper(AssertionError);
        function AssertionError(options) {
          var _this;
          _classCallCheck(this, AssertionError);
          if (_typeof(options) !== 'object' || options === null) {
            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
          }
          var message = options.message,
            operator = options.operator,
            stackStartFn = options.stackStartFn;
          var actual = options.actual,
            expected = options.expected;
          var limit = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          if (message != null) {
            _this = _super.call(this, String(message));
          } else {
            if ({
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.stderr && {
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.stderr.isTTY) {
              if ({
                "browser": true,
                "env": {},
                "versions": {
                  "node": "v16.20.0"
                }
              }.stderr && {
                "browser": true,
                "env": {},
                "versions": {
                  "node": "v16.20.0"
                }
              }.stderr.getColorDepth && {
                "browser": true,
                "env": {},
                "versions": {
                  "node": "v16.20.0"
                }
              }.stderr.getColorDepth() !== 1) {
                blue = "\x1B[34m";
                green = "\x1B[32m";
                white = "\x1B[39m";
                red = "\x1B[31m";
              } else {
                blue = '';
                green = '';
                white = '';
                red = '';
              }
            }
            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
              actual = copyError(actual);
              expected = copyError(expected);
            }
            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
              _this = _super.call(this, createErrDiff(actual, expected, operator));
            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
              var base = kReadableOperator[operator];
              var res = inspectValue(actual).split('\n');
              if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                base = kReadableOperator.notStrictEqualObject;
              }
              if (res.length > 30) {
                res[26] = "".concat(blue, "...").concat(white);
                while (res.length > 27) {
                  res.pop();
                }
              }
              if (res.length === 1) {
                _this = _super.call(this, "".concat(base, " ").concat(res[0]));
              } else {
                _this = _super.call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n"));
              }
            } else {
              var _res = inspectValue(actual);
              var other = '';
              var knownOperators = kReadableOperator[operator];
              if (operator === 'notDeepEqual' || operator === 'notEqual') {
                _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                if (_res.length > 1024) {
                  _res = "".concat(_res.slice(0, 1021), "...");
                }
              } else {
                other = "".concat(inspectValue(expected));
                if (_res.length > 512) {
                  _res = "".concat(_res.slice(0, 509), "...");
                }
                if (other.length > 512) {
                  other = "".concat(other.slice(0, 509), "...");
                }
                if (operator === 'deepEqual' || operator === 'equal') {
                  _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                } else {
                  other = " ".concat(operator, " ").concat(other);
                }
              }
              _this = _super.call(this, "".concat(_res).concat(other));
            }
          }
          Error.stackTraceLimit = limit;
          _this.generatedMessage = !message;
          Object.defineProperty(_assertThisInitialized(_this), 'name', {
            value: 'AssertionError [ERR_ASSERTION]',
            enumerable: false,
            writable: true,
            configurable: true
          });
          _this.code = 'ERR_ASSERTION';
          _this.actual = actual;
          _this.expected = expected;
          _this.operator = operator;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
          }
          _this.stack;
          _this.name = 'AssertionError';
          return _possibleConstructorReturn(_this);
        }
        _createClass(AssertionError, [{
          key: "toString",
          value: function toString() {
            return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
          }
        }, {
          key: _inspect$custom,
          value: function value(recurseTimes, ctx) {
            return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
              customInspect: false,
              depth: 0
            }));
          }
        }]);
        return AssertionError;
      }(_wrapNativeSuper(Error), inspect.custom);
      module.exports = AssertionError;
    },
    7515: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      function _typeof(o) {
        "@babel/helpers - typeof";

        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
          return typeof o;
        } : function (o) {
          return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
        }, _typeof(o);
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== undefined) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        Object.defineProperty(subClass, "prototype", {
          writable: false
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
            result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized(self);
      }
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      var codes = {};
      var assert;
      var util;
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === 'string') {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = function (_Base) {
          _inherits(NodeError, _Base);
          var _super = _createSuper(NodeError);
          function NodeError(arg1, arg2, arg3) {
            var _this;
            _classCallCheck(this, NodeError);
            _this = _super.call(this, getMessage(arg1, arg2, arg3));
            _this.code = code;
            return _this;
          }
          return _createClass(NodeError);
        }(Base);
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function (i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === undefined || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== 'number') {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
      createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
        if (assert === undefined) assert = __webpack_require__(1696);
        assert(typeof name === 'string', "'name' must be a string");
        var determiner;
        if (typeof expected === 'string' && startsWith(expected, 'not ')) {
          determiner = 'must not be';
          expected = expected.replace(/^not /, '');
        } else {
          determiner = 'must be';
        }
        var msg;
        if (endsWith(name, ' argument')) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
        } else {
          var type = includes(name, '.') ? 'property' : 'argument';
          msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
        }
        msg += ". Received type ".concat(_typeof(actual));
        return msg;
      }, TypeError);
      createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
        var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
        if (util === undefined) util = __webpack_require__(3335);
        var inspected = util.inspect(value);
        if (inspected.length > 128) {
          inspected = "".concat(inspected.slice(0, 128), "...");
        }
        return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
      }, TypeError, RangeError);
      createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
        var type;
        if (value && value.constructor && value.constructor.name) {
          type = "instance of ".concat(value.constructor.name);
        } else {
          type = "type ".concat(_typeof(value));
        }
        return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
      }, TypeError);
      createErrorType('ERR_MISSING_ARGS', function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (assert === undefined) assert = __webpack_require__(1696);
        assert(args.length > 0, 'At least one arg needs to be specified');
        var msg = 'The ';
        var len = args.length;
        args = args.map(function (a) {
          return "\"".concat(a, "\"");
        });
        switch (len) {
          case 1:
            msg += "".concat(args[0], " argument");
            break;
          case 2:
            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
            break;
          default:
            msg += args.slice(0, len - 1).join(', ');
            msg += ", and ".concat(args[len - 1], " arguments");
            break;
        }
        return "".concat(msg, " must be specified");
      }, TypeError);
      module.exports.codes = codes;
    },
    6796: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _iterableToArrayLimit(r, l) {
        var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (null != t) {
          var e,
            n,
            i,
            u,
            a = [],
            f = !0,
            o = !1;
          try {
            if (i = (t = t.call(r)).next, 0 === l) {
              if (Object(t) !== t) return;
              f = !1;
            } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
          } catch (r) {
            o = !0, n = r;
          } finally {
            try {
              if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
            } finally {
              if (o) throw n;
            }
          }
          return a;
        }
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _typeof(o) {
        "@babel/helpers - typeof";

        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
          return typeof o;
        } : function (o) {
          return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
        }, _typeof(o);
      }
      var regexFlagsSupported = /a/g.flags !== undefined;
      var arrayFromSet = function arrayFromSet(set) {
        var array = [];
        set.forEach(function (value) {
          return array.push(value);
        });
        return array;
      };
      var arrayFromMap = function arrayFromMap(map) {
        var array = [];
        map.forEach(function (value, key) {
          return array.push([key, value]);
        });
        return array;
      };
      var objectIs = Object.is ? Object.is : __webpack_require__(4679);
      var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
        return [];
      };
      var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(4782);
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
      var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
      var objectToString = uncurryThis(Object.prototype.toString);
      var _require$types = __webpack_require__(3335).types,
        isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
        isArrayBufferView = _require$types.isArrayBufferView,
        isDate = _require$types.isDate,
        isMap = _require$types.isMap,
        isRegExp = _require$types.isRegExp,
        isSet = _require$types.isSet,
        isNativeError = _require$types.isNativeError,
        isBoxedPrimitive = _require$types.isBoxedPrimitive,
        isNumberObject = _require$types.isNumberObject,
        isStringObject = _require$types.isStringObject,
        isBooleanObject = _require$types.isBooleanObject,
        isBigIntObject = _require$types.isBigIntObject,
        isSymbolObject = _require$types.isSymbolObject,
        isFloat32Array = _require$types.isFloat32Array,
        isFloat64Array = _require$types.isFloat64Array;
      function isNonIndex(key) {
        if (key.length === 0 || key.length > 10) return true;
        for (var i = 0; i < key.length; i++) {
          var code = key.charCodeAt(i);
          if (code < 48 || code > 57) return true;
        }
        return key.length === 10 && key >= Math.pow(2, 32);
      }
      function getOwnNonIndexProperties(value) {
        return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
      }
      function compare(a, b) {
        if (a === b) {
          return 0;
        }
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) {
          return -1;
        }
        if (y < x) {
          return 1;
        }
        return 0;
      }
      var ONLY_ENUMERABLE = undefined;
      var kStrict = true;
      var kLoose = false;
      var kNoIterator = 0;
      var kIsArray = 1;
      var kIsSet = 2;
      var kIsMap = 3;
      function areSimilarRegExps(a, b) {
        return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
      }
      function areSimilarFloatArrays(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        for (var offset = 0; offset < a.byteLength; offset++) {
          if (a[offset] !== b[offset]) {
            return false;
          }
        }
        return true;
      }
      function areSimilarTypedArrays(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
      }
      function areEqualArrayBuffers(buf1, buf2) {
        return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
      }
      function isEqualBoxedPrimitive(val1, val2) {
        if (isNumberObject(val1)) {
          return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
        }
        if (isStringObject(val1)) {
          return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
        }
        if (isBooleanObject(val1)) {
          return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
        }
        if (isBigIntObject(val1)) {
          return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
        }
        return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
      }
      function innerDeepEqual(val1, val2, strict, memos) {
        if (val1 === val2) {
          if (val1 !== 0) return true;
          return strict ? objectIs(val1, val2) : true;
        }
        if (strict) {
          if (_typeof(val1) !== 'object') {
            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
          }
          if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
            return false;
          }
          if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
          }
        } else {
          if (val1 === null || _typeof(val1) !== 'object') {
            if (val2 === null || _typeof(val2) !== 'object') {
              return val1 == val2;
            }
            return false;
          }
          if (val2 === null || _typeof(val2) !== 'object') {
            return false;
          }
        }
        var val1Tag = objectToString(val1);
        var val2Tag = objectToString(val2);
        if (val1Tag !== val2Tag) {
          return false;
        }
        if (Array.isArray(val1)) {
          if (val1.length !== val2.length) {
            return false;
          }
          var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
        }
        if (val1Tag === '[object Object]') {
          if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
            return false;
          }
        }
        if (isDate(val1)) {
          if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
            return false;
          }
        } else if (isRegExp(val1)) {
          if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
            return false;
          }
        } else if (isNativeError(val1) || val1 instanceof Error) {
          if (val1.message !== val2.message || val1.name !== val2.name) {
            return false;
          }
        } else if (isArrayBufferView(val1)) {
          if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
              return false;
            }
          } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
          }
          var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (_keys.length !== _keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
        } else if (isSet(val1)) {
          if (!isSet(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsSet);
        } else if (isMap(val1)) {
          if (!isMap(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsMap);
        } else if (isAnyArrayBuffer(val1)) {
          if (!areEqualArrayBuffers(val1, val2)) {
            return false;
          }
        } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator);
      }
      function getEnumerables(val, keys) {
        return keys.filter(function (k) {
          return propertyIsEnumerable(val, k);
        });
      }
      function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
        if (arguments.length === 5) {
          aKeys = Object.keys(val1);
          var bKeys = Object.keys(val2);
          if (aKeys.length !== bKeys.length) {
            return false;
          }
        }
        var i = 0;
        for (; i < aKeys.length; i++) {
          if (!hasOwnProperty(val2, aKeys[i])) {
            return false;
          }
        }
        if (strict && arguments.length === 5) {
          var symbolKeysA = objectGetOwnPropertySymbols(val1);
          if (symbolKeysA.length !== 0) {
            var count = 0;
            for (i = 0; i < symbolKeysA.length; i++) {
              var key = symbolKeysA[i];
              if (propertyIsEnumerable(val1, key)) {
                if (!propertyIsEnumerable(val2, key)) {
                  return false;
                }
                aKeys.push(key);
                count++;
              } else if (propertyIsEnumerable(val2, key)) {
                return false;
              }
            }
            var symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
              return false;
            }
          } else {
            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
              return false;
            }
          }
        }
        if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
          return true;
        }
        if (memos === undefined) {
          memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
          };
        } else {
          var val2MemoA = memos.val1.get(val1);
          if (val2MemoA !== undefined) {
            var val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
              return val2MemoA === val2MemoB;
            }
          }
          memos.position++;
        }
        memos.val1.set(val1, memos.position);
        memos.val2.set(val2, memos.position);
        var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
        memos.val1.delete(val1);
        memos.val2.delete(val2);
        return areEq;
      }
      function setHasEqualElement(set, val1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var val2 = setValues[i];
          if (innerDeepEqual(val1, val2, strict, memo)) {
            set.delete(val2);
            return true;
          }
        }
        return false;
      }
      function findLooseMatchingPrimitives(prim) {
        switch (_typeof(prim)) {
          case 'undefined':
            return null;
          case 'object':
            return undefined;
          case 'symbol':
            return false;
          case 'string':
            prim = +prim;
          case 'number':
            if (numberIsNaN(prim)) {
              return false;
            }
        }
        return true;
      }
      function setMightHaveLoosePrim(a, b, prim) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) return altValue;
        return b.has(altValue) && !a.has(altValue);
      }
      function mapMightHaveLoosePrim(a, b, prim, item, memo) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) {
          return altValue;
        }
        var curB = b.get(altValue);
        if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
          return false;
        }
        return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
      }
      function setEquiv(a, b, strict, memo) {
        var set = null;
        var aValues = arrayFromSet(a);
        for (var i = 0; i < aValues.length; i++) {
          var val = aValues[i];
          if (_typeof(val) === 'object' && val !== null) {
            if (set === null) {
              set = new Set();
            }
            set.add(val);
          } else if (!b.has(val)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(a, b, val)) {
              return false;
            }
            if (set === null) {
              set = new Set();
            }
            set.add(val);
          }
        }
        if (set !== null) {
          var bValues = arrayFromSet(b);
          for (var _i = 0; _i < bValues.length; _i++) {
            var _val = bValues[_i];
            if (_typeof(_val) === 'object' && _val !== null) {
              if (!setHasEqualElement(set, _val, strict, memo)) return false;
            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var key2 = setValues[i];
          if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
            set.delete(key2);
            return true;
          }
        }
        return false;
      }
      function mapEquiv(a, b, strict, memo) {
        var set = null;
        var aEntries = arrayFromMap(a);
        for (var i = 0; i < aEntries.length; i++) {
          var _aEntries$i = _slicedToArray(aEntries[i], 2),
            key = _aEntries$i[0],
            item1 = _aEntries$i[1];
          if (_typeof(key) === 'object' && key !== null) {
            if (set === null) {
              set = new Set();
            }
            set.add(key);
          } else {
            var item2 = b.get(key);
            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
              if (strict) return false;
              if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
              if (set === null) {
                set = new Set();
              }
              set.add(key);
            }
          }
        }
        if (set !== null) {
          var bEntries = arrayFromMap(b);
          for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
              _key = _bEntries$_i[0],
              item = _bEntries$_i[1];
            if (_typeof(_key) === 'object' && _key !== null) {
              if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
            } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function objEquiv(a, b, strict, keys, memos, iterationType) {
        var i = 0;
        if (iterationType === kIsSet) {
          if (!setEquiv(a, b, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsMap) {
          if (!mapEquiv(a, b, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsArray) {
          for (; i < a.length; i++) {
            if (hasOwnProperty(a, i)) {
              if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                return false;
              }
            } else if (hasOwnProperty(b, i)) {
              return false;
            } else {
              var keysA = Object.keys(a);
              for (; i < keysA.length; i++) {
                var key = keysA[i];
                if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                  return false;
                }
              }
              if (keysA.length !== Object.keys(b).length) {
                return false;
              }
              return true;
            }
          }
        }
        for (i = 0; i < keys.length; i++) {
          var _key2 = keys[i];
          if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
            return false;
          }
        }
        return true;
      }
      function isDeepEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kLoose);
      }
      function isDeepStrictEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kStrict);
      }
      module.exports = {
        isDeepEqual: isDeepEqual,
        isDeepStrictEqual: isDeepStrictEqual
      };
    },
    5766: (__unused_webpack_module, exports) => {
      "use strict";

      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
      function getLens(b64) {
        var len = b64.length;
        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        }
        var validLen = b64.indexOf('=');
        if (validLen === -1) validLen = len;
        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i;
        for (i = 0; i < len; i += 4) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 0xFF;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 0xFF;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
          output.push(tripletToBase64(tmp));
        }
        return output.join('');
      }
      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
        }
        return parts.join('');
      }
    },
    7160: function (module) {
      !function (e, t) {
        true ? module.exports = t() : 0;
      }(this, function () {
        return function (e) {
          var t = {};
          function r(n) {
            if (t[n]) return t[n].exports;
            var i = t[n] = {
              i: n,
              l: !1,
              exports: {}
            };
            return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports;
          }
          return r.m = e, r.c = t, r.d = function (e, t, n) {
            r.o(e, t) || Object.defineProperty(e, t, {
              enumerable: !0,
              get: n
            });
          }, r.r = function (e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
              value: "Module"
            }), Object.defineProperty(e, "__esModule", {
              value: !0
            });
          }, r.t = function (e, t) {
            if (1 & t && (e = r(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var n = Object.create(null);
            if (r.r(n), Object.defineProperty(n, "default", {
              enumerable: !0,
              value: e
            }), 2 & t && "string" != typeof e) for (var i in e) r.d(n, i, function (t) {
              return e[t];
            }.bind(null, i));
            return n;
          }, r.n = function (e) {
            var t = e && e.__esModule ? function () {
              return e.default;
            } : function () {
              return e;
            };
            return r.d(t, "a", t), t;
          }, r.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
          }, r.p = "", r(r.s = 90);
        }({
          17: function (e, t, r) {
            "use strict";

            t.__esModule = !0, t.default = void 0;
            var n = r(18),
              i = function () {
                function e() {}
                return e.getFirstMatch = function (e, t) {
                  var r = t.match(e);
                  return r && r.length > 0 && r[1] || "";
                }, e.getSecondMatch = function (e, t) {
                  var r = t.match(e);
                  return r && r.length > 1 && r[2] || "";
                }, e.matchAndReturnConst = function (e, t, r) {
                  if (e.test(t)) return r;
                }, e.getWindowsVersionName = function (e) {
                  switch (e) {
                    case "NT":
                      return "NT";
                    case "XP":
                      return "XP";
                    case "NT 5.0":
                      return "2000";
                    case "NT 5.1":
                      return "XP";
                    case "NT 5.2":
                      return "2003";
                    case "NT 6.0":
                      return "Vista";
                    case "NT 6.1":
                      return "7";
                    case "NT 6.2":
                      return "8";
                    case "NT 6.3":
                      return "8.1";
                    case "NT 10.0":
                      return "10";
                    default:
                      return;
                  }
                }, e.getMacOSVersionName = function (e) {
                  var t = e.split(".").splice(0, 2).map(function (e) {
                    return parseInt(e, 10) || 0;
                  });
                  if (t.push(0), 10 === t[0]) switch (t[1]) {
                    case 5:
                      return "Leopard";
                    case 6:
                      return "Snow Leopard";
                    case 7:
                      return "Lion";
                    case 8:
                      return "Mountain Lion";
                    case 9:
                      return "Mavericks";
                    case 10:
                      return "Yosemite";
                    case 11:
                      return "El Capitan";
                    case 12:
                      return "Sierra";
                    case 13:
                      return "High Sierra";
                    case 14:
                      return "Mojave";
                    case 15:
                      return "Catalina";
                    default:
                      return;
                  }
                }, e.getAndroidVersionName = function (e) {
                  var t = e.split(".").splice(0, 2).map(function (e) {
                    return parseInt(e, 10) || 0;
                  });
                  if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0;
                }, e.getVersionPrecision = function (e) {
                  return e.split(".").length;
                }, e.compareVersions = function (t, r, n) {
                  void 0 === n && (n = !1);
                  var i = e.getVersionPrecision(t),
                    s = e.getVersionPrecision(r),
                    a = Math.max(i, s),
                    o = 0,
                    u = e.map([t, r], function (t) {
                      var r = a - e.getVersionPrecision(t),
                        n = t + new Array(r + 1).join(".0");
                      return e.map(n.split("."), function (e) {
                        return new Array(20 - e.length).join("0") + e;
                      }).reverse();
                    });
                  for (n && (o = a - Math.min(i, s)), a -= 1; a >= o;) {
                    if (u[0][a] > u[1][a]) return 1;
                    if (u[0][a] === u[1][a]) {
                      if (a === o) return 0;
                      a -= 1;
                    } else if (u[0][a] < u[1][a]) return -1;
                  }
                }, e.map = function (e, t) {
                  var r,
                    n = [];
                  if (Array.prototype.map) return Array.prototype.map.call(e, t);
                  for (r = 0; r < e.length; r += 1) n.push(t(e[r]));
                  return n;
                }, e.find = function (e, t) {
                  var r, n;
                  if (Array.prototype.find) return Array.prototype.find.call(e, t);
                  for (r = 0, n = e.length; r < n; r += 1) {
                    var i = e[r];
                    if (t(i, r)) return i;
                  }
                }, e.assign = function (e) {
                  for (var t, r, n = e, i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) s[a - 1] = arguments[a];
                  if (Object.assign) return Object.assign.apply(Object, [e].concat(s));
                  var o = function () {
                    var e = s[t];
                    "object" == typeof e && null !== e && Object.keys(e).forEach(function (t) {
                      n[t] = e[t];
                    });
                  };
                  for (t = 0, r = s.length; t < r; t += 1) o();
                  return e;
                }, e.getBrowserAlias = function (e) {
                  return n.BROWSER_ALIASES_MAP[e];
                }, e.getBrowserTypeByAlias = function (e) {
                  return n.BROWSER_MAP[e] || "";
                }, e;
              }();
            t.default = i, e.exports = t.default;
          },
          18: function (e, t, r) {
            "use strict";

            t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0;
            t.BROWSER_ALIASES_MAP = {
              "Amazon Silk": "amazon_silk",
              "Android Browser": "android",
              Bada: "bada",
              BlackBerry: "blackberry",
              Chrome: "chrome",
              Chromium: "chromium",
              Electron: "electron",
              Epiphany: "epiphany",
              Firefox: "firefox",
              Focus: "focus",
              Generic: "generic",
              "Google Search": "google_search",
              Googlebot: "googlebot",
              "Internet Explorer": "ie",
              "K-Meleon": "k_meleon",
              Maxthon: "maxthon",
              "Microsoft Edge": "edge",
              "MZ Browser": "mz",
              "NAVER Whale Browser": "naver",
              Opera: "opera",
              "Opera Coast": "opera_coast",
              PhantomJS: "phantomjs",
              Puffin: "puffin",
              QupZilla: "qupzilla",
              QQ: "qq",
              QQLite: "qqlite",
              Safari: "safari",
              Sailfish: "sailfish",
              "Samsung Internet for Android": "samsung_internet",
              SeaMonkey: "seamonkey",
              Sleipnir: "sleipnir",
              Swing: "swing",
              Tizen: "tizen",
              "UC Browser": "uc",
              Vivaldi: "vivaldi",
              "WebOS Browser": "webos",
              WeChat: "wechat",
              "Yandex Browser": "yandex",
              Roku: "roku"
            };
            t.BROWSER_MAP = {
              amazon_silk: "Amazon Silk",
              android: "Android Browser",
              bada: "Bada",
              blackberry: "BlackBerry",
              chrome: "Chrome",
              chromium: "Chromium",
              electron: "Electron",
              epiphany: "Epiphany",
              firefox: "Firefox",
              focus: "Focus",
              generic: "Generic",
              googlebot: "Googlebot",
              google_search: "Google Search",
              ie: "Internet Explorer",
              k_meleon: "K-Meleon",
              maxthon: "Maxthon",
              edge: "Microsoft Edge",
              mz: "MZ Browser",
              naver: "NAVER Whale Browser",
              opera: "Opera",
              opera_coast: "Opera Coast",
              phantomjs: "PhantomJS",
              puffin: "Puffin",
              qupzilla: "QupZilla",
              qq: "QQ Browser",
              qqlite: "QQ Browser Lite",
              safari: "Safari",
              sailfish: "Sailfish",
              samsung_internet: "Samsung Internet for Android",
              seamonkey: "SeaMonkey",
              sleipnir: "Sleipnir",
              swing: "Swing",
              tizen: "Tizen",
              uc: "UC Browser",
              vivaldi: "Vivaldi",
              webos: "WebOS Browser",
              wechat: "WeChat",
              yandex: "Yandex Browser"
            };
            t.PLATFORMS_MAP = {
              tablet: "tablet",
              mobile: "mobile",
              desktop: "desktop",
              tv: "tv"
            };
            t.OS_MAP = {
              WindowsPhone: "Windows Phone",
              Windows: "Windows",
              MacOS: "macOS",
              iOS: "iOS",
              Android: "Android",
              WebOS: "WebOS",
              BlackBerry: "BlackBerry",
              Bada: "Bada",
              Tizen: "Tizen",
              Linux: "Linux",
              ChromeOS: "Chrome OS",
              PlayStation4: "PlayStation 4",
              Roku: "Roku"
            };
            t.ENGINE_MAP = {
              EdgeHTML: "EdgeHTML",
              Blink: "Blink",
              Trident: "Trident",
              Presto: "Presto",
              Gecko: "Gecko",
              WebKit: "WebKit"
            };
          },
          90: function (e, t, r) {
            "use strict";

            t.__esModule = !0, t.default = void 0;
            var n,
              i = (n = r(91)) && n.__esModule ? n : {
                default: n
              },
              s = r(18);
            function a(e, t) {
              for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
              }
            }
            var o = function () {
              function e() {}
              var t, r, n;
              return e.getParser = function (e, t) {
                if (void 0 === t && (t = !1), "string" != typeof e) throw new Error("UserAgent should be a string");
                return new i.default(e, t);
              }, e.parse = function (e) {
                return new i.default(e).getResult();
              }, t = e, n = [{
                key: "BROWSER_MAP",
                get: function () {
                  return s.BROWSER_MAP;
                }
              }, {
                key: "ENGINE_MAP",
                get: function () {
                  return s.ENGINE_MAP;
                }
              }, {
                key: "OS_MAP",
                get: function () {
                  return s.OS_MAP;
                }
              }, {
                key: "PLATFORMS_MAP",
                get: function () {
                  return s.PLATFORMS_MAP;
                }
              }], (r = null) && a(t.prototype, r), n && a(t, n), e;
            }();
            t.default = o, e.exports = t.default;
          },
          91: function (e, t, r) {
            "use strict";

            t.__esModule = !0, t.default = void 0;
            var n = u(r(92)),
              i = u(r(93)),
              s = u(r(94)),
              a = u(r(95)),
              o = u(r(17));
            function u(e) {
              return e && e.__esModule ? e : {
                default: e
              };
            }
            var d = function () {
              function e(e, t) {
                if (void 0 === t && (t = !1), null == e || "" === e) throw new Error("UserAgent parameter can't be empty");
                this._ua = e, this.parsedResult = {}, !0 !== t && this.parse();
              }
              var t = e.prototype;
              return t.getUA = function () {
                return this._ua;
              }, t.test = function (e) {
                return e.test(this._ua);
              }, t.parseBrowser = function () {
                var e = this;
                this.parsedResult.browser = {};
                var t = o.default.find(n.default, function (t) {
                  if ("function" == typeof t.test) return t.test(e);
                  if (t.test instanceof Array) return t.test.some(function (t) {
                    return e.test(t);
                  });
                  throw new Error("Browser's test function is not valid");
                });
                return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;
              }, t.getBrowser = function () {
                return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
              }, t.getBrowserName = function (e) {
                return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
              }, t.getBrowserVersion = function () {
                return this.getBrowser().version;
              }, t.getOS = function () {
                return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
              }, t.parseOS = function () {
                var e = this;
                this.parsedResult.os = {};
                var t = o.default.find(i.default, function (t) {
                  if ("function" == typeof t.test) return t.test(e);
                  if (t.test instanceof Array) return t.test.some(function (t) {
                    return e.test(t);
                  });
                  throw new Error("Browser's test function is not valid");
                });
                return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;
              }, t.getOSName = function (e) {
                var t = this.getOS().name;
                return e ? String(t).toLowerCase() || "" : t || "";
              }, t.getOSVersion = function () {
                return this.getOS().version;
              }, t.getPlatform = function () {
                return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
              }, t.getPlatformType = function (e) {
                void 0 === e && (e = !1);
                var t = this.getPlatform().type;
                return e ? String(t).toLowerCase() || "" : t || "";
              }, t.parsePlatform = function () {
                var e = this;
                this.parsedResult.platform = {};
                var t = o.default.find(s.default, function (t) {
                  if ("function" == typeof t.test) return t.test(e);
                  if (t.test instanceof Array) return t.test.some(function (t) {
                    return e.test(t);
                  });
                  throw new Error("Browser's test function is not valid");
                });
                return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;
              }, t.getEngine = function () {
                return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
              }, t.getEngineName = function (e) {
                return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
              }, t.parseEngine = function () {
                var e = this;
                this.parsedResult.engine = {};
                var t = o.default.find(a.default, function (t) {
                  if ("function" == typeof t.test) return t.test(e);
                  if (t.test instanceof Array) return t.test.some(function (t) {
                    return e.test(t);
                  });
                  throw new Error("Browser's test function is not valid");
                });
                return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;
              }, t.parse = function () {
                return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
              }, t.getResult = function () {
                return o.default.assign({}, this.parsedResult);
              }, t.satisfies = function (e) {
                var t = this,
                  r = {},
                  n = 0,
                  i = {},
                  s = 0;
                if (Object.keys(e).forEach(function (t) {
                  var a = e[t];
                  "string" == typeof a ? (i[t] = a, s += 1) : "object" == typeof a && (r[t] = a, n += 1);
                }), n > 0) {
                  var a = Object.keys(r),
                    u = o.default.find(a, function (e) {
                      return t.isOS(e);
                    });
                  if (u) {
                    var d = this.satisfies(r[u]);
                    if (void 0 !== d) return d;
                  }
                  var c = o.default.find(a, function (e) {
                    return t.isPlatform(e);
                  });
                  if (c) {
                    var f = this.satisfies(r[c]);
                    if (void 0 !== f) return f;
                  }
                }
                if (s > 0) {
                  var l = Object.keys(i),
                    h = o.default.find(l, function (e) {
                      return t.isBrowser(e, !0);
                    });
                  if (void 0 !== h) return this.compareVersion(i[h]);
                }
              }, t.isBrowser = function (e, t) {
                void 0 === t && (t = !1);
                var r = this.getBrowserName().toLowerCase(),
                  n = e.toLowerCase(),
                  i = o.default.getBrowserTypeByAlias(n);
                return t && i && (n = i.toLowerCase()), n === r;
              }, t.compareVersion = function (e) {
                var t = [0],
                  r = e,
                  n = !1,
                  i = this.getBrowserVersion();
                if ("string" == typeof i) return ">" === e[0] || "<" === e[0] ? (r = e.substr(1), "=" === e[1] ? (n = !0, r = e.substr(2)) : t = [], ">" === e[0] ? t.push(1) : t.push(-1)) : "=" === e[0] ? r = e.substr(1) : "~" === e[0] && (n = !0, r = e.substr(1)), t.indexOf(o.default.compareVersions(i, r, n)) > -1;
              }, t.isOS = function (e) {
                return this.getOSName(!0) === String(e).toLowerCase();
              }, t.isPlatform = function (e) {
                return this.getPlatformType(!0) === String(e).toLowerCase();
              }, t.isEngine = function (e) {
                return this.getEngineName(!0) === String(e).toLowerCase();
              }, t.is = function (e, t) {
                return void 0 === t && (t = !1), this.isBrowser(e, t) || this.isOS(e) || this.isPlatform(e);
              }, t.some = function (e) {
                var t = this;
                return void 0 === e && (e = []), e.some(function (e) {
                  return t.is(e);
                });
              }, e;
            }();
            t.default = d, e.exports = t.default;
          },
          92: function (e, t, r) {
            "use strict";

            t.__esModule = !0, t.default = void 0;
            var n,
              i = (n = r(17)) && n.__esModule ? n : {
                default: n
              };
            var s = /version\/(\d+(\.?_?\d+)+)/i,
              a = [{
                test: [/googlebot/i],
                describe: function (e) {
                  var t = {
                      name: "Googlebot"
                    },
                    r = i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/opera/i],
                describe: function (e) {
                  var t = {
                      name: "Opera"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/opr\/|opios/i],
                describe: function (e) {
                  var t = {
                      name: "Opera"
                    },
                    r = i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/SamsungBrowser/i],
                describe: function (e) {
                  var t = {
                      name: "Samsung Internet for Android"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/Whale/i],
                describe: function (e) {
                  var t = {
                      name: "NAVER Whale Browser"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/MZBrowser/i],
                describe: function (e) {
                  var t = {
                      name: "MZ Browser"
                    },
                    r = i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/focus/i],
                describe: function (e) {
                  var t = {
                      name: "Focus"
                    },
                    r = i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/swing/i],
                describe: function (e) {
                  var t = {
                      name: "Swing"
                    },
                    r = i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/coast/i],
                describe: function (e) {
                  var t = {
                      name: "Opera Coast"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/opt\/\d+(?:.?_?\d+)+/i],
                describe: function (e) {
                  var t = {
                      name: "Opera Touch"
                    },
                    r = i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/yabrowser/i],
                describe: function (e) {
                  var t = {
                      name: "Yandex Browser"
                    },
                    r = i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/ucbrowser/i],
                describe: function (e) {
                  var t = {
                      name: "UC Browser"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/Maxthon|mxios/i],
                describe: function (e) {
                  var t = {
                      name: "Maxthon"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/epiphany/i],
                describe: function (e) {
                  var t = {
                      name: "Epiphany"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/puffin/i],
                describe: function (e) {
                  var t = {
                      name: "Puffin"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/sleipnir/i],
                describe: function (e) {
                  var t = {
                      name: "Sleipnir"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/k-meleon/i],
                describe: function (e) {
                  var t = {
                      name: "K-Meleon"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/micromessenger/i],
                describe: function (e) {
                  var t = {
                      name: "WeChat"
                    },
                    r = i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/qqbrowser/i],
                describe: function (e) {
                  var t = {
                      name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
                    },
                    r = i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/msie|trident/i],
                describe: function (e) {
                  var t = {
                      name: "Internet Explorer"
                    },
                    r = i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/\sedg\//i],
                describe: function (e) {
                  var t = {
                      name: "Microsoft Edge"
                    },
                    r = i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/edg([ea]|ios)/i],
                describe: function (e) {
                  var t = {
                      name: "Microsoft Edge"
                    },
                    r = i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/vivaldi/i],
                describe: function (e) {
                  var t = {
                      name: "Vivaldi"
                    },
                    r = i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/seamonkey/i],
                describe: function (e) {
                  var t = {
                      name: "SeaMonkey"
                    },
                    r = i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/sailfish/i],
                describe: function (e) {
                  var t = {
                      name: "Sailfish"
                    },
                    r = i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/silk/i],
                describe: function (e) {
                  var t = {
                      name: "Amazon Silk"
                    },
                    r = i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/phantom/i],
                describe: function (e) {
                  var t = {
                      name: "PhantomJS"
                    },
                    r = i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/slimerjs/i],
                describe: function (e) {
                  var t = {
                      name: "SlimerJS"
                    },
                    r = i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                describe: function (e) {
                  var t = {
                      name: "BlackBerry"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/(web|hpw)[o0]s/i],
                describe: function (e) {
                  var t = {
                      name: "WebOS Browser"
                    },
                    r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/bada/i],
                describe: function (e) {
                  var t = {
                      name: "Bada"
                    },
                    r = i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/tizen/i],
                describe: function (e) {
                  var t = {
                      name: "Tizen"
                    },
                    r = i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/qupzilla/i],
                describe: function (e) {
                  var t = {
                      name: "QupZilla"
                    },
                    r = i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/firefox|iceweasel|fxios/i],
                describe: function (e) {
                  var t = {
                      name: "Firefox"
                    },
                    r = i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/electron/i],
                describe: function (e) {
                  var t = {
                      name: "Electron"
                    },
                    r = i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/MiuiBrowser/i],
                describe: function (e) {
                  var t = {
                      name: "Miui"
                    },
                    r = i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/chromium/i],
                describe: function (e) {
                  var t = {
                      name: "Chromium"
                    },
                    r = i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/chrome|crios|crmo/i],
                describe: function (e) {
                  var t = {
                      name: "Chrome"
                    },
                    r = i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/GSA/i],
                describe: function (e) {
                  var t = {
                      name: "Google Search"
                    },
                    r = i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: function (e) {
                  var t = !e.test(/like android/i),
                    r = e.test(/android/i);
                  return t && r;
                },
                describe: function (e) {
                  var t = {
                      name: "Android Browser"
                    },
                    r = i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/playstation 4/i],
                describe: function (e) {
                  var t = {
                      name: "PlayStation 4"
                    },
                    r = i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/safari|applewebkit/i],
                describe: function (e) {
                  var t = {
                      name: "Safari"
                    },
                    r = i.default.getFirstMatch(s, e);
                  return r && (t.version = r), t;
                }
              }, {
                test: [/.*/i],
                describe: function (e) {
                  var t = -1 !== e.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
                  return {
                    name: i.default.getFirstMatch(t, e),
                    version: i.default.getSecondMatch(t, e)
                  };
                }
              }];
            t.default = a, e.exports = t.default;
          },
          93: function (e, t, r) {
            "use strict";

            t.__esModule = !0, t.default = void 0;
            var n,
              i = (n = r(17)) && n.__esModule ? n : {
                default: n
              },
              s = r(18);
            var a = [{
              test: [/Roku\/DVP/],
              describe: function (e) {
                var t = i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
                return {
                  name: s.OS_MAP.Roku,
                  version: t
                };
              }
            }, {
              test: [/windows phone/i],
              describe: function (e) {
                var t = i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
                return {
                  name: s.OS_MAP.WindowsPhone,
                  version: t
                };
              }
            }, {
              test: [/windows /i],
              describe: function (e) {
                var t = i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e),
                  r = i.default.getWindowsVersionName(t);
                return {
                  name: s.OS_MAP.Windows,
                  version: t,
                  versionName: r
                };
              }
            }, {
              test: [/Macintosh(.*?) FxiOS(.*?)\//],
              describe: function (e) {
                var t = {
                    name: s.OS_MAP.iOS
                  },
                  r = i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
                return r && (t.version = r), t;
              }
            }, {
              test: [/macintosh/i],
              describe: function (e) {
                var t = i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."),
                  r = i.default.getMacOSVersionName(t),
                  n = {
                    name: s.OS_MAP.MacOS,
                    version: t
                  };
                return r && (n.versionName = r), n;
              }
            }, {
              test: [/(ipod|iphone|ipad)/i],
              describe: function (e) {
                var t = i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
                return {
                  name: s.OS_MAP.iOS,
                  version: t
                };
              }
            }, {
              test: function (e) {
                var t = !e.test(/like android/i),
                  r = e.test(/android/i);
                return t && r;
              },
              describe: function (e) {
                var t = i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e),
                  r = i.default.getAndroidVersionName(t),
                  n = {
                    name: s.OS_MAP.Android,
                    version: t
                  };
                return r && (n.versionName = r), n;
              }
            }, {
              test: [/(web|hpw)[o0]s/i],
              describe: function (e) {
                var t = i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e),
                  r = {
                    name: s.OS_MAP.WebOS
                  };
                return t && t.length && (r.version = t), r;
              }
            }, {
              test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
              describe: function (e) {
                var t = i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || i.default.getFirstMatch(/\bbb(\d+)/i, e);
                return {
                  name: s.OS_MAP.BlackBerry,
                  version: t
                };
              }
            }, {
              test: [/bada/i],
              describe: function (e) {
                var t = i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
                return {
                  name: s.OS_MAP.Bada,
                  version: t
                };
              }
            }, {
              test: [/tizen/i],
              describe: function (e) {
                var t = i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
                return {
                  name: s.OS_MAP.Tizen,
                  version: t
                };
              }
            }, {
              test: [/linux/i],
              describe: function () {
                return {
                  name: s.OS_MAP.Linux
                };
              }
            }, {
              test: [/CrOS/],
              describe: function () {
                return {
                  name: s.OS_MAP.ChromeOS
                };
              }
            }, {
              test: [/PlayStation 4/],
              describe: function (e) {
                var t = i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
                return {
                  name: s.OS_MAP.PlayStation4,
                  version: t
                };
              }
            }];
            t.default = a, e.exports = t.default;
          },
          94: function (e, t, r) {
            "use strict";

            t.__esModule = !0, t.default = void 0;
            var n,
              i = (n = r(17)) && n.__esModule ? n : {
                default: n
              },
              s = r(18);
            var a = [{
              test: [/googlebot/i],
              describe: function () {
                return {
                  type: "bot",
                  vendor: "Google"
                };
              }
            }, {
              test: [/huawei/i],
              describe: function (e) {
                var t = i.default.getFirstMatch(/(can-l01)/i, e) && "Nova",
                  r = {
                    type: s.PLATFORMS_MAP.mobile,
                    vendor: "Huawei"
                  };
                return t && (r.model = t), r;
              }
            }, {
              test: [/nexus\s*(?:7|8|9|10).*/i],
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.tablet,
                  vendor: "Nexus"
                };
              }
            }, {
              test: [/ipad/i],
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.tablet,
                  vendor: "Apple",
                  model: "iPad"
                };
              }
            }, {
              test: [/Macintosh(.*?) FxiOS(.*?)\//],
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.tablet,
                  vendor: "Apple",
                  model: "iPad"
                };
              }
            }, {
              test: [/kftt build/i],
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.tablet,
                  vendor: "Amazon",
                  model: "Kindle Fire HD 7"
                };
              }
            }, {
              test: [/silk/i],
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.tablet,
                  vendor: "Amazon"
                };
              }
            }, {
              test: [/tablet(?! pc)/i],
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.tablet
                };
              }
            }, {
              test: function (e) {
                var t = e.test(/ipod|iphone/i),
                  r = e.test(/like (ipod|iphone)/i);
                return t && !r;
              },
              describe: function (e) {
                var t = i.default.getFirstMatch(/(ipod|iphone)/i, e);
                return {
                  type: s.PLATFORMS_MAP.mobile,
                  vendor: "Apple",
                  model: t
                };
              }
            }, {
              test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.mobile,
                  vendor: "Nexus"
                };
              }
            }, {
              test: [/[^-]mobi/i],
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.mobile
                };
              }
            }, {
              test: function (e) {
                return "blackberry" === e.getBrowserName(!0);
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.mobile,
                  vendor: "BlackBerry"
                };
              }
            }, {
              test: function (e) {
                return "bada" === e.getBrowserName(!0);
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.mobile
                };
              }
            }, {
              test: function (e) {
                return "windows phone" === e.getBrowserName();
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.mobile,
                  vendor: "Microsoft"
                };
              }
            }, {
              test: function (e) {
                var t = Number(String(e.getOSVersion()).split(".")[0]);
                return "android" === e.getOSName(!0) && t >= 3;
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.tablet
                };
              }
            }, {
              test: function (e) {
                return "android" === e.getOSName(!0);
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.mobile
                };
              }
            }, {
              test: function (e) {
                return "macos" === e.getOSName(!0);
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.desktop,
                  vendor: "Apple"
                };
              }
            }, {
              test: function (e) {
                return "windows" === e.getOSName(!0);
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.desktop
                };
              }
            }, {
              test: function (e) {
                return "linux" === e.getOSName(!0);
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.desktop
                };
              }
            }, {
              test: function (e) {
                return "playstation 4" === e.getOSName(!0);
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.tv
                };
              }
            }, {
              test: function (e) {
                return "roku" === e.getOSName(!0);
              },
              describe: function () {
                return {
                  type: s.PLATFORMS_MAP.tv
                };
              }
            }];
            t.default = a, e.exports = t.default;
          },
          95: function (e, t, r) {
            "use strict";

            t.__esModule = !0, t.default = void 0;
            var n,
              i = (n = r(17)) && n.__esModule ? n : {
                default: n
              },
              s = r(18);
            var a = [{
              test: function (e) {
                return "microsoft edge" === e.getBrowserName(!0);
              },
              describe: function (e) {
                if (/\sedg\//i.test(e)) return {
                  name: s.ENGINE_MAP.Blink
                };
                var t = i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
                return {
                  name: s.ENGINE_MAP.EdgeHTML,
                  version: t
                };
              }
            }, {
              test: [/trident/i],
              describe: function (e) {
                var t = {
                    name: s.ENGINE_MAP.Trident
                  },
                  r = i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
                return r && (t.version = r), t;
              }
            }, {
              test: function (e) {
                return e.test(/presto/i);
              },
              describe: function (e) {
                var t = {
                    name: s.ENGINE_MAP.Presto
                  },
                  r = i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
                return r && (t.version = r), t;
              }
            }, {
              test: function (e) {
                var t = e.test(/gecko/i),
                  r = e.test(/like gecko/i);
                return t && !r;
              },
              describe: function (e) {
                var t = {
                    name: s.ENGINE_MAP.Gecko
                  },
                  r = i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
                return r && (t.version = r), t;
              }
            }, {
              test: [/(apple)?webkit\/537\.36/i],
              describe: function () {
                return {
                  name: s.ENGINE_MAP.Blink
                };
              }
            }, {
              test: [/(apple)?webkit/i],
              describe: function (e) {
                var t = {
                    name: s.ENGINE_MAP.WebKit
                  },
                  r = i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
                return r && (t.version = r), t;
              }
            }];
            t.default = a, e.exports = t.default;
          }
        });
      });
    },
    8834: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      var __webpack_unused_export__;
      var base64 = __webpack_require__(5766);
      var ieee754 = __webpack_require__(2333);
      var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') : null;
      exports.lW = Buffer;
      __webpack_unused_export__ = SlowBuffer;
      exports.h2 = 50;
      var K_MAX_LENGTH = 0x7fffffff;
      __webpack_unused_export__ = K_MAX_LENGTH;
      Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
        console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
      }
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = {
            foo: function () {
              return 42;
            }
          };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer.prototype, 'parent', {
        enumerable: true,
        get: function () {
          if (!Buffer.isBuffer(this)) return undefined;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer.prototype, 'offset', {
        enumerable: true,
        get: function () {
          if (!Buffer.isBuffer(this)) return undefined;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer.prototype);
        return buf;
      }
      function Buffer(arg, encodingOrOffset, length) {
        if (typeof arg === 'number') {
          if (typeof encodingOrOffset === 'string') {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === 'string') {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === 'number') {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }
        var valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer.from(valueOf, encodingOrOffset, length);
        }
        var b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
          return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
        }
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
      }
      Buffer.from = function (value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer, Uint8Array);
      function assertSize(size) {
        if (typeof size !== 'number') {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== undefined) {
          return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer.alloc = function (size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer.allocUnsafe = function (size) {
        return allocUnsafe(size);
      };
      Buffer.allocUnsafeSlow = function (size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== 'string' || encoding === '') {
          encoding = 'utf8';
        }
        if (!Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }
        var length = byteLength(string, encoding) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);
        for (var i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        var buf;
        if (byteOffset === undefined && length === undefined) {
          buf = new Uint8Array(array);
        } else if (length === undefined) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== undefined) {
          if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer.alloc(+length);
      }
      Buffer.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer.prototype;
      };
      Buffer.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }
        if (a === b) return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'latin1':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return true;
          default:
            return false;
        }
      };
      Buffer.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer.alloc(0);
        }
        var i;
        if (length === undefined) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer = Buffer.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              Buffer.from(buf).copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(buffer, buf, pos);
            }
          } else if (!Buffer.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== 'string') {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
        }
        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        var loweredCase = false;
        for (;;) {
          switch (encoding) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return len;
            case 'utf8':
            case 'utf-8':
              return utf8ToBytes(string).length;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return len * 2;
            case 'hex':
              return len >>> 1;
            case 'base64':
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ('' + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === undefined || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return '';
        }
        if (end === undefined || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return '';
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return '';
        }
        if (!encoding) encoding = 'utf8';
        while (true) {
          switch (encoding) {
            case 'hex':
              return hexSlice(this, start, end);
            case 'utf8':
            case 'utf-8':
              return utf8Slice(this, start, end);
            case 'ascii':
              return asciiSlice(this, start, end);
            case 'latin1':
            case 'binary':
              return latin1Slice(this, start, end);
            case 'base64':
              return base64Slice(this, start, end);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
              encoding = (encoding + '').toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer.prototype._isBuffer = true;
      function swap(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 16-bits');
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 32-bits');
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 64-bits');
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0) return '';
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer.prototype.toLocaleString = Buffer.prototype.toString;
      Buffer.prototype.equals = function equals(b) {
        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
        if (this === b) return true;
        return Buffer.compare(this, b) === 0;
      };
      Buffer.prototype.inspect = function inspect() {
        var str = '';
        var max = exports.h2;
        str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
        if (this.length > max) str += ' ... ';
        return '<Buffer ' + str + '>';
      };
      if (customInspectSymbol) {
        Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
      }
      Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer.from(target, target.offset, target.byteLength);
        }
        if (!Buffer.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
        }
        if (start === undefined) {
          start = 0;
        }
        if (end === undefined) {
          end = target ? target.length : 0;
        }
        if (thisStart === undefined) {
          thisStart = 0;
        }
        if (thisEnd === undefined) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError('out of range index');
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;
        if (typeof byteOffset === 'string') {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 0x7fffffff) {
          byteOffset = 0x7fffffff;
        } else if (byteOffset < -0x80000000) {
          byteOffset = -0x80000000;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir) return -1;else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;else return -1;
        }
        if (typeof val === 'string') {
          val = Buffer.from(val, encoding);
        }
        if (Buffer.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === 'number') {
          val = val & 0xFF;
          if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError('val must be string, number or Buffer');
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== undefined) {
          encoding = String(encoding).toLowerCase();
          if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i) {
          if (indexSize === 1) {
            return buf[i];
          } else {
            return buf.readUInt16BE(i * indexSize);
          }
        }
        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer.prototype.write = function write(string, offset, length, encoding) {
        if (offset === undefined) {
          encoding = 'utf8';
          length = this.length;
          offset = 0;
        } else if (length === undefined && typeof offset === 'string') {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
          } else {
            encoding = length;
            length = undefined;
          }
        } else {
          throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
        }
        var remaining = this.length - offset;
        if (length === undefined || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError('Attempt to write outside buffer bounds');
        }
        if (!encoding) encoding = 'utf8';
        var loweredCase = false;
        for (;;) {
          switch (encoding) {
            case 'hex':
              return hexWrite(this, string, offset, length);
            case 'utf8':
            case 'utf-8':
              return utf8Write(this, string, offset, length);
            case 'ascii':
            case 'latin1':
            case 'binary':
              return asciiWrite(this, string, offset, length);
            case 'base64':
              return base64Write(this, string, offset, length);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
              encoding = ('' + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer.prototype.toJSON = function toJSON() {
        return {
          type: 'Buffer',
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 0x80) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                  if (tempCodePoint > 0x7F) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
          } else if (codePoint > 0xFFFF) {
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 0x1000;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = '';
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = '';
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 0x7F);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = '';
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        var out = '';
        for (var i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = '';
        for (var i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === undefined ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
        if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
      }
      Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert) checkOffset(offset, byteLength, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength, this.length);
        }
        var val = this[offset + --byteLength];
        var mul = 1;
        while (byteLength > 0 && (mul *= 0x100)) {
          val += this[offset + --byteLength] * mul;
        }
        return val;
      };
      Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
      };
      Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert) checkOffset(offset, byteLength, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul;
        }
        mul *= 0x80;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength);
        return val;
      };
      Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert) checkOffset(offset, byteLength, this.length);
        var i = byteLength;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 0x100)) {
          val += this[offset + --i] * mul;
        }
        mul *= 0x80;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength);
        return val;
      };
      Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 0x80)) return this[offset];
        return (0xff - this[offset] + 1) * -1;
      };
      Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 0x8000 ? val | 0xFFFF0000 : val;
      };
      Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 0x8000 ? val | 0xFFFF0000 : val;
      };
      Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError('Index out of range');
      }
      Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1;
          checkInt(this, value, offset, byteLength, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 0xFF;
        while (++i < byteLength && (mul *= 0x100)) {
          this[offset + i] = value / mul & 0xFF;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1;
          checkInt(this, value, offset, byteLength, maxBytes, 0);
        }
        var i = byteLength - 1;
        var mul = 1;
        this[offset + i] = value & 0xFF;
        while (--i >= 0 && (mul *= 0x100)) {
          this[offset + i] = value / mul & 0xFF;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
        this[offset] = value & 0xff;
        return offset + 1;
      };
      Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
        return offset + 2;
      };
      Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 0xff;
        return offset + 4;
      };
      Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
        return offset + 4;
      };
      Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1);
          checkInt(this, value, offset, byteLength, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 0xFF;
        while (++i < byteLength && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 0xFF;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1);
          checkInt(this, value, offset, byteLength, limit - 1, -limit);
        }
        var i = byteLength - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 0xFF;
        while (--i >= 0 && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 0xFF;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
        if (value < 0) value = 0xff + value + 1;
        this[offset] = value & 0xff;
        return offset + 1;
      };
      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
        return offset + 2;
      };
      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
        if (value < 0) value = 0xffffffff + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError('Index out of range');
        if (offset < 0) throw new RangeError('Index out of range');
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError('targetStart out of bounds');
        }
        if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
        if (end < 0) throw new RangeError('sourceEnd out of bounds');
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }
        return len;
      };
      Buffer.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === 'string') {
          if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
          }
          if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string');
          }
          if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding);
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
              val = code;
            }
          }
        } else if (typeof val === 'number') {
          val = val & 255;
        } else if (typeof val === 'boolean') {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError('Out of range index');
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === undefined ? this.length : end >>> 0;
        if (!val) val = 0;
        var i;
        if (typeof val === 'number') {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
          var len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split('=')[0];
        str = str.trim().replace(INVALID_BASE64_RE, '');
        if (str.length < 2) return '';
        while (str.length % 4 !== 0) {
          str = str + '=';
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 0xD7FF && codePoint < 0xE000) {
            if (!leadSurrogate) {
              if (codePoint > 0xDBFF) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 0xDC00) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          }
          leadSurrogate = null;
          if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
          } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
          } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
          } else {
            throw new Error('Invalid code point');
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 0xFF);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length) break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function () {
        var alphabet = '0123456789abcdef';
        var table = new Array(256);
        for (var i = 0; i < 16; ++i) {
          var i16 = i * 16;
          for (var j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
    },
    2680: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var GetIntrinsic = __webpack_require__(7286);
      var callBind = __webpack_require__(9429);
      var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    },
    9429: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var bind = __webpack_require__(4090);
      var GetIntrinsic = __webpack_require__(7286);
      var $apply = GetIntrinsic('%Function.prototype.apply%');
      var $call = GetIntrinsic('%Function.prototype.call%');
      var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
      var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
      var $max = GetIntrinsic('%Math.max%');
      if ($defineProperty) {
        try {
          $defineProperty({}, 'a', {
            value: 1
          });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, 'length');
          if (desc.configurable) {
            $defineProperty(func, 'length', {
              value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
            });
          }
        }
        return func;
      };
      var applyBind = function applyBind() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, 'apply', {
          value: applyBind
        });
      } else {
        module.exports.apply = applyBind;
      }
    },
    5130: (module, exports, __webpack_require__) => {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
          }
        };
      })();
      exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
      function useColors() {
        if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = 'color: ' + this.color;
        args.splice(1, 0, c, 'color: inherit');
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, match => {
          if (match === '%%') {
            return;
          }
          index++;
          if (match === '%c') {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {});
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem('debug', namespaces);
          } else {
            exports.storage.removeItem('debug');
          }
        } catch (error) {}
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem('debug');
        } catch (error) {}
        if (!r && typeof {
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        } !== 'undefined' && 'env' in {
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        }) {
          r = false;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {}
      }
      module.exports = __webpack_require__(7123)(exports);
      const {
        formatters
      } = module.exports;
      formatters.j = function (v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return '[UnexpectedJSONParseError]: ' + error.message;
        }
      };
    },
    7123: (module, __unused_webpack_exports, __webpack_require__) => {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = __webpack_require__(1378);
        createDebug.destroy = destroy;
        Object.keys(env).forEach(key => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self = debug;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
              args.unshift('%O');
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === '%%') {
                return '%';
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === 'function') {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: v => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
              createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
            } else {
              createDebug.names.push(new RegExp('^' + namespaces + '$'));
            }
          }
        }
        function disable() {
          const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');
          createDebug.enable('');
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === '*') {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    },
    4926: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var keys = __webpack_require__(3464);
      var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
      var toStr = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function (fn) {
        return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
      };
      var hasPropertyDescriptors = __webpack_require__(1181)();
      var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
      var defineProperty = function (object, name, value, predicate) {
        if (name in object) {
          if (predicate === true) {
            if (object[name] === value) {
              return;
            }
          } else if (!isFunction(predicate) || !predicate()) {
            return;
          }
        }
        if (supportsDescriptors) {
          origDefineProperty(object, name, {
            configurable: true,
            enumerable: false,
            value: value,
            writable: true
          });
        } else {
          object[name] = value;
        }
      };
      var defineProperties = function (object, map) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map);
        if (hasSymbols) {
          props = concat.call(props, Object.getOwnPropertySymbols(map));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    },
    9913: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);
      }
      exports.number = number;
      function bool(b) {
        if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);
      }
      exports.bool = bool;
      function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
        if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports.bytes = bytes;
      function hash(hash) {
        if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
        number(hash.outputLen);
        number(hash.blockLen);
      }
      exports.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed) throw new Error('Hash instance has been destroyed');
        if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
      }
      exports.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports.output = output;
      const assert = {
        number,
        bool,
        bytes,
        hash,
        exists,
        output
      };
      exports["default"] = assert;
    },
    7843: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SHA2 = void 0;
      const _assert_js_1 = __webpack_require__(9913);
      const utils_js_1 = __webpack_require__(9570);
      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(0xffffffff);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      class SHA2 extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
          _assert_js_1.default.exists(this);
          const {
            view,
            buffer,
            blockLen
          } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          _assert_js_1.default.exists(this);
          _assert_js_1.default.output(out, this);
          this.finished = true;
          const {
            buffer,
            view,
            blockLen,
            isLE
          } = this;
          let {
            pos
          } = this;
          buffer[pos++] = 0b10000000;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++) buffer[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));
        }
        digest() {
          const {
            buffer,
            outputLen
          } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const {
            blockLen,
            buffer,
            length,
            finished,
            destroyed,
            pos
          } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen) to.buffer.set(buffer);
          return to;
        }
      }
      exports.SHA2 = SHA2;
    },
    4198: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
      const U32_MASK64 = BigInt(2 ** 32 - 1);
      const _32n = BigInt(32);
      function fromBig(n, le = false) {
        if (le) return {
          h: Number(n & U32_MASK64),
          l: Number(n >> _32n & U32_MASK64)
        };
        return {
          h: Number(n >> _32n & U32_MASK64) | 0,
          l: Number(n & U32_MASK64) | 0
        };
      }
      exports.fromBig = fromBig;
      function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const {
            h,
            l
          } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports.split = split;
      const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports.toBig = toBig;
      const shrSH = (h, l, s) => h >>> s;
      const shrSL = (h, l, s) => h << 32 - s | l >>> s;
      const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      const rotr32H = (h, l) => l;
      const rotr32L = (h, l) => h;
      const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return {
          h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
          l: l | 0
        };
      }
      exports.add = add;
      const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      const u64 = {
        fromBig,
        split,
        toBig: exports.toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports["default"] = u64;
    },
    6197: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.crypto = void 0;
      exports.crypto = {
        node: undefined,
        web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined
      };
    },
    7227: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hmac = void 0;
      const _assert_js_1 = __webpack_require__(9913);
      const utils_js_1 = __webpack_require__(9570);
      class HMAC extends utils_js_1.Hash {
        constructor(hash, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          _assert_js_1.default.hash(hash);
          const key = (0, utils_js_1.toBytes)(_key);
          this.iHash = hash.create();
          if (!(this.iHash instanceof utils_js_1.Hash)) throw new TypeError('Expected instance of class which extends utils.Hash');
          const blockLen = this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const pad = new Uint8Array(blockLen);
          pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;
          this.iHash.update(pad);
          this.oHash = hash.create();
          for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;
          this.oHash.update(pad);
          pad.fill(0);
        }
        update(buf) {
          _assert_js_1.default.exists(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          _assert_js_1.default.exists(this);
          _assert_js_1.default.bytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const {
            oHash,
            iHash,
            finished,
            destroyed,
            blockLen,
            outputLen
          } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      }
      const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
      exports.hmac = hmac;
      exports.hmac.create = (hash, key) => new HMAC(hash, key);
    },
    430: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pbkdf2Async = exports.pbkdf2 = void 0;
      const _assert_js_1 = __webpack_require__(9913);
      const hmac_js_1 = __webpack_require__(7227);
      const utils_js_1 = __webpack_require__(9570);
      function pbkdf2Init(hash, _password, _salt, _opts) {
        _assert_js_1.default.hash(hash);
        const opts = (0, utils_js_1.checkOpts)({
          dkLen: 32,
          asyncTick: 10
        }, _opts);
        const {
          c,
          dkLen,
          asyncTick
        } = opts;
        _assert_js_1.default.number(c);
        _assert_js_1.default.number(dkLen);
        _assert_js_1.default.number(asyncTick);
        if (c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');
        const password = (0, utils_js_1.toBytes)(_password);
        const salt = (0, utils_js_1.toBytes)(_salt);
        const DK = new Uint8Array(dkLen);
        const PRF = hmac_js_1.hmac.create(hash, password);
        const PRFSalt = PRF._cloneInto().update(salt);
        return {
          c,
          dkLen,
          asyncTick,
          DK,
          PRF,
          PRFSalt
        };
      }
      function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
        PRF.destroy();
        PRFSalt.destroy();
        if (prfW) prfW.destroy();
        u.fill(0);
        return DK;
      }
      function pbkdf2(hash, password, salt, opts) {
        const {
          c,
          dkLen,
          DK,
          PRF,
          PRFSalt
        } = pbkdf2Init(hash, password, salt, opts);
        let prfW;
        const arr = new Uint8Array(4);
        const view = (0, utils_js_1.createView)(arr);
        const u = new Uint8Array(PRF.outputLen);
        for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
          const Ti = DK.subarray(pos, pos + PRF.outputLen);
          view.setInt32(0, ti, false);
          (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
          Ti.set(u.subarray(0, Ti.length));
          for (let ui = 1; ui < c; ui++) {
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
          }
        }
        return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
      }
      exports.pbkdf2 = pbkdf2;
      async function pbkdf2Async(hash, password, salt, opts) {
        const {
          c,
          dkLen,
          asyncTick,
          DK,
          PRF,
          PRFSalt
        } = pbkdf2Init(hash, password, salt, opts);
        let prfW;
        const arr = new Uint8Array(4);
        const view = (0, utils_js_1.createView)(arr);
        const u = new Uint8Array(PRF.outputLen);
        for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
          const Ti = DK.subarray(pos, pos + PRF.outputLen);
          view.setInt32(0, ti, false);
          (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
          Ti.set(u.subarray(0, Ti.length));
          await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, i => {
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
          });
        }
        return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
      }
      exports.pbkdf2Async = pbkdf2Async;
    },
    3163: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ripemd160 = exports.RIPEMD160 = void 0;
      const _sha2_js_1 = __webpack_require__(7843);
      const utils_js_1 = __webpack_require__(9570);
      const Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
      const Id = Uint8Array.from({
        length: 16
      }, (_, i) => i);
      const Pi = Id.map(i => (9 * i + 5) % 16);
      let idxL = [Id];
      let idxR = [Pi];
      for (let i = 0; i < 4; i++) for (let j of [idxL, idxR]) j.push(j[i].map(k => Rho[k]));
      const shifts = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(i => new Uint8Array(i));
      const shiftsL = idxL.map((idx, i) => idx.map(j => shifts[i][j]));
      const shiftsR = idxR.map((idx, i) => idx.map(j => shifts[i][j]));
      const Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
      const Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
      const rotl = (word, shift) => word << shift | word >>> 32 - shift;
      function f(group, x, y, z) {
        if (group === 0) return x ^ y ^ z;else if (group === 1) return x & y | ~x & z;else if (group === 2) return (x | ~y) ^ z;else if (group === 3) return x & z | y & ~z;else return x ^ (y | ~z);
      }
      const BUF = new Uint32Array(16);
      class RIPEMD160 extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 20, 8, true);
          this.h0 = 0x67452301 | 0;
          this.h1 = 0xefcdab89 | 0;
          this.h2 = 0x98badcfe | 0;
          this.h3 = 0x10325476 | 0;
          this.h4 = 0xc3d2e1f0 | 0;
        }
        get() {
          const {
            h0,
            h1,
            h2,
            h3,
            h4
          } = this;
          return [h0, h1, h2, h3, h4];
        }
        set(h0, h1, h2, h3, h4) {
          this.h0 = h0 | 0;
          this.h1 = h1 | 0;
          this.h2 = h2 | 0;
          this.h3 = h3 | 0;
          this.h4 = h4 | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) BUF[i] = view.getUint32(offset, true);
          let al = this.h0 | 0,
            ar = al,
            bl = this.h1 | 0,
            br = bl,
            cl = this.h2 | 0,
            cr = cl,
            dl = this.h3 | 0,
            dr = dl,
            el = this.h4 | 0,
            er = el;
          for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group],
              hbr = Kr[group];
            const rl = idxL[group],
              rr = idxR[group];
            const sl = shiftsL[group],
              sr = shiftsR[group];
            for (let i = 0; i < 16; i++) {
              const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
              al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
            }
            for (let i = 0; i < 16; i++) {
              const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
              ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
            }
          }
          this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
        }
        roundClean() {
          BUF.fill(0);
        }
        destroy() {
          this.destroyed = true;
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0);
        }
      }
      exports.RIPEMD160 = RIPEMD160;
      exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
    },
    5639: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.scryptAsync = exports.scrypt = void 0;
      const _assert_js_1 = __webpack_require__(9913);
      const sha256_js_1 = __webpack_require__(5468);
      const pbkdf2_js_1 = __webpack_require__(430);
      const utils_js_1 = __webpack_require__(9570);
      const rotl = (a, b) => a << b | a >>> 32 - b;
      function XorAndSalsa(prev, pi, input, ii, out, oi) {
        let y00 = prev[pi++] ^ input[ii++],
          y01 = prev[pi++] ^ input[ii++];
        let y02 = prev[pi++] ^ input[ii++],
          y03 = prev[pi++] ^ input[ii++];
        let y04 = prev[pi++] ^ input[ii++],
          y05 = prev[pi++] ^ input[ii++];
        let y06 = prev[pi++] ^ input[ii++],
          y07 = prev[pi++] ^ input[ii++];
        let y08 = prev[pi++] ^ input[ii++],
          y09 = prev[pi++] ^ input[ii++];
        let y10 = prev[pi++] ^ input[ii++],
          y11 = prev[pi++] ^ input[ii++];
        let y12 = prev[pi++] ^ input[ii++],
          y13 = prev[pi++] ^ input[ii++];
        let y14 = prev[pi++] ^ input[ii++],
          y15 = prev[pi++] ^ input[ii++];
        let x00 = y00,
          x01 = y01,
          x02 = y02,
          x03 = y03,
          x04 = y04,
          x05 = y05,
          x06 = y06,
          x07 = y07,
          x08 = y08,
          x09 = y09,
          x10 = y10,
          x11 = y11,
          x12 = y12,
          x13 = y13,
          x14 = y14,
          x15 = y15;
        for (let i = 0; i < 8; i += 2) {
          x04 ^= rotl(x00 + x12 | 0, 7);
          x08 ^= rotl(x04 + x00 | 0, 9);
          x12 ^= rotl(x08 + x04 | 0, 13);
          x00 ^= rotl(x12 + x08 | 0, 18);
          x09 ^= rotl(x05 + x01 | 0, 7);
          x13 ^= rotl(x09 + x05 | 0, 9);
          x01 ^= rotl(x13 + x09 | 0, 13);
          x05 ^= rotl(x01 + x13 | 0, 18);
          x14 ^= rotl(x10 + x06 | 0, 7);
          x02 ^= rotl(x14 + x10 | 0, 9);
          x06 ^= rotl(x02 + x14 | 0, 13);
          x10 ^= rotl(x06 + x02 | 0, 18);
          x03 ^= rotl(x15 + x11 | 0, 7);
          x07 ^= rotl(x03 + x15 | 0, 9);
          x11 ^= rotl(x07 + x03 | 0, 13);
          x15 ^= rotl(x11 + x07 | 0, 18);
          x01 ^= rotl(x00 + x03 | 0, 7);
          x02 ^= rotl(x01 + x00 | 0, 9);
          x03 ^= rotl(x02 + x01 | 0, 13);
          x00 ^= rotl(x03 + x02 | 0, 18);
          x06 ^= rotl(x05 + x04 | 0, 7);
          x07 ^= rotl(x06 + x05 | 0, 9);
          x04 ^= rotl(x07 + x06 | 0, 13);
          x05 ^= rotl(x04 + x07 | 0, 18);
          x11 ^= rotl(x10 + x09 | 0, 7);
          x08 ^= rotl(x11 + x10 | 0, 9);
          x09 ^= rotl(x08 + x11 | 0, 13);
          x10 ^= rotl(x09 + x08 | 0, 18);
          x12 ^= rotl(x15 + x14 | 0, 7);
          x13 ^= rotl(x12 + x15 | 0, 9);
          x14 ^= rotl(x13 + x12 | 0, 13);
          x15 ^= rotl(x14 + x13 | 0, 18);
        }
        out[oi++] = y00 + x00 | 0;
        out[oi++] = y01 + x01 | 0;
        out[oi++] = y02 + x02 | 0;
        out[oi++] = y03 + x03 | 0;
        out[oi++] = y04 + x04 | 0;
        out[oi++] = y05 + x05 | 0;
        out[oi++] = y06 + x06 | 0;
        out[oi++] = y07 + x07 | 0;
        out[oi++] = y08 + x08 | 0;
        out[oi++] = y09 + x09 | 0;
        out[oi++] = y10 + x10 | 0;
        out[oi++] = y11 + x11 | 0;
        out[oi++] = y12 + x12 | 0;
        out[oi++] = y13 + x13 | 0;
        out[oi++] = y14 + x14 | 0;
        out[oi++] = y15 + x15 | 0;
      }
      function BlockMix(input, ii, out, oi, r) {
        let head = oi + 0;
        let tail = oi + 16 * r;
        for (let i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
        for (let i = 0; i < r; i++, head += 16, ii += 16) {
          XorAndSalsa(out, tail, input, ii, out, head);
          if (i > 0) tail += 16;
          XorAndSalsa(out, head, input, ii += 16, out, tail);
        }
      }
      function scryptInit(password, salt, _opts) {
        const opts = (0, utils_js_1.checkOpts)({
          dkLen: 32,
          asyncTick: 10,
          maxmem: 1024 ** 3 + 1024
        }, _opts);
        const {
          N,
          r,
          p,
          dkLen,
          asyncTick,
          maxmem,
          onProgress
        } = opts;
        _assert_js_1.default.number(N);
        _assert_js_1.default.number(r);
        _assert_js_1.default.number(p);
        _assert_js_1.default.number(dkLen);
        _assert_js_1.default.number(asyncTick);
        _assert_js_1.default.number(maxmem);
        if (onProgress !== undefined && typeof onProgress !== 'function') throw new Error('progressCb should be function');
        const blockSize = 128 * r;
        const blockSize32 = blockSize / 4;
        if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
          throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');
        }
        if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
          throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');
        }
        if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
          throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');
        }
        const memUsed = blockSize * (N + p);
        if (memUsed > maxmem) {
          throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
        }
        const B = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, {
          c: 1,
          dkLen: blockSize * p
        });
        const B32 = (0, utils_js_1.u32)(B);
        const V = (0, utils_js_1.u32)(new Uint8Array(blockSize * N));
        const tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));
        let blockMixCb = () => {};
        if (onProgress) {
          const totalBlockMix = 2 * N * p;
          const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
          let blockMixCnt = 0;
          blockMixCb = () => {
            blockMixCnt++;
            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)) onProgress(blockMixCnt / totalBlockMix);
          };
        }
        return {
          N,
          r,
          p,
          dkLen,
          blockSize32,
          V,
          B32,
          B,
          tmp,
          blockMixCb,
          asyncTick
        };
      }
      function scryptOutput(password, dkLen, B, V, tmp) {
        const res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B, {
          c: 1,
          dkLen
        });
        B.fill(0);
        V.fill(0);
        tmp.fill(0);
        return res;
      }
      function scrypt(password, salt, opts) {
        const {
          N,
          r,
          p,
          dkLen,
          blockSize32,
          V,
          B32,
          B,
          tmp,
          blockMixCb
        } = scryptInit(password, salt, opts);
        for (let pi = 0; pi < p; pi++) {
          const Pi = blockSize32 * pi;
          for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i];
          for (let i = 0, pos = 0; i < N - 1; i++) {
            BlockMix(V, pos, V, pos += blockSize32, r);
            blockMixCb();
          }
          BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
          blockMixCb();
          for (let i = 0; i < N; i++) {
            const j = B32[Pi + blockSize32 - 16] % N;
            for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
            BlockMix(tmp, 0, B32, Pi, r);
            blockMixCb();
          }
        }
        return scryptOutput(password, dkLen, B, V, tmp);
      }
      exports.scrypt = scrypt;
      async function scryptAsync(password, salt, opts) {
        const {
          N,
          r,
          p,
          dkLen,
          blockSize32,
          V,
          B32,
          B,
          tmp,
          blockMixCb,
          asyncTick
        } = scryptInit(password, salt, opts);
        for (let pi = 0; pi < p; pi++) {
          const Pi = blockSize32 * pi;
          for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i];
          let pos = 0;
          await (0, utils_js_1.asyncLoop)(N - 1, asyncTick, i => {
            BlockMix(V, pos, V, pos += blockSize32, r);
            blockMixCb();
          });
          BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
          blockMixCb();
          await (0, utils_js_1.asyncLoop)(N, asyncTick, i => {
            const j = B32[Pi + blockSize32 - 16] % N;
            for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
            BlockMix(tmp, 0, B32, Pi, r);
            blockMixCb();
          });
        }
        return scryptOutput(password, dkLen, B, V, tmp);
      }
      exports.scryptAsync = scryptAsync;
    },
    5468: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sha256 = void 0;
      const _sha2_js_1 = __webpack_require__(7843);
      const utils_js_1 = __webpack_require__(9570);
      const Chi = (a, b, c) => a & b ^ ~a & c;
      const Maj = (a, b, c) => a & b ^ a & c ^ b & c;
      const SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
      const IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
      const SHA256_W = new Uint32Array(64);
      class SHA256 extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const {
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
          } = this;
          return [A, B, C, D, E, F, G, H];
        }
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let {
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
          } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      }
      exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    },
    33: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
      const _assert_js_1 = __webpack_require__(9913);
      const _u64_js_1 = __webpack_require__(4198);
      const utils_js_1 = __webpack_require__(9570);
      const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
      const _0n = BigInt(0);
      const _1n = BigInt(1);
      const _2n = BigInt(2);
      const _7n = BigInt(7);
      const _256n = BigInt(256);
      const _0x71n = BigInt(0x71);
      for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
          if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;
        }
        _SHA3_IOTA.push(t);
      }
      const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
      const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
      const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
      function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        for (let round = 24 - rounds; round < 24; round++) {
          for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
          for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
              s[x + y] ^= Th;
              s[x + y + 1] ^= Tl;
            }
          }
          let curH = s[2];
          let curL = s[3];
          for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
          }
          for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++) B[x] = s[y + x];
            for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
          }
          s[0] ^= SHA3_IOTA_H[round];
          s[1] ^= SHA3_IOTA_L[round];
        }
        B.fill(0);
      }
      exports.keccakP = keccakP;
      class Keccak extends utils_js_1.Hash {
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          _assert_js_1.default.number(outputLen);
          if (0 >= this.blockLen || this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
          this.state = new Uint8Array(200);
          this.state32 = (0, utils_js_1.u32)(this.state);
        }
        keccak() {
          keccakP(this.state32, this.rounds);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          _assert_js_1.default.exists(this);
          const {
            blockLen,
            state
          } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = true;
          const {
            state,
            suffix,
            pos,
            blockLen
          } = this;
          state[pos] ^= suffix;
          if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
          state[blockLen - 1] ^= 0x80;
          this.keccak();
        }
        writeInto(out) {
          _assert_js_1.default.exists(this, false);
          _assert_js_1.default.bytes(out);
          this.finish();
          const bufferOut = this.state;
          const {
            blockLen
          } = this;
          for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
          return this.writeInto(out);
        }
        xof(bytes) {
          _assert_js_1.default.number(bytes);
          return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
          _assert_js_1.default.output(out, this);
          if (this.finished) throw new Error('digest() was already called');
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          this.state.fill(0);
        }
        _cloneInto(to) {
          const {
            blockLen,
            suffix,
            outputLen,
            rounds,
            enableXOF
          } = this;
          to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      }
      exports.Keccak = Keccak;
      const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
      exports.sha3_224 = gen(0x06, 144, 224 / 8);
      exports.sha3_256 = gen(0x06, 136, 256 / 8);
      exports.sha3_384 = gen(0x06, 104, 384 / 8);
      exports.sha3_512 = gen(0x06, 72, 512 / 8);
      exports.keccak_224 = gen(0x01, 144, 224 / 8);
      exports.keccak_256 = gen(0x01, 136, 256 / 8);
      exports.keccak_384 = gen(0x01, 104, 384 / 8);
      exports.keccak_512 = gen(0x01, 72, 512 / 8);
      const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
      exports.shake128 = genShake(0x1f, 168, 128 / 8);
      exports.shake256 = genShake(0x1f, 136, 256 / 8);
    },
    6123: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sha384 = exports.sha512_256 = exports.sha512 = exports.SHA512 = void 0;
      const _sha2_js_1 = __webpack_require__(7843);
      const _u64_js_1 = __webpack_require__(4198);
      const utils_js_1 = __webpack_require__(9570);
      const [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(n => BigInt(n)));
      const SHA512_W_H = new Uint32Array(80);
      const SHA512_W_L = new Uint32Array(80);
      class SHA512 extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 0x6a09e667 | 0;
          this.Al = 0xf3bcc908 | 0;
          this.Bh = 0xbb67ae85 | 0;
          this.Bl = 0x84caa73b | 0;
          this.Ch = 0x3c6ef372 | 0;
          this.Cl = 0xfe94f82b | 0;
          this.Dh = 0xa54ff53a | 0;
          this.Dl = 0x5f1d36f1 | 0;
          this.Eh = 0x510e527f | 0;
          this.El = 0xade682d1 | 0;
          this.Fh = 0x9b05688c | 0;
          this.Fl = 0x2b3e6c1f | 0;
          this.Gh = 0x1f83d9ab | 0;
          this.Gl = 0xfb41bd6b | 0;
          this.Hh = 0x5be0cd19 | 0;
          this.Hl = 0x137e2179 | 0;
        }
        get() {
          const {
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
          } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let {
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
          } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({
              h: Eh,
              l: El
            } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({
            h: Ah,
            l: Al
          } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({
            h: Bh,
            l: Bl
          } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({
            h: Ch,
            l: Cl
          } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({
            h: Dh,
            l: Dl
          } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({
            h: Eh,
            l: El
          } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({
            h: Fh,
            l: Fl
          } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({
            h: Gh,
            l: Gl
          } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({
            h: Hh,
            l: Hl
          } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      exports.SHA512 = SHA512;
      class SHA512_256 extends SHA512 {
        constructor() {
          super();
          this.Ah = 0x22312194 | 0;
          this.Al = 0xfc2bf72c | 0;
          this.Bh = 0x9f555fa3 | 0;
          this.Bl = 0xc84c64c2 | 0;
          this.Ch = 0x2393b86b | 0;
          this.Cl = 0x6f53b151 | 0;
          this.Dh = 0x96387719 | 0;
          this.Dl = 0x5940eabd | 0;
          this.Eh = 0x96283ee2 | 0;
          this.El = 0xa88effe3 | 0;
          this.Fh = 0xbe5e1e25 | 0;
          this.Fl = 0x53863992 | 0;
          this.Gh = 0x2b0199fc | 0;
          this.Gl = 0x2c85b8aa | 0;
          this.Hh = 0x0eb72ddc | 0;
          this.Hl = 0x81c52ca2 | 0;
          this.outputLen = 32;
        }
      }
      class SHA384 extends SHA512 {
        constructor() {
          super();
          this.Ah = 0xcbbb9d5d | 0;
          this.Al = 0xc1059ed8 | 0;
          this.Bh = 0x629a292a | 0;
          this.Bl = 0x367cd507 | 0;
          this.Ch = 0x9159015a | 0;
          this.Cl = 0x3070dd17 | 0;
          this.Dh = 0x152fecd8 | 0;
          this.Dl = 0xf70e5939 | 0;
          this.Eh = 0x67332667 | 0;
          this.El = 0xffc00b31 | 0;
          this.Fh = 0x8eb44a87 | 0;
          this.Fl = 0x68581511 | 0;
          this.Gh = 0xdb0c2e0d | 0;
          this.Gl = 0x64f98fa7 | 0;
          this.Hh = 0x47b5481d | 0;
          this.Hl = 0xbefa4fa4 | 0;
          this.outputLen = 48;
        }
      }
      exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
      exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    },
    9570: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
      const crypto_1 = __webpack_require__(6197);
      const u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      const u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports.u32 = u32;
      const createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView;
      const rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports.rotr = rotr;
      exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
      if (!exports.isLE) throw new Error('Non little-endian hardware is not supported');
      const hexes = Array.from({
        length: 256
      }, (v, i) => i.toString(16).padStart(2, '0'));
      function bytesToHex(uint8a) {
        if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');
        let hex = '';
        for (let i = 0; i < uint8a.length; i++) {
          hex += hexes[uint8a[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex;
      function hexToBytes(hex) {
        if (typeof hex !== 'string') {
          throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
        }
        if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');
        const array = new Uint8Array(hex.length / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');
          array[i] = byte;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes;
      const nextTick = async () => {};
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick) continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      exports.asyncLoop = asyncLoop;
      function utf8ToBytes(str) {
        if (typeof str !== 'string') {
          throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
        }
        return new TextEncoder().encode(str);
      }
      exports.utf8ToBytes = utf8ToBytes;
      function toBytes(data) {
        if (typeof data === 'string') data = utf8ToBytes(data);
        if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
        return data;
      }
      exports.toBytes = toBytes;
      function concatBytes(...arrays) {
        if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');
        if (arrays.length === 1) return arrays[0];
        const length = arrays.reduce((a, arr) => a + arr.length, 0);
        const result = new Uint8Array(length);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const arr = arrays[i];
          result.set(arr, pad);
          pad += arr.length;
        }
        return result;
      }
      exports.concatBytes = concatBytes;
      class Hash {
        clone() {
          return this._cloneInto();
        }
      }
      exports.Hash = Hash;
      const isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
      function checkOpts(defaults, opts) {
        if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts))) throw new TypeError('Options should be object or undefined');
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports.checkOpts = checkOpts;
      function wrapConstructor(hashConstructor) {
        const hashC = message => hashConstructor().update(toBytes(message)).digest();
        const tmp = hashConstructor();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashConstructor();
        return hashC;
      }
      exports.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = opts => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto.web) {
          return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto_1.crypto.node) {
          return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      }
      exports.randomBytes = randomBytes;
    },
    2003: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        __assign: () => __assign,
        __asyncDelegator: () => __asyncDelegator,
        __asyncGenerator: () => __asyncGenerator,
        __asyncValues: () => __asyncValues,
        __await: () => __await,
        __awaiter: () => __awaiter,
        __classPrivateFieldGet: () => __classPrivateFieldGet,
        __classPrivateFieldIn: () => __classPrivateFieldIn,
        __classPrivateFieldSet: () => __classPrivateFieldSet,
        __createBinding: () => __createBinding,
        __decorate: () => __decorate,
        __exportStar: () => __exportStar,
        __extends: () => __extends,
        __generator: () => __generator,
        __importDefault: () => __importDefault,
        __importStar: () => __importStar,
        __makeTemplateObject: () => __makeTemplateObject,
        __metadata: () => __metadata,
        __param: () => __param,
        __read: () => __read,
        __rest: () => __rest,
        __spread: () => __spread,
        __spreadArray: () => __spreadArray,
        __spreadArrays: () => __spreadArrays,
        __values: () => __values
      });
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var __assign = function () {
        __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
      }
      function __decorate(decorators, target, key, desc) {
        var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      }
      function __param(paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      }
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function () {
              if (t[0] & 1) throw t[1];
              return t[1];
            },
            trys: [],
            ops: []
          },
          f,
          y,
          t,
          g;
        return g = {
          next: verb(0),
          "throw": verb(1),
          "return": verb(2)
        }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
          return this;
        }), g;
        function verb(n) {
          return function (v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return {
            value: op[0] ? op[1] : void 0,
            done: true
          };
        }
      }
      var __createBinding = Object.create ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            }
          };
        }
        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      };
      function __exportStar(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
      }
      function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function () {
            if (o && i >= o.length) o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = {
            error: error
          };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      }
      function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
      }
      function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
        return r;
      }
      function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
      }
      function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      }
      function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i;
        function verb(n) {
          if (g[n]) i[n] = function (v) {
            return new Promise(function (a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
      }
      function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function () {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function (v) {
            return (p = !p) ? {
              value: __await(o[n](v)),
              done: n === "return"
            } : f ? f(v) : v;
          } : f;
        }
      }
      function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator],
          i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function (v) {
            resolve({
              value: v,
              done: d
            });
          }, reject);
        }
      }
      function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", {
            value: raw
          });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }
      ;
      var __setModuleDefault = Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      };
      function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      }
      function __importDefault(mod) {
        return mod && mod.__esModule ? mod : {
          default: mod
        };
      }
      function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      }
      function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      }
      function __classPrivateFieldIn(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      }
    },
    6920: module => {
      module.exports = stringify;
      stringify.default = stringify;
      stringify.stable = deterministicStringify;
      stringify.stableStringify = deterministicStringify;
      var LIMIT_REPLACE_NODE = '[...]';
      var CIRCULAR_REPLACE_NODE = '[Circular]';
      var arr = [];
      var replacerStack = [];
      function defaultOptions() {
        return {
          depthLimit: Number.MAX_SAFE_INTEGER,
          edgesLimit: Number.MAX_SAFE_INTEGER
        };
      }
      function stringify(obj, replacer, spacer, options) {
        if (typeof options === 'undefined') {
          options = defaultOptions();
        }
        decirc(obj, '', 0, [], undefined, 0, options);
        var res;
        try {
          if (replacerStack.length === 0) {
            res = JSON.stringify(obj, replacer, spacer);
          } else {
            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
          }
        } catch (_) {
          return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');
        } finally {
          while (arr.length !== 0) {
            var part = arr.pop();
            if (part.length === 4) {
              Object.defineProperty(part[0], part[1], part[3]);
            } else {
              part[0][part[1]] = part[2];
            }
          }
        }
        return res;
      }
      function setReplace(replace, val, k, parent) {
        var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
        if (propertyDescriptor.get !== undefined) {
          if (propertyDescriptor.configurable) {
            Object.defineProperty(parent, k, {
              value: replace
            });
            arr.push([parent, k, val, propertyDescriptor]);
          } else {
            replacerStack.push([val, k, replace]);
          }
        } else {
          parent[k] = replace;
          arr.push([parent, k, val]);
        }
      }
      function decirc(val, k, edgeIndex, stack, parent, depth, options) {
        depth += 1;
        var i;
        if (typeof val === 'object' && val !== null) {
          for (i = 0; i < stack.length; i++) {
            if (stack[i] === val) {
              setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
              return;
            }
          }
          if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          stack.push(val);
          if (Array.isArray(val)) {
            for (i = 0; i < val.length; i++) {
              decirc(val[i], i, i, stack, val, depth, options);
            }
          } else {
            var keys = Object.keys(val);
            for (i = 0; i < keys.length; i++) {
              var key = keys[i];
              decirc(val[key], key, i, stack, val, depth, options);
            }
          }
          stack.pop();
        }
      }
      function compareFunction(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      }
      function deterministicStringify(obj, replacer, spacer, options) {
        if (typeof options === 'undefined') {
          options = defaultOptions();
        }
        var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
        var res;
        try {
          if (replacerStack.length === 0) {
            res = JSON.stringify(tmp, replacer, spacer);
          } else {
            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
          }
        } catch (_) {
          return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');
        } finally {
          while (arr.length !== 0) {
            var part = arr.pop();
            if (part.length === 4) {
              Object.defineProperty(part[0], part[1], part[3]);
            } else {
              part[0][part[1]] = part[2];
            }
          }
        }
        return res;
      }
      function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
        depth += 1;
        var i;
        if (typeof val === 'object' && val !== null) {
          for (i = 0; i < stack.length; i++) {
            if (stack[i] === val) {
              setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
              return;
            }
          }
          try {
            if (typeof val.toJSON === 'function') {
              return;
            }
          } catch (_) {
            return;
          }
          if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          stack.push(val);
          if (Array.isArray(val)) {
            for (i = 0; i < val.length; i++) {
              deterministicDecirc(val[i], i, i, stack, val, depth, options);
            }
          } else {
            var tmp = {};
            var keys = Object.keys(val).sort(compareFunction);
            for (i = 0; i < keys.length; i++) {
              var key = keys[i];
              deterministicDecirc(val[key], key, i, stack, val, depth, options);
              tmp[key] = val[key];
            }
            if (typeof parent !== 'undefined') {
              arr.push([parent, k, val]);
              parent[k] = tmp;
            } else {
              return tmp;
            }
          }
          stack.pop();
        }
      }
      function replaceGetterValues(replacer) {
        replacer = typeof replacer !== 'undefined' ? replacer : function (k, v) {
          return v;
        };
        return function (key, val) {
          if (replacerStack.length > 0) {
            for (var i = 0; i < replacerStack.length; i++) {
              var part = replacerStack[i];
              if (part[1] === key && part[0] === val) {
                val = part[2];
                replacerStack.splice(i, 1);
                break;
              }
            }
          }
          return replacer.call(this, key, val);
        };
      }
    },
    3243: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var isCallable = __webpack_require__(9680);
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
          if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
              iterator(array[i], i, array);
            } else {
              iterator.call(receiver, array[i], i, array);
            }
          }
        }
      };
      var forEachString = function forEachString(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
          if (receiver == null) {
            iterator(string.charAt(i), i, string);
          } else {
            iterator.call(receiver, string.charAt(i), i, string);
          }
        }
      };
      var forEachObject = function forEachObject(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach = function forEach(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError('iterator must be a function');
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === '[object Array]') {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === 'string') {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module.exports = forEach;
    },
    7795: module => {
      "use strict";

      var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = '[object Function]';
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== 'function' || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function () {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push('$' + i);
        }
        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
        if (target.prototype) {
          var Empty = function Empty() {};
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    },
    4090: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var implementation = __webpack_require__(7795);
      module.exports = Function.prototype.bind || implementation;
    },
    7286: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var undefined;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function (expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
        } catch (e) {}
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, '');
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function () {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function () {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, 'callee').get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = __webpack_require__(2636)();
      var hasProto = __webpack_require__(8486)();
      var getProto = Object.getPrototypeOf || (hasProto ? function (x) {
        return x.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
      var INTRINSICS = {
        '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
        '%Array%': Array,
        '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
        '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
        '%AsyncFromSyncIteratorPrototype%': undefined,
        '%AsyncFunction%': needsEval,
        '%AsyncGenerator%': needsEval,
        '%AsyncGeneratorFunction%': needsEval,
        '%AsyncIteratorPrototype%': needsEval,
        '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
        '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
        '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
        '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
        '%Boolean%': Boolean,
        '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
        '%Date%': Date,
        '%decodeURI%': decodeURI,
        '%decodeURIComponent%': decodeURIComponent,
        '%encodeURI%': encodeURI,
        '%encodeURIComponent%': encodeURIComponent,
        '%Error%': Error,
        '%eval%': eval,
        '%EvalError%': EvalError,
        '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
        '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
        '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
        '%Function%': $Function,
        '%GeneratorFunction%': needsEval,
        '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
        '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
        '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
        '%isFinite%': isFinite,
        '%isNaN%': isNaN,
        '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
        '%JSON%': typeof JSON === 'object' ? JSON : undefined,
        '%Map%': typeof Map === 'undefined' ? undefined : Map,
        '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
        '%Math%': Math,
        '%Number%': Number,
        '%Object%': Object,
        '%parseFloat%': parseFloat,
        '%parseInt%': parseInt,
        '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
        '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
        '%RangeError%': RangeError,
        '%ReferenceError%': ReferenceError,
        '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
        '%RegExp%': RegExp,
        '%Set%': typeof Set === 'undefined' ? undefined : Set,
        '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
        '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
        '%String%': String,
        '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
        '%Symbol%': hasSymbols ? Symbol : undefined,
        '%SyntaxError%': $SyntaxError,
        '%ThrowTypeError%': ThrowTypeError,
        '%TypedArray%': TypedArray,
        '%TypeError%': $TypeError,
        '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
        '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
        '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
        '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
        '%URIError%': URIError,
        '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
        '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
        '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
      };
      if (getProto) {
        try {
          null.error;
        } catch (e) {
          var errorProto = getProto(getProto(e));
          INTRINSICS['%Error.prototype%'] = errorProto;
        }
      }
      var doEval = function doEval(name) {
        var value;
        if (name === '%AsyncFunction%') {
          value = getEvalledConstructor('async function () {}');
        } else if (name === '%GeneratorFunction%') {
          value = getEvalledConstructor('function* () {}');
        } else if (name === '%AsyncGeneratorFunction%') {
          value = getEvalledConstructor('async function* () {}');
        } else if (name === '%AsyncGenerator%') {
          var fn = doEval('%AsyncGeneratorFunction%');
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === '%AsyncIteratorPrototype%') {
          var gen = doEval('%AsyncGenerator%');
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
        '%ArrayPrototype%': ['Array', 'prototype'],
        '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
        '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
        '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
        '%ArrayProto_values%': ['Array', 'prototype', 'values'],
        '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
        '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
        '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
        '%BooleanPrototype%': ['Boolean', 'prototype'],
        '%DataViewPrototype%': ['DataView', 'prototype'],
        '%DatePrototype%': ['Date', 'prototype'],
        '%ErrorPrototype%': ['Error', 'prototype'],
        '%EvalErrorPrototype%': ['EvalError', 'prototype'],
        '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
        '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
        '%FunctionPrototype%': ['Function', 'prototype'],
        '%Generator%': ['GeneratorFunction', 'prototype'],
        '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
        '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
        '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
        '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
        '%JSONParse%': ['JSON', 'parse'],
        '%JSONStringify%': ['JSON', 'stringify'],
        '%MapPrototype%': ['Map', 'prototype'],
        '%NumberPrototype%': ['Number', 'prototype'],
        '%ObjectPrototype%': ['Object', 'prototype'],
        '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
        '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
        '%PromisePrototype%': ['Promise', 'prototype'],
        '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
        '%Promise_all%': ['Promise', 'all'],
        '%Promise_reject%': ['Promise', 'reject'],
        '%Promise_resolve%': ['Promise', 'resolve'],
        '%RangeErrorPrototype%': ['RangeError', 'prototype'],
        '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
        '%RegExpPrototype%': ['RegExp', 'prototype'],
        '%SetPrototype%': ['Set', 'prototype'],
        '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
        '%StringPrototype%': ['String', 'prototype'],
        '%SymbolPrototype%': ['Symbol', 'prototype'],
        '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
        '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
        '%TypeErrorPrototype%': ['TypeError', 'prototype'],
        '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
        '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
        '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
        '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
        '%URIErrorPrototype%': ['URIError', 'prototype'],
        '%WeakMapPrototype%': ['WeakMap', 'prototype'],
        '%WeakSetPrototype%': ['WeakSet', 'prototype']
      };
      var bind = __webpack_require__(4090);
      var hasOwn = __webpack_require__(3198);
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === '%' && last !== '%') {
          throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
        } else if (last === '%' && first !== '%') {
          throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
        }
        var result = [];
        $replace(string, rePropName, function (match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = '%' + alias[0] + '%';
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
          }
          return {
            alias: alias,
            name: intrinsicName,
            value: value
          };
        }
        throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== 'string' || name.length === 0) {
          throw new $TypeError('intrinsic name must be a non-empty string');
        }
        if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
        var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
          }
          if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += '.' + part;
          intrinsicRealName = '%' + intrinsicBaseName + '%';
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
              }
              return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    },
    326: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var GetIntrinsic = __webpack_require__(7286);
      var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
      if ($gOPD) {
        try {
          $gOPD([], 'length');
        } catch (e) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    },
    1181: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var GetIntrinsic = __webpack_require__(7286);
      var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
      var hasPropertyDescriptors = function hasPropertyDescriptors() {
        if ($defineProperty) {
          try {
            $defineProperty({}, 'a', {
              value: 1
            });
            return true;
          } catch (e) {
            return false;
          }
        }
        return false;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!hasPropertyDescriptors()) {
          return null;
        }
        try {
          return $defineProperty([], 'length', {
            value: 1
          }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    },
    8486: module => {
      "use strict";

      var test = {
        foo: {}
      };
      var $Object = Object;
      module.exports = function hasProto() {
        return {
          __proto__: test
        }.foo === test.foo && !({
          __proto__: null
        } instanceof $Object);
      };
    },
    2636: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var origSymbol = typeof Symbol !== 'undefined' && Symbol;
      var hasSymbolSham = __webpack_require__(6679);
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== 'function') {
          return false;
        }
        if (typeof Symbol !== 'function') {
          return false;
        }
        if (typeof origSymbol('foo') !== 'symbol') {
          return false;
        }
        if (typeof Symbol('bar') !== 'symbol') {
          return false;
        }
        return hasSymbolSham();
      };
    },
    6679: module => {
      "use strict";

      module.exports = function hasSymbols() {
        if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
          return false;
        }
        if (typeof Symbol.iterator === 'symbol') {
          return true;
        }
        var obj = {};
        var sym = Symbol('test');
        var symObj = Object(sym);
        if (typeof sym === 'string') {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === 'function') {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    },
    7226: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var hasSymbols = __webpack_require__(6679);
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    },
    3198: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var bind = __webpack_require__(4090);
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    },
    2333: (__unused_webpack_module, exports) => {
      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
        buffer[offset + i - d] |= s * 128;
      };
    },
    1285: module => {
      if (typeof Object.create === 'function') {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    },
    2635: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var hasToStringTag = __webpack_require__(7226)();
      var callBound = __webpack_require__(2680);
      var $toString = callBound('Object.prototype.toString');
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === '[object Arguments]';
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
      };
      var supportsStandardArguments = function () {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    },
    9680: module => {
      "use strict";

      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
        try {
          badArrayLike = Object.defineProperty({}, 'length', {
            get: function () {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function () {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = '[object Object]';
      var fnClass = '[object Function]';
      var genClass = '[object GeneratorFunction]';
      var ddaClass = '[object HTMLAllCollection]';
      var ddaClass2 = '[object HTML document.all class]';
      var ddaClass3 = '[object HTMLCollection]';
      var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === 'object') {
        var all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value('') == null;
              } catch (e) {}
            }
            return false;
          };
        }
      }
      module.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== 'function' && typeof value !== 'object') {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e) {
          if (e !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== 'function' && typeof value !== 'object') {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    },
    3138: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = __webpack_require__(7226)();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function () {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function('return function*() {}')();
        } catch (e) {}
      };
      var GeneratorFunction;
      module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== 'function') {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === '[object GeneratorFunction]';
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === 'undefined') {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    },
    7053: module => {
      "use strict";

      module.exports = function isNaN(value) {
        return value !== value;
      };
    },
    4782: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var callBind = __webpack_require__(9429);
      var define = __webpack_require__(4926);
      var implementation = __webpack_require__(7053);
      var getPolyfill = __webpack_require__(755);
      var shim = __webpack_require__(5346);
      var polyfill = callBind(getPolyfill(), Number);
      define(polyfill, {
        getPolyfill: getPolyfill,
        implementation: implementation,
        shim: shim
      });
      module.exports = polyfill;
    },
    755: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var implementation = __webpack_require__(7053);
      module.exports = function getPolyfill() {
        if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
          return Number.isNaN;
        }
        return implementation;
      };
    },
    5346: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var define = __webpack_require__(4926);
      var getPolyfill = __webpack_require__(755);
      module.exports = function shimNumberIsNaN() {
        var polyfill = getPolyfill();
        define(Number, {
          isNaN: polyfill
        }, {
          isNaN: function testIsNaN() {
            return Number.isNaN !== polyfill;
          }
        });
        return polyfill;
      };
    },
    198: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var whichTypedArray = __webpack_require__(2094);
      module.exports = function isTypedArray(value) {
        return !!whichTypedArray(value);
      };
    },
    7105: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      const Yallist = __webpack_require__(8006);
      const MAX = Symbol('max');
      const LENGTH = Symbol('length');
      const LENGTH_CALCULATOR = Symbol('lengthCalculator');
      const ALLOW_STALE = Symbol('allowStale');
      const MAX_AGE = Symbol('maxAge');
      const DISPOSE = Symbol('dispose');
      const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
      const LRU_LIST = Symbol('lruList');
      const CACHE = Symbol('cache');
      const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');
      const naiveLength = () => 1;
      class LRUCache {
        constructor(options) {
          if (typeof options === 'number') options = {
            max: options
          };
          if (!options) options = {};
          if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');
          const max = this[MAX] = options.max || Infinity;
          const lc = options.length || naiveLength;
          this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
          this[ALLOW_STALE] = options.stale || false;
          if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
          this[MAX_AGE] = options.maxAge || 0;
          this[DISPOSE] = options.dispose;
          this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
          this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
          this.reset();
        }
        set max(mL) {
          if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
          this[MAX] = mL || Infinity;
          trim(this);
        }
        get max() {
          return this[MAX];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
          this[MAX_AGE] = mA;
          trim(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        set lengthCalculator(lC) {
          if (typeof lC !== 'function') lC = naiveLength;
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach(hit => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
              this[LENGTH] += hit.length;
            });
          }
          trim(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; walker !== null;) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; walker !== null;) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map(k => k.key);
        }
        values() {
          return this[LRU_LIST].toArray().map(k => k.value);
        }
        reset() {
          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
          }
          this[CACHE] = new Map();
          this[LRU_LIST] = new Yallist();
          this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map(hit => isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter(h => h);
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
          const now = maxAge ? Date.now() : 0;
          const len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
              del(this, this[CACHE].get(key));
              return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            if (this[DISPOSE]) {
              if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          if (hit.length > this[MAX]) {
            if (this[DISPOSE]) this[DISPOSE](key, value);
            return false;
          }
          this[LENGTH] += hit.length;
          this[LRU_LIST].unshift(hit);
          this[CACHE].set(key, this[LRU_LIST].head);
          trim(this);
          return true;
        }
        has(key) {
          if (!this[CACHE].has(key)) return false;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get(this, key, true);
        }
        peek(key) {
          return get(this, key, false);
        }
        pop() {
          const node = this[LRU_LIST].tail;
          if (!node) return null;
          del(this, node);
          return node.value;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0) this.set(hit.k, hit.v);else {
              const maxAge = expiresAt - now;
              if (maxAge > 0) {
                this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        }
        prune() {
          this[CACHE].forEach((value, key) => get(this, key, false));
        }
      }
      const get = (self, key, doUse) => {
        const node = self[CACHE].get(key);
        if (node) {
          const hit = node.value;
          if (isStale(self, hit)) {
            del(self, node);
            if (!self[ALLOW_STALE]) return undefined;
          } else {
            if (doUse) {
              if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
              self[LRU_LIST].unshiftNode(node);
            }
          }
          return hit.value;
        }
      };
      const isStale = (self, hit) => {
        if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
      };
      const trim = self => {
        if (self[LENGTH] > self[MAX]) {
          for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
            const prev = walker.prev;
            del(self, walker);
            walker = prev;
          }
        }
      };
      const del = (self, node) => {
        if (node) {
          const hit = node.value;
          if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
          self[LENGTH] -= hit.length;
          self[CACHE].delete(hit.key);
          self[LRU_LIST].removeNode(node);
        }
      };
      class Entry {
        constructor(key, value, length, now, maxAge) {
          this.key = key;
          this.value = value;
          this.length = length;
          this.now = now;
          this.maxAge = maxAge || 0;
        }
      }
      const forEachStep = (self, fn, node, thisp) => {
        let hit = node.value;
        if (isStale(self, hit)) {
          del(self, node);
          if (!self[ALLOW_STALE]) hit = undefined;
        }
        if (hit) fn.call(thisp, hit.value, hit.key, self);
      };
      module.exports = LRUCache;
    },
    1378: module => {
      var s = 1000;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function (val, options) {
        options = options || {};
        var type = typeof val;
        if (type === 'string' && val.length > 0) {
          return parse(val);
        } else if (type === 'number' && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();
        switch (type) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return n * y;
          case 'weeks':
          case 'week':
          case 'w':
            return n * w;
          case 'days':
          case 'day':
          case 'd':
            return n * d;
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return n * h;
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return n * m;
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return n * s;
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return n;
          default:
            return undefined;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + 'd';
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + 'h';
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + 'm';
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + 's';
        }
        return ms + 'ms';
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, 'day');
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, 'hour');
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, 'minute');
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, 'second');
        }
        return ms + ' ms';
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
      }
    },
    8169: module => {
      "use strict";

      var numberIsNaN = function (value) {
        return value !== value;
      };
      module.exports = function is(a, b) {
        if (a === 0 && b === 0) {
          return 1 / a === 1 / b;
        }
        if (a === b) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b)) {
          return true;
        }
        return false;
      };
    },
    4679: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var define = __webpack_require__(4926);
      var callBind = __webpack_require__(9429);
      var implementation = __webpack_require__(8169);
      var getPolyfill = __webpack_require__(8070);
      var shim = __webpack_require__(191);
      var polyfill = callBind(getPolyfill(), Object);
      define(polyfill, {
        getPolyfill: getPolyfill,
        implementation: implementation,
        shim: shim
      });
      module.exports = polyfill;
    },
    8070: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var implementation = __webpack_require__(8169);
      module.exports = function getPolyfill() {
        return typeof Object.is === 'function' ? Object.is : implementation;
      };
    },
    191: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var getPolyfill = __webpack_require__(8070);
      var define = __webpack_require__(4926);
      module.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define(Object, {
          is: polyfill
        }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    },
    5691: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var keysShim;
      if (!Object.keys) {
        var has = Object.prototype.hasOwnProperty;
        var toStr = Object.prototype.toString;
        var isArgs = __webpack_require__(801);
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var hasDontEnumBug = !isEnumerable.call({
          toString: null
        }, 'toString');
        var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
        var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
        var equalsConstructorPrototype = function (o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        var excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        var hasAutomationEqualityBug = function () {
          if (typeof window === 'undefined') {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        var equalsConstructorPrototypeIfNotBuggy = function (o) {
          if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object) {
          var isObject = object !== null && typeof object === 'object';
          var isFunction = toStr.call(object) === '[object Function]';
          var isArguments = isArgs(object);
          var isString = isObject && toStr.call(object) === '[object String]';
          var theKeys = [];
          if (!isObject && !isFunction && !isArguments) {
            throw new TypeError('Object.keys called on a non-object');
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object.length > 0 && !has.call(object, 0)) {
            for (var i = 0; i < object.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object.length > 0) {
            for (var j = 0; j < object.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object) {
              if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      module.exports = keysShim;
    },
    3464: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var slice = Array.prototype.slice;
      var isArgs = __webpack_require__(801);
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : __webpack_require__(5691);
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function () {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object) {
              if (isArgs(object)) {
                return originalKeys(slice.call(object));
              }
              return originalKeys(object);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    },
    801: module => {
      "use strict";

      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === '[object Arguments]';
        if (!isArgs) {
          isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
        }
        return isArgs;
      };
    },
    1589: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var objectKeys = __webpack_require__(3464);
      var hasSymbols = __webpack_require__(6679)();
      var callBound = __webpack_require__(2680);
      var toObject = Object;
      var $push = callBound('Array.prototype.push');
      var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
      var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
      module.exports = function assign(target, source1) {
        if (target == null) {
          throw new TypeError('target must be an object');
        }
        var to = toObject(target);
        if (arguments.length === 1) {
          return to;
        }
        for (var s = 1; s < arguments.length; ++s) {
          var from = toObject(arguments[s]);
          var keys = objectKeys(from);
          var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
          if (getSymbols) {
            var syms = getSymbols(from);
            for (var j = 0; j < syms.length; ++j) {
              var key = syms[j];
              if ($propIsEnumerable(from, key)) {
                $push(keys, key);
              }
            }
          }
          for (var i = 0; i < keys.length; ++i) {
            var nextKey = keys[i];
            if ($propIsEnumerable(from, nextKey)) {
              var propValue = from[nextKey];
              to[nextKey] = propValue;
            }
          }
        }
        return to;
      };
    },
    3347: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var implementation = __webpack_require__(1589);
      var lacksProperEnumerationOrder = function () {
        if (!Object.assign) {
          return false;
        }
        var str = 'abcdefghijklmnopqrst';
        var letters = str.split('');
        var map = {};
        for (var i = 0; i < letters.length; ++i) {
          map[letters[i]] = letters[i];
        }
        var obj = Object.assign({}, map);
        var actual = '';
        for (var k in obj) {
          actual += k;
        }
        return str !== actual;
      };
      var assignHasPendingExceptions = function () {
        if (!Object.assign || !Object.preventExtensions) {
          return false;
        }
        var thrower = Object.preventExtensions({
          1: 2
        });
        try {
          Object.assign(thrower, 'xy');
        } catch (e) {
          return thrower[1] === 'y';
        }
        return false;
      };
      module.exports = function getPolyfill() {
        if (!Object.assign) {
          return implementation;
        }
        if (lacksProperEnumerationOrder()) {
          return implementation;
        }
        if (assignHasPendingExceptions()) {
          return implementation;
        }
        return Object.assign;
      };
    },
    1023: module => {
      "use strict";

      function assertPath(path) {
        if (typeof path !== 'string') {
          throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
        }
      }
      function normalizeStringPosix(path, allowAboveRoot) {
        var res = '';
        var lastSegmentLength = 0;
        var lastSlash = -1;
        var dots = 0;
        var code;
        for (var i = 0; i <= path.length; ++i) {
          if (i < path.length) code = path.charCodeAt(i);else if (code === 47) break;else code = 47;
          if (code === 47) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
              if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                if (res.length > 2) {
                  var lastSlashIndex = res.lastIndexOf('/');
                  if (lastSlashIndex !== res.length - 1) {
                    if (lastSlashIndex === -1) {
                      res = '';
                      lastSegmentLength = 0;
                    } else {
                      res = res.slice(0, lastSlashIndex);
                      lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                    }
                    lastSlash = i;
                    dots = 0;
                    continue;
                  }
                } else if (res.length === 2 || res.length === 1) {
                  res = '';
                  lastSegmentLength = 0;
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              }
              if (allowAboveRoot) {
                if (res.length > 0) res += '/..';else res = '..';
                lastSegmentLength = 2;
              }
            } else {
              if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);
              lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
          } else if (code === 46 && dots !== -1) {
            ++dots;
          } else {
            dots = -1;
          }
        }
        return res;
      }
      function _format(sep, pathObject) {
        var dir = pathObject.dir || pathObject.root;
        var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
        if (!dir) {
          return base;
        }
        if (dir === pathObject.root) {
          return dir + base;
        }
        return dir + sep + base;
      }
      var posix = {
        resolve: function resolve() {
          var resolvedPath = '';
          var resolvedAbsolute = false;
          var cwd;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path;
            if (i >= 0) path = arguments[i];else {
              if (cwd === undefined) cwd = {
                "browser": true,
                "env": {},
                "versions": {
                  "node": "v16.20.0"
                }
              }.cwd();
              path = cwd;
            }
            assertPath(path);
            if (path.length === 0) {
              continue;
            }
            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47;
          }
          resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
          if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';
          } else if (resolvedPath.length > 0) {
            return resolvedPath;
          } else {
            return '.';
          }
        },
        normalize: function normalize(path) {
          assertPath(path);
          if (path.length === 0) return '.';
          var isAbsolute = path.charCodeAt(0) === 47;
          var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
          path = normalizeStringPosix(path, !isAbsolute);
          if (path.length === 0 && !isAbsolute) path = '.';
          if (path.length > 0 && trailingSeparator) path += '/';
          if (isAbsolute) return '/' + path;
          return path;
        },
        isAbsolute: function isAbsolute(path) {
          assertPath(path);
          return path.length > 0 && path.charCodeAt(0) === 47;
        },
        join: function join() {
          if (arguments.length === 0) return '.';
          var joined;
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === undefined) joined = arg;else joined += '/' + arg;
            }
          }
          if (joined === undefined) return '.';
          return posix.normalize(joined);
        },
        relative: function relative(from, to) {
          assertPath(from);
          assertPath(to);
          if (from === to) return '';
          from = posix.resolve(from);
          to = posix.resolve(to);
          if (from === to) return '';
          var fromStart = 1;
          for (; fromStart < from.length; ++fromStart) {
            if (from.charCodeAt(fromStart) !== 47) break;
          }
          var fromEnd = from.length;
          var fromLen = fromEnd - fromStart;
          var toStart = 1;
          for (; toStart < to.length; ++toStart) {
            if (to.charCodeAt(toStart) !== 47) break;
          }
          var toEnd = to.length;
          var toLen = toEnd - toStart;
          var length = fromLen < toLen ? fromLen : toLen;
          var lastCommonSep = -1;
          var i = 0;
          for (; i <= length; ++i) {
            if (i === length) {
              if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                  return to.slice(toStart + i + 1);
                } else if (i === 0) {
                  return to.slice(toStart + i);
                }
              } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                  lastCommonSep = i;
                } else if (i === 0) {
                  lastCommonSep = 0;
                }
              }
              break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode) break;else if (fromCode === 47) lastCommonSep = i;
          }
          var out = '';
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === 47) {
              if (out.length === 0) out += '..';else out += '/..';
            }
          }
          if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47) ++toStart;
            return to.slice(toStart);
          }
        },
        _makeLong: function _makeLong(path) {
          return path;
        },
        dirname: function dirname(path) {
          assertPath(path);
          if (path.length === 0) return '.';
          var code = path.charCodeAt(0);
          var hasRoot = code === 47;
          var end = -1;
          var matchedSlash = true;
          for (var i = path.length - 1; i >= 1; --i) {
            code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) return hasRoot ? '/' : '.';
          if (hasRoot && end === 1) return '//';
          return path.slice(0, end);
        },
        basename: function basename(path, ext) {
          if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
          assertPath(path);
          var start = 0;
          var end = -1;
          var matchedSlash = true;
          var i;
          if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path) return '';
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
            return path.slice(start, end);
          } else {
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1) return '';
            return path.slice(start, end);
          }
        },
        extname: function extname(path) {
          assertPath(path);
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var preDotState = 0;
          for (var i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return '';
          }
          return path.slice(startDot, end);
        },
        format: function format(pathObject) {
          if (pathObject === null || typeof pathObject !== 'object') {
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
          }
          return _format('/', pathObject);
        },
        parse: function parse(path) {
          assertPath(path);
          var ret = {
            root: '',
            dir: '',
            base: '',
            ext: '',
            name: ''
          };
          if (path.length === 0) return ret;
          var code = path.charCodeAt(0);
          var isAbsolute = code === 47;
          var start;
          if (isAbsolute) {
            ret.root = '/';
            start = 1;
          } else {
            start = 0;
          }
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var i = path.length - 1;
          var preDotState = 0;
          for (; i >= start; --i) {
            code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path.slice(1, startDot);
              ret.base = path.slice(1, end);
            } else {
              ret.name = path.slice(startPart, startDot);
              ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
          }
          if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';
          return ret;
        },
        sep: '/',
        delimiter: ':',
        win32: null,
        posix: null
      };
      posix.posix = posix;
      module.exports = posix;
    },
    7847: (module, __unused_webpack_exports, __webpack_require__) => {
      const ANY = Symbol('SemVer ANY');
      class Comparator {
        static get ANY() {
          return ANY;
        }
        constructor(comp, options) {
          options = parseOptions(options);
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          comp = comp.trim().split(/\s+/).join(' ');
          debug('comparator', comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = '';
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug('comp', this);
        }
        parse(comp) {
          const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
          const m = comp.match(r);
          if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
          }
          this.operator = m[1] !== undefined ? m[1] : '';
          if (this.operator === '=') {
            this.operator = '';
          }
          if (!m[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer(m[2], this.options.loose);
          }
        }
        toString() {
          return this.value;
        }
        test(version) {
          debug('Comparator.test', version, this.options.loose);
          if (this.semver === ANY || version === ANY) {
            return true;
          }
          if (typeof version === 'string') {
            try {
              version = new SemVer(version, this.options);
            } catch (er) {
              return false;
            }
          }
          return cmp(version, this.operator, this.semver, this.options);
        }
        intersects(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError('a Comparator is required');
          }
          if (this.operator === '') {
            if (this.value === '') {
              return true;
            }
            return new Range(comp.value, options).test(this.value);
          } else if (comp.operator === '') {
            if (comp.value === '') {
              return true;
            }
            return new Range(this.value, options).test(comp.semver);
          }
          options = parseOptions(options);
          if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
            return false;
          }
          if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
            return false;
          }
          if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
            return true;
          }
          if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
            return true;
          }
          if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
            return true;
          }
          if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {
            return true;
          }
          if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {
            return true;
          }
          return false;
        }
      }
      module.exports = Comparator;
      const parseOptions = __webpack_require__(1388);
      const {
        safeRe: re,
        t
      } = __webpack_require__(4808);
      const cmp = __webpack_require__(8117);
      const debug = __webpack_require__(952);
      const SemVer = __webpack_require__(2435);
      const Range = __webpack_require__(6843);
    },
    6843: (module, __unused_webpack_exports, __webpack_require__) => {
      class Range {
        constructor(range, options) {
          options = parseOptions(options);
          if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
              return range;
            } else {
              return new Range(range.raw, options);
            }
          }
          if (range instanceof Comparator) {
            this.raw = range.value;
            this.set = [[range]];
            this.format();
            return this;
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range.trim().split(/\s+/).join(' ');
          this.set = this.raw.split('||').map(r => this.parseRange(r.trim())).filter(c => c.length);
          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
          }
          if (this.set.length > 1) {
            const first = this.set[0];
            this.set = this.set.filter(c => !isNullSet(c[0]));
            if (this.set.length === 0) {
              this.set = [first];
            } else if (this.set.length > 1) {
              for (const c of this.set) {
                if (c.length === 1 && isAny(c[0])) {
                  this.set = [c];
                  break;
                }
              }
            }
          }
          this.format();
        }
        format() {
          this.range = this.set.map(comps => comps.join(' ').trim()).join('||').trim();
          return this.range;
        }
        toString() {
          return this.range;
        }
        parseRange(range) {
          const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
          const memoKey = memoOpts + ':' + range;
          const cached = cache.get(memoKey);
          if (cached) {
            return cached;
          }
          const loose = this.options.loose;
          const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
          debug('hyphen replace', range);
          range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
          debug('comparator trim', range);
          range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
          debug('tilde trim', range);
          range = range.replace(re[t.CARETTRIM], caretTrimReplace);
          debug('caret trim', range);
          let rangeList = range.split(' ').map(comp => parseComparator(comp, this.options)).join(' ').split(/\s+/).map(comp => replaceGTE0(comp, this.options));
          if (loose) {
            rangeList = rangeList.filter(comp => {
              debug('loose invalid filter', comp, this.options);
              return !!comp.match(re[t.COMPARATORLOOSE]);
            });
          }
          debug('range list', rangeList);
          const rangeMap = new Map();
          const comparators = rangeList.map(comp => new Comparator(comp, this.options));
          for (const comp of comparators) {
            if (isNullSet(comp)) {
              return [comp];
            }
            rangeMap.set(comp.value, comp);
          }
          if (rangeMap.size > 1 && rangeMap.has('')) {
            rangeMap.delete('');
          }
          const result = [...rangeMap.values()];
          cache.set(memoKey, result);
          return result;
        }
        intersects(range, options) {
          if (!(range instanceof Range)) {
            throw new TypeError('a Range is required');
          }
          return this.set.some(thisComparators => {
            return isSatisfiable(thisComparators, options) && range.set.some(rangeComparators => {
              return isSatisfiable(rangeComparators, options) && thisComparators.every(thisComparator => {
                return rangeComparators.every(rangeComparator => {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        }
        test(version) {
          if (!version) {
            return false;
          }
          if (typeof version === 'string') {
            try {
              version = new SemVer(version, this.options);
            } catch (er) {
              return false;
            }
          }
          for (let i = 0; i < this.set.length; i++) {
            if (testSet(this.set[i], version, this.options)) {
              return true;
            }
          }
          return false;
        }
      }
      module.exports = Range;
      const LRU = __webpack_require__(7105);
      const cache = new LRU({
        max: 1000
      });
      const parseOptions = __webpack_require__(1388);
      const Comparator = __webpack_require__(7847);
      const debug = __webpack_require__(952);
      const SemVer = __webpack_require__(2435);
      const {
        safeRe: re,
        t,
        comparatorTrimReplace,
        tildeTrimReplace,
        caretTrimReplace
      } = __webpack_require__(4808);
      const {
        FLAG_INCLUDE_PRERELEASE,
        FLAG_LOOSE
      } = __webpack_require__(5558);
      const isNullSet = c => c.value === '<0.0.0-0';
      const isAny = c => c.value === '';
      const isSatisfiable = (comparators, options) => {
        let result = true;
        const remainingComparators = comparators.slice();
        let testComparator = remainingComparators.pop();
        while (result && remainingComparators.length) {
          result = remainingComparators.every(otherComparator => {
            return testComparator.intersects(otherComparator, options);
          });
          testComparator = remainingComparators.pop();
        }
        return result;
      };
      const parseComparator = (comp, options) => {
        debug('comp', comp, options);
        comp = replaceCarets(comp, options);
        debug('caret', comp);
        comp = replaceTildes(comp, options);
        debug('tildes', comp);
        comp = replaceXRanges(comp, options);
        debug('xrange', comp);
        comp = replaceStars(comp, options);
        debug('stars', comp);
        return comp;
      };
      const isX = id => !id || id.toLowerCase() === 'x' || id === '*';
      const replaceTildes = (comp, options) => {
        return comp.trim().split(/\s+/).map(c => replaceTilde(c, options)).join(' ');
      };
      const replaceTilde = (comp, options) => {
        const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
        return comp.replace(r, (_, M, m, p, pr) => {
          debug('tilde', comp, _, M, m, p, pr);
          let ret;
          if (isX(M)) {
            ret = '';
          } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
          } else if (pr) {
            debug('replaceTilde pr', pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
          }
          debug('tilde return', ret);
          return ret;
        });
      };
      const replaceCarets = (comp, options) => {
        return comp.trim().split(/\s+/).map(c => replaceCaret(c, options)).join(' ');
      };
      const replaceCaret = (comp, options) => {
        debug('caret', comp, options);
        const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
        const z = options.includePrerelease ? '-0' : '';
        return comp.replace(r, (_, M, m, p, pr) => {
          debug('caret', comp, _, M, m, p, pr);
          let ret;
          if (isX(M)) {
            ret = '';
          } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            if (M === '0') {
              ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
              ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
          } else if (pr) {
            debug('replaceCaret pr', pr);
            if (M === '0') {
              if (m === '0') {
                ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
          } else {
            debug('no pr');
            if (M === '0') {
              if (m === '0') {
                ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
          }
          debug('caret return', ret);
          return ret;
        });
      };
      const replaceXRanges = (comp, options) => {
        debug('replaceXRanges', comp, options);
        return comp.split(/\s+/).map(c => replaceXRange(c, options)).join(' ');
      };
      const replaceXRange = (comp, options) => {
        comp = comp.trim();
        const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
        return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
          debug('xRange', comp, ret, gtlt, M, m, p, pr);
          const xM = isX(M);
          const xm = xM || isX(m);
          const xp = xm || isX(p);
          const anyX = xp;
          if (gtlt === '=' && anyX) {
            gtlt = '';
          }
          pr = options.includePrerelease ? '-0' : '';
          if (xM) {
            if (gtlt === '>' || gtlt === '<') {
              ret = '<0.0.0-0';
            } else {
              ret = '*';
            }
          } else if (gtlt && anyX) {
            if (xm) {
              m = 0;
            }
            p = 0;
            if (gtlt === '>') {
              gtlt = '>=';
              if (xm) {
                M = +M + 1;
                m = 0;
                p = 0;
              } else {
                m = +m + 1;
                p = 0;
              }
            } else if (gtlt === '<=') {
              gtlt = '<';
              if (xm) {
                M = +M + 1;
              } else {
                m = +m + 1;
              }
            }
            if (gtlt === '<') {
              pr = '-0';
            }
            ret = `${gtlt + M}.${m}.${p}${pr}`;
          } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
          } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
          }
          debug('xRange return', ret);
          return ret;
        });
      };
      const replaceStars = (comp, options) => {
        debug('replaceStars', comp, options);
        return comp.trim().replace(re[t.STAR], '');
      };
      const replaceGTE0 = (comp, options) => {
        debug('replaceGTE0', comp, options);
        return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
      };
      const hyphenReplace = incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
        if (isX(fM)) {
          from = '';
        } else if (isX(fm)) {
          from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
        } else if (isX(fp)) {
          from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
        } else if (fpr) {
          from = `>=${from}`;
        } else {
          from = `>=${from}${incPr ? '-0' : ''}`;
        }
        if (isX(tM)) {
          to = '';
        } else if (isX(tm)) {
          to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
          to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
          to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
          to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
          to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
      };
      const testSet = (set, version, options) => {
        for (let i = 0; i < set.length; i++) {
          if (!set[i].test(version)) {
            return false;
          }
        }
        if (version.prerelease.length && !options.includePrerelease) {
          for (let i = 0; i < set.length; i++) {
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
              continue;
            }
            if (set[i].semver.prerelease.length > 0) {
              const allowed = set[i].semver;
              if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                return true;
              }
            }
          }
          return false;
        }
        return true;
      };
    },
    2435: (module, __unused_webpack_exports, __webpack_require__) => {
      const debug = __webpack_require__(952);
      const {
        MAX_LENGTH,
        MAX_SAFE_INTEGER
      } = __webpack_require__(5558);
      const {
        safeRe: re,
        t
      } = __webpack_require__(4808);
      const parseOptions = __webpack_require__(1388);
      const {
        compareIdentifiers
      } = __webpack_require__(4935);
      class SemVer {
        constructor(version, options) {
          options = parseOptions(options);
          if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
              return version;
            } else {
              version = version.version;
            }
          } else if (typeof version !== 'string') {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
          }
          if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
          }
          debug('SemVer', version, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
          }
          this.raw = version;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError('Invalid major version');
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError('Invalid minor version');
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError('Invalid patch version');
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split('.').map(id => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split('.') : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join('.')}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug('SemVer.compare', this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === 'string' && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug('prerelease compare', i, a, b);
            if (a === undefined && b === undefined) {
              return 0;
            } else if (b === undefined) {
              return 1;
            } else if (a === undefined) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          let i = 0;
          do {
            const a = this.build[i];
            const b = other.build[i];
            debug('prerelease compare', i, a, b);
            if (a === undefined && b === undefined) {
              return 0;
            } else if (b === undefined) {
              return 1;
            } else if (a === undefined) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        inc(release, identifier, identifierBase) {
          switch (release) {
            case 'premajor':
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc('pre', identifier, identifierBase);
              break;
            case 'preminor':
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc('pre', identifier, identifierBase);
              break;
            case 'prepatch':
              this.prerelease.length = 0;
              this.inc('patch', identifier, identifierBase);
              this.inc('pre', identifier, identifierBase);
              break;
            case 'prerelease':
              if (this.prerelease.length === 0) {
                this.inc('patch', identifier, identifierBase);
              }
              this.inc('pre', identifier, identifierBase);
              break;
            case 'major':
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case 'minor':
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case 'patch':
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case 'pre':
              {
                const base = Number(identifierBase) ? 1 : 0;
                if (!identifier && identifierBase === false) {
                  throw new Error('invalid increment argument: identifier is empty');
                }
                if (this.prerelease.length === 0) {
                  this.prerelease = [base];
                } else {
                  let i = this.prerelease.length;
                  while (--i >= 0) {
                    if (typeof this.prerelease[i] === 'number') {
                      this.prerelease[i]++;
                      i = -2;
                    }
                  }
                  if (i === -1) {
                    if (identifier === this.prerelease.join('.') && identifierBase === false) {
                      throw new Error('invalid increment argument: identifier already exists');
                    }
                    this.prerelease.push(base);
                  }
                }
                if (identifier) {
                  let prerelease = [identifier, base];
                  if (identifierBase === false) {
                    prerelease = [identifier];
                  }
                  if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                    if (isNaN(this.prerelease[1])) {
                      this.prerelease = prerelease;
                    }
                  } else {
                    this.prerelease = prerelease;
                  }
                }
                break;
              }
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.raw = this.format();
          if (this.build.length) {
            this.raw += `+${this.build.join('.')}`;
          }
          return this;
        }
      }
      module.exports = SemVer;
    },
    6694: (module, __unused_webpack_exports, __webpack_require__) => {
      const parse = __webpack_require__(9943);
      const clean = (version, options) => {
        const s = parse(version.trim().replace(/^[=v]+/, ''), options);
        return s ? s.version : null;
      };
      module.exports = clean;
    },
    8117: (module, __unused_webpack_exports, __webpack_require__) => {
      const eq = __webpack_require__(3276);
      const neq = __webpack_require__(7893);
      const gt = __webpack_require__(6379);
      const gte = __webpack_require__(8463);
      const lt = __webpack_require__(1897);
      const lte = __webpack_require__(6298);
      const cmp = (a, op, b, loose) => {
        switch (op) {
          case '===':
            if (typeof a === 'object') {
              a = a.version;
            }
            if (typeof b === 'object') {
              b = b.version;
            }
            return a === b;
          case '!==':
            if (typeof a === 'object') {
              a = a.version;
            }
            if (typeof b === 'object') {
              b = b.version;
            }
            return a !== b;
          case '':
          case '=':
          case '==':
            return eq(a, b, loose);
          case '!=':
            return neq(a, b, loose);
          case '>':
            return gt(a, b, loose);
          case '>=':
            return gte(a, b, loose);
          case '<':
            return lt(a, b, loose);
          case '<=':
            return lte(a, b, loose);
          default:
            throw new TypeError(`Invalid operator: ${op}`);
        }
      };
      module.exports = cmp;
    },
    8686: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const parse = __webpack_require__(9943);
      const {
        safeRe: re,
        t
      } = __webpack_require__(4808);
      const coerce = (version, options) => {
        if (version instanceof SemVer) {
          return version;
        }
        if (typeof version === 'number') {
          version = String(version);
        }
        if (typeof version !== 'string') {
          return null;
        }
        options = options || {};
        let match = null;
        if (!options.rtl) {
          match = version.match(re[t.COERCE]);
        } else {
          let next;
          while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
              match = next;
            }
            re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
          }
          re[t.COERCERTL].lastIndex = -1;
        }
        if (match === null) {
          return null;
        }
        return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options);
      };
      module.exports = coerce;
    },
    5914: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const compareBuild = (a, b, loose) => {
        const versionA = new SemVer(a, loose);
        const versionB = new SemVer(b, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
      };
      module.exports = compareBuild;
    },
    5404: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(2271);
      const compareLoose = (a, b) => compare(a, b, true);
      module.exports = compareLoose;
    },
    2271: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
      module.exports = compare;
    },
    6007: (module, __unused_webpack_exports, __webpack_require__) => {
      const parse = __webpack_require__(9943);
      const diff = (version1, version2) => {
        const v1 = parse(version1, null, true);
        const v2 = parse(version2, null, true);
        const comparison = v1.compare(v2);
        if (comparison === 0) {
          return null;
        }
        const v1Higher = comparison > 0;
        const highVersion = v1Higher ? v1 : v2;
        const lowVersion = v1Higher ? v2 : v1;
        const highHasPre = !!highVersion.prerelease.length;
        const lowHasPre = !!lowVersion.prerelease.length;
        if (lowHasPre && !highHasPre) {
          if (!lowVersion.patch && !lowVersion.minor) {
            return 'major';
          }
          if (highVersion.patch) {
            return 'patch';
          }
          if (highVersion.minor) {
            return 'minor';
          }
          return 'major';
        }
        const prefix = highHasPre ? 'pre' : '';
        if (v1.major !== v2.major) {
          return prefix + 'major';
        }
        if (v1.minor !== v2.minor) {
          return prefix + 'minor';
        }
        if (v1.patch !== v2.patch) {
          return prefix + 'patch';
        }
        return 'prerelease';
      };
      module.exports = diff;
    },
    3276: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(2271);
      const eq = (a, b, loose) => compare(a, b, loose) === 0;
      module.exports = eq;
    },
    6379: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(2271);
      const gt = (a, b, loose) => compare(a, b, loose) > 0;
      module.exports = gt;
    },
    8463: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(2271);
      const gte = (a, b, loose) => compare(a, b, loose) >= 0;
      module.exports = gte;
    },
    6360: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const inc = (version, release, options, identifier, identifierBase) => {
        if (typeof options === 'string') {
          identifierBase = identifier;
          identifier = options;
          options = undefined;
        }
        try {
          return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
        } catch (er) {
          return null;
        }
      };
      module.exports = inc;
    },
    1897: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(2271);
      const lt = (a, b, loose) => compare(a, b, loose) < 0;
      module.exports = lt;
    },
    6298: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(2271);
      const lte = (a, b, loose) => compare(a, b, loose) <= 0;
      module.exports = lte;
    },
    4551: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const major = (a, loose) => new SemVer(a, loose).major;
      module.exports = major;
    },
    469: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const minor = (a, loose) => new SemVer(a, loose).minor;
      module.exports = minor;
    },
    7893: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(2271);
      const neq = (a, b, loose) => compare(a, b, loose) !== 0;
      module.exports = neq;
    },
    9943: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const parse = (version, options, throwErrors = false) => {
        if (version instanceof SemVer) {
          return version;
        }
        try {
          return new SemVer(version, options);
        } catch (er) {
          if (!throwErrors) {
            return null;
          }
          throw er;
        }
      };
      module.exports = parse;
    },
    4250: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const patch = (a, loose) => new SemVer(a, loose).patch;
      module.exports = patch;
    },
    8204: (module, __unused_webpack_exports, __webpack_require__) => {
      const parse = __webpack_require__(9943);
      const prerelease = (version, options) => {
        const parsed = parse(version, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
      };
      module.exports = prerelease;
    },
    733: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(2271);
      const rcompare = (a, b, loose) => compare(b, a, loose);
      module.exports = rcompare;
    },
    2961: (module, __unused_webpack_exports, __webpack_require__) => {
      const compareBuild = __webpack_require__(5914);
      const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
      module.exports = rsort;
    },
    9844: (module, __unused_webpack_exports, __webpack_require__) => {
      const Range = __webpack_require__(6843);
      const satisfies = (version, range, options) => {
        try {
          range = new Range(range, options);
        } catch (er) {
          return false;
        }
        return range.test(version);
      };
      module.exports = satisfies;
    },
    1116: (module, __unused_webpack_exports, __webpack_require__) => {
      const compareBuild = __webpack_require__(5914);
      const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
      module.exports = sort;
    },
    7230: (module, __unused_webpack_exports, __webpack_require__) => {
      const parse = __webpack_require__(9943);
      const valid = (version, options) => {
        const v = parse(version, options);
        return v ? v.version : null;
      };
      module.exports = valid;
    },
    7699: (module, __unused_webpack_exports, __webpack_require__) => {
      const internalRe = __webpack_require__(4808);
      const constants = __webpack_require__(5558);
      const SemVer = __webpack_require__(2435);
      const identifiers = __webpack_require__(4935);
      const parse = __webpack_require__(9943);
      const valid = __webpack_require__(7230);
      const clean = __webpack_require__(6694);
      const inc = __webpack_require__(6360);
      const diff = __webpack_require__(6007);
      const major = __webpack_require__(4551);
      const minor = __webpack_require__(469);
      const patch = __webpack_require__(4250);
      const prerelease = __webpack_require__(8204);
      const compare = __webpack_require__(2271);
      const rcompare = __webpack_require__(733);
      const compareLoose = __webpack_require__(5404);
      const compareBuild = __webpack_require__(5914);
      const sort = __webpack_require__(1116);
      const rsort = __webpack_require__(2961);
      const gt = __webpack_require__(6379);
      const lt = __webpack_require__(1897);
      const eq = __webpack_require__(3276);
      const neq = __webpack_require__(7893);
      const gte = __webpack_require__(8463);
      const lte = __webpack_require__(6298);
      const cmp = __webpack_require__(8117);
      const coerce = __webpack_require__(8686);
      const Comparator = __webpack_require__(7847);
      const Range = __webpack_require__(6843);
      const satisfies = __webpack_require__(9844);
      const toComparators = __webpack_require__(8865);
      const maxSatisfying = __webpack_require__(3727);
      const minSatisfying = __webpack_require__(4338);
      const minVersion = __webpack_require__(1542);
      const validRange = __webpack_require__(6240);
      const outside = __webpack_require__(9106);
      const gtr = __webpack_require__(995);
      const ltr = __webpack_require__(7805);
      const intersects = __webpack_require__(2013);
      const simplifyRange = __webpack_require__(1338);
      const subset = __webpack_require__(3122);
      module.exports = {
        parse,
        valid,
        clean,
        inc,
        diff,
        major,
        minor,
        patch,
        prerelease,
        compare,
        rcompare,
        compareLoose,
        compareBuild,
        sort,
        rsort,
        gt,
        lt,
        eq,
        neq,
        gte,
        lte,
        cmp,
        coerce,
        Comparator,
        Range,
        satisfies,
        toComparators,
        maxSatisfying,
        minSatisfying,
        minVersion,
        validRange,
        outside,
        gtr,
        ltr,
        intersects,
        simplifyRange,
        subset,
        SemVer,
        re: internalRe.re,
        src: internalRe.src,
        tokens: internalRe.t,
        SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
        RELEASE_TYPES: constants.RELEASE_TYPES,
        compareIdentifiers: identifiers.compareIdentifiers,
        rcompareIdentifiers: identifiers.rcompareIdentifiers
      };
    },
    5558: module => {
      const SEMVER_SPEC_VERSION = '2.0.0';
      const MAX_LENGTH = 256;
      const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
      const MAX_SAFE_COMPONENT_LENGTH = 16;
      const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
      const RELEASE_TYPES = ['major', 'premajor', 'minor', 'preminor', 'patch', 'prepatch', 'prerelease'];
      module.exports = {
        MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER,
        RELEASE_TYPES,
        SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 0b001,
        FLAG_LOOSE: 0b010
      };
    },
    952: module => {
      const debug = typeof {
        "browser": true,
        "env": {},
        "versions": {
          "node": "v16.20.0"
        }
      } === 'object' && {
        "browser": true,
        "env": {},
        "versions": {
          "node": "v16.20.0"
        }
      }.env && false && 0 ? 0 : () => {};
      module.exports = debug;
    },
    4935: module => {
      const numeric = /^[0-9]+$/;
      const compareIdentifiers = (a, b) => {
        const anum = numeric.test(a);
        const bnum = numeric.test(b);
        if (anum && bnum) {
          a = +a;
          b = +b;
        }
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      };
      const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
      module.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    },
    1388: module => {
      const looseOption = Object.freeze({
        loose: true
      });
      const emptyOpts = Object.freeze({});
      const parseOptions = options => {
        if (!options) {
          return emptyOpts;
        }
        if (typeof options !== 'object') {
          return looseOption;
        }
        return options;
      };
      module.exports = parseOptions;
    },
    4808: (module, exports, __webpack_require__) => {
      const {
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_LENGTH
      } = __webpack_require__(5558);
      const debug = __webpack_require__(952);
      exports = module.exports = {};
      const re = exports.re = [];
      const safeRe = exports.safeRe = [];
      const src = exports.src = [];
      const t = exports.t = {};
      let R = 0;
      const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
      const safeRegexReplacements = [['\\s', 1], ['\\d', MAX_LENGTH], [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]];
      const makeSafeRegex = value => {
        for (const [token, max] of safeRegexReplacements) {
          value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
        }
        return value;
      };
      const createToken = (name, value, isGlobal) => {
        const safe = makeSafeRegex(value);
        const index = R++;
        debug(name, index, value);
        t[name] = index;
        src[index] = value;
        re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
        safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
      };
      createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
      createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
      createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
      createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
      createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
      createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
      createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
      createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
      createToken('FULL', `^${src[t.FULLPLAIN]}$`);
      createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
      createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
      createToken('GTLT', '((?:<|>)?=?)');
      createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
      createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
      createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
      createToken('COERCE', `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\d])`);
      createToken('COERCERTL', src[t.COERCE], true);
      createToken('LONETILDE', '(?:~>?)');
      createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports.tildeTrimReplace = '$1~';
      createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken('LONECARET', '(?:\\^)');
      createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports.caretTrimReplace = '$1^';
      createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
      createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
      exports.comparatorTrimReplace = '$1$2$3';
      createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
      createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
      createToken('STAR', '(<|>)?=?\\s*\\*');
      createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
      createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
    },
    995: (module, __unused_webpack_exports, __webpack_require__) => {
      const outside = __webpack_require__(9106);
      const gtr = (version, range, options) => outside(version, range, '>', options);
      module.exports = gtr;
    },
    2013: (module, __unused_webpack_exports, __webpack_require__) => {
      const Range = __webpack_require__(6843);
      const intersects = (r1, r2, options) => {
        r1 = new Range(r1, options);
        r2 = new Range(r2, options);
        return r1.intersects(r2, options);
      };
      module.exports = intersects;
    },
    7805: (module, __unused_webpack_exports, __webpack_require__) => {
      const outside = __webpack_require__(9106);
      const ltr = (version, range, options) => outside(version, range, '<', options);
      module.exports = ltr;
    },
    3727: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const Range = __webpack_require__(6843);
      const maxSatisfying = (versions, range, options) => {
        let max = null;
        let maxSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions.forEach(v => {
          if (rangeObj.test(v)) {
            if (!max || maxSV.compare(v) === -1) {
              max = v;
              maxSV = new SemVer(max, options);
            }
          }
        });
        return max;
      };
      module.exports = maxSatisfying;
    },
    4338: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const Range = __webpack_require__(6843);
      const minSatisfying = (versions, range, options) => {
        let min = null;
        let minSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions.forEach(v => {
          if (rangeObj.test(v)) {
            if (!min || minSV.compare(v) === 1) {
              min = v;
              minSV = new SemVer(min, options);
            }
          }
        });
        return min;
      };
      module.exports = minSatisfying;
    },
    1542: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const Range = __webpack_require__(6843);
      const gt = __webpack_require__(6379);
      const minVersion = (range, loose) => {
        range = new Range(range, loose);
        let minver = new SemVer('0.0.0');
        if (range.test(minver)) {
          return minver;
        }
        minver = new SemVer('0.0.0-0');
        if (range.test(minver)) {
          return minver;
        }
        minver = null;
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let setMin = null;
          comparators.forEach(comparator => {
            const compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
              case '>':
                if (compver.prerelease.length === 0) {
                  compver.patch++;
                } else {
                  compver.prerelease.push(0);
                }
                compver.raw = compver.format();
              case '':
              case '>=':
                if (!setMin || gt(compver, setMin)) {
                  setMin = compver;
                }
                break;
              case '<':
              case '<=':
                break;
              default:
                throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
          });
          if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
          }
        }
        if (minver && range.test(minver)) {
          return minver;
        }
        return null;
      };
      module.exports = minVersion;
    },
    9106: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(2435);
      const Comparator = __webpack_require__(7847);
      const {
        ANY
      } = Comparator;
      const Range = __webpack_require__(6843);
      const satisfies = __webpack_require__(9844);
      const gt = __webpack_require__(6379);
      const lt = __webpack_require__(1897);
      const lte = __webpack_require__(6298);
      const gte = __webpack_require__(8463);
      const outside = (version, range, hilo, options) => {
        version = new SemVer(version, options);
        range = new Range(range, options);
        let gtfn, ltefn, ltfn, comp, ecomp;
        switch (hilo) {
          case '>':
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = '>';
            ecomp = '>=';
            break;
          case '<':
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = '<';
            ecomp = '<=';
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (satisfies(version, range, options)) {
          return false;
        }
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let high = null;
          let low = null;
          comparators.forEach(comparator => {
            if (comparator.semver === ANY) {
              comparator = new Comparator('>=0.0.0');
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
              high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
              low = comparator;
            }
          });
          if (high.operator === comp || high.operator === ecomp) {
            return false;
          }
          if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
            return false;
          } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false;
          }
        }
        return true;
      };
      module.exports = outside;
    },
    1338: (module, __unused_webpack_exports, __webpack_require__) => {
      const satisfies = __webpack_require__(9844);
      const compare = __webpack_require__(2271);
      module.exports = (versions, range, options) => {
        const set = [];
        let first = null;
        let prev = null;
        const v = versions.sort((a, b) => compare(a, b, options));
        for (const version of v) {
          const included = satisfies(version, range, options);
          if (included) {
            prev = version;
            if (!first) {
              first = version;
            }
          } else {
            if (prev) {
              set.push([first, prev]);
            }
            prev = null;
            first = null;
          }
        }
        if (first) {
          set.push([first, null]);
        }
        const ranges = [];
        for (const [min, max] of set) {
          if (min === max) {
            ranges.push(min);
          } else if (!max && min === v[0]) {
            ranges.push('*');
          } else if (!max) {
            ranges.push(`>=${min}`);
          } else if (min === v[0]) {
            ranges.push(`<=${max}`);
          } else {
            ranges.push(`${min} - ${max}`);
          }
        }
        const simplified = ranges.join(' || ');
        const original = typeof range.raw === 'string' ? range.raw : String(range);
        return simplified.length < original.length ? simplified : range;
      };
    },
    3122: (module, __unused_webpack_exports, __webpack_require__) => {
      const Range = __webpack_require__(6843);
      const Comparator = __webpack_require__(7847);
      const {
        ANY
      } = Comparator;
      const satisfies = __webpack_require__(9844);
      const compare = __webpack_require__(2271);
      const subset = (sub, dom, options = {}) => {
        if (sub === dom) {
          return true;
        }
        sub = new Range(sub, options);
        dom = new Range(dom, options);
        let sawNonNull = false;
        OUTER: for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
        return true;
      };
      const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
      const minimumVersion = [new Comparator('>=0.0.0')];
      const simpleSubset = (sub, dom, options) => {
        if (sub === dom) {
          return true;
        }
        if (sub.length === 1 && sub[0].semver === ANY) {
          if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
          } else if (options.includePrerelease) {
            sub = minimumVersionWithPreRelease;
          } else {
            sub = minimumVersion;
          }
        }
        if (dom.length === 1 && dom[0].semver === ANY) {
          if (options.includePrerelease) {
            return true;
          } else {
            dom = minimumVersion;
          }
        }
        const eqSet = new Set();
        let gt, lt;
        for (const c of sub) {
          if (c.operator === '>' || c.operator === '>=') {
            gt = higherGT(gt, c, options);
          } else if (c.operator === '<' || c.operator === '<=') {
            lt = lowerLT(lt, c, options);
          } else {
            eqSet.add(c.semver);
          }
        }
        if (eqSet.size > 1) {
          return null;
        }
        let gtltComp;
        if (gt && lt) {
          gtltComp = compare(gt.semver, lt.semver, options);
          if (gtltComp > 0) {
            return null;
          } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
            return null;
          }
        }
        for (const eq of eqSet) {
          if (gt && !satisfies(eq, String(gt), options)) {
            return null;
          }
          if (lt && !satisfies(eq, String(lt), options)) {
            return null;
          }
          for (const c of dom) {
            if (!satisfies(eq, String(c), options)) {
              return false;
            }
          }
          return true;
        }
        let higher, lower;
        let hasDomLT, hasDomGT;
        let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
        let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
        if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
          needDomLTPre = false;
        }
        for (const c of dom) {
          hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
          hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
          if (gt) {
            if (needDomGTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                needDomGTPre = false;
              }
            }
            if (c.operator === '>' || c.operator === '>=') {
              higher = higherGT(gt, c, options);
              if (higher === c && higher !== gt) {
                return false;
              }
            } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
              return false;
            }
          }
          if (lt) {
            if (needDomLTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                needDomLTPre = false;
              }
            }
            if (c.operator === '<' || c.operator === '<=') {
              lower = lowerLT(lt, c, options);
              if (lower === c && lower !== lt) {
                return false;
              }
            } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
              return false;
            }
          }
          if (!c.operator && (lt || gt) && gtltComp !== 0) {
            return false;
          }
        }
        if (gt && hasDomLT && !lt && gtltComp !== 0) {
          return false;
        }
        if (lt && hasDomGT && !gt && gtltComp !== 0) {
          return false;
        }
        if (needDomGTPre || needDomLTPre) {
          return false;
        }
        return true;
      };
      const higherGT = (a, b, options) => {
        if (!a) {
          return b;
        }
        const comp = compare(a.semver, b.semver, options);
        return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
      };
      const lowerLT = (a, b, options) => {
        if (!a) {
          return b;
        }
        const comp = compare(a.semver, b.semver, options);
        return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
      };
      module.exports = subset;
    },
    8865: (module, __unused_webpack_exports, __webpack_require__) => {
      const Range = __webpack_require__(6843);
      const toComparators = (range, options) => new Range(range, options).set.map(comp => comp.map(c => c.value).join(' ').trim().split(' '));
      module.exports = toComparators;
    },
    6240: (module, __unused_webpack_exports, __webpack_require__) => {
      const Range = __webpack_require__(6843);
      const validRange = (range, options) => {
        try {
          return new Range(range, options).range || '*';
        } catch (er) {
          return null;
        }
      };
      module.exports = validRange;
    },
    3626: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "getKeys", {
        enumerable: true,
        get: function () {
          return getKeys;
        }
      });
      const _session = __webpack_require__(2686);
      async function getKeys() {
        const session = await (0, _session.getCurrentSignerSession)();
        return await session.keys();
      }
    },
    2686: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        login: function () {
          return login;
        },
        logout: function () {
          return logout;
        },
        getCurrentSignerSession: function () {
          return getCurrentSignerSession;
        }
      });
      const _cubesignersdk = __webpack_require__(4102);
      const _snapsui = __webpack_require__(3961);
      const _types = __webpack_require__(5886);
      const _rpcerrors = __webpack_require__(774);
      class SnapSessionStorage {
        async clear() {
          await snap.request({
            method: "snap_manageState",
            params: {
              operation: "clear"
            }
          });
        }
        async empty() {
          return (await this.#getState()) === null;
        }
        async save(data) {
          await snap.request({
            method: "snap_manageState",
            params: {
              operation: "update",
              newState: data
            }
          });
        }
        async retrieve() {
          const state = await this.#getState();
          if (state === null) {
            throw new Error("Snap state is empty");
          }
          return state;
        }
        async #getState() {
          const state = await snap.request({
            method: "snap_manageState",
            params: {
              operation: "get"
            }
          });
          return state;
        }
      }
      const sessionStorage = new SnapSessionStorage();
      async function login(rpc) {
        if (await sessionStorage.empty()) {
          await handleLogin(rpc);
        }
      }
      async function logout(rpc) {
        if (!(await sessionStorage.empty())) {
          await handleLogout(rpc.origin);
        }
      }
      async function handleLogin(rpc) {
        if (rpc.request.params) {
          await handleTokenBasedLogin(rpc);
        } else {
          await handleUserLogin(rpc.origin);
        }
      }
      async function handleTokenBasedLogin(rpc) {
        const shape = {
          token_base64: "string"
        };
        const params = (0, _types.sanitize)(rpc.request.params, shape);
        const secretBase64Token = params.token_base64;
        let secretApiToken;
        try {
          secretApiToken = parseAndValidateToken(secretBase64Token);
        } catch (_err) {
          throw _rpcerrors.rpcErrors.invalidParams({
            message: "Invalid RPC Params: Parameter 'token_base64' is an invalid base64 string."
          });
        }
        const approved = await snap.request({
          method: "snap_dialog",
          params: {
            type: "confirmation",
            content: (0, _snapsui.panel)([(0, _snapsui.heading)("Log in to CubeSigner"), (0, _snapsui.text)(`Do you want to let **${rpc.origin}** log you into CubeSigner?`)])
          }
        });
        if (!approved) {
          throw _rpcerrors.providerErrors.userRejectedRequest();
        }
        await sessionStorage.save(secretApiToken);
      }
      async function handleUserLogin(origin) {
        const secretInput = await snap.request({
          method: "snap_dialog",
          params: {
            type: "prompt",
            content: (0, _snapsui.panel)([(0, _snapsui.heading)("Log in to CubeSigner"), (0, _snapsui.text)(`**${origin}** is asking you to login with CubeSigner.`), (0, _snapsui.text)("Your secret API session token:")]),
            placeholder: "ewog...Q=="
          }
        });
        if (secretInput === null) {
          throw _rpcerrors.providerErrors.userRejectedRequest();
        }
        try {
          const secretApiToken = parseAndValidateToken(secretInput);
          await sessionStorage.save(secretApiToken);
        } catch (err) {
          const retry = await snap.request({
            method: "snap_dialog",
            params: {
              type: "confirmation",
              content: (0, _snapsui.panel)([(0, _snapsui.heading)("Bad API token!"), (0, _snapsui.text)("The session token you entered is not valid. The token should be a base64-encoded JSON object created with CubeSigner: cs token create"), (0, _snapsui.text)("Try again with another token?")])
            }
          });
          if (retry == true) {
            return await handleUserLogin(origin);
          }
          throw _rpcerrors.providerErrors.userRejectedRequest();
        }
      }
      async function handleLogout(origin) {
        const approved = await snap.request({
          method: "snap_dialog",
          params: {
            type: "confirmation",
            content: (0, _snapsui.panel)([(0, _snapsui.heading)("Do you want to log out?"), (0, _snapsui.text)(`**${origin}** is asking you to log out.`)])
          }
        });
        if (approved) {
          await sessionStorage.clear();
          await snap.request({
            method: "snap_dialog",
            params: {
              type: "alert",
              content: (0, _snapsui.panel)([(0, _snapsui.heading)("Token removed"), (0, _snapsui.text)(`If you want to revoke your token, use the CubeSigner: 'cs token revoke'`)])
            }
          });
        }
      }
      async function getCurrentSignerSession() {
        if (await sessionStorage.empty()) {
          throw _rpcerrors.rpcErrors.invalidRequest({
            message: "Not logged in"
          });
        }
        return _cubesignersdk.CubeSigner.loadSignerSession(sessionStorage);
      }
      function validateSignerSession(json) {
        const shape = {
          org_id: "string",
          role_id: "string",
          purpose: "string",
          token: "string",
          session_info: {
            auth_token: "string",
            auth_token_exp: "number",
            epoch: "number",
            epoch_token: "string",
            refresh_token: "string",
            refresh_token_exp: "number",
            session_id: "string"
          },
          env: {
            "Dev-CubeSignerStack": {
              ClientId: "string",
              Region: "string",
              UserPoolId: "string",
              SignerApiRoot: "string"
            }
          }
        };
        try {
          return (0, _types.sanitize)(json, shape);
        } catch (e) {
          const message = e instanceof Error ? e.message : "unknown error";
          throw _rpcerrors.rpcErrors.invalidInput({
            message: `Invalid API session token: ${message}`
          });
        }
      }
      function parseAndValidateToken(secretInput) {
        const secretB64Token = secretInput.replace(/\s/g, "");
        const secretApiToken = JSON.parse(atob(secretB64Token));
        return validateSignerSession(secretApiToken);
      }
    },
    6173: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        signBlob: function () {
          return signBlob;
        },
        signEvm: function () {
          return signEvm;
        },
        signSolana: function () {
          return signSolana;
        },
        signBtc: function () {
          return signBtc;
        }
      });
      const _types = __webpack_require__(5886);
      const _utils = __webpack_require__(6297);
      const _rpcerrors = __webpack_require__(774);
      const _snapsui = __webpack_require__(3961);
      const _session = __webpack_require__(2686);
      async function confirm(kind, key, request) {
        const approved = await snap.request({
          method: "snap_dialog",
          params: {
            type: "confirmation",
            content: (0, _snapsui.panel)([(0, _snapsui.heading)("Signature request"), (0, _snapsui.text)(`Do you want to sign the following "${kind}" request`), (0, _snapsui.copyable)(request), (0, _snapsui.text)(`with the following public key?`), (0, _snapsui.copyable)(key)])
          }
        });
        if (!approved) {
          throw _rpcerrors.providerErrors.userRejectedRequest();
        }
      }
      async function signBlob(rpc) {
        const shape = {
          keyId: "string",
          body: {
            message_base64: "string"
          }
        };
        const params = (0, _types.sanitize)(rpc.request.params, shape);
        await confirm("blob", params.keyId, JSON.stringify(params.body));
        const session = await (0, _session.getCurrentSignerSession)();
        return (await session.signBlob(params.keyId, params.body)).data();
      }
      async function signEvm(rpc) {
        const params = rpc.request.params;
        (0, _utils.assertParams)(params, "pubkey", "body");
        await confirm("evm", params.pubkey, JSON.stringify(params.body));
        const session = await (0, _session.getCurrentSignerSession)();
        return (await session.signEvm(params.pubkey, params.body)).data();
      }
      async function signSolana(rpc) {
        const params = rpc.request.params;
        (0, _utils.assertParams)(params, "pubkey", "body");
        await confirm("Solana", params.pubkey, JSON.stringify(params.body));
        const session = await (0, _session.getCurrentSignerSession)();
        return (await session.signSolana(params.pubkey, params.body)).data();
      }
      async function signBtc(rpc) {
        const params = rpc.request.params;
        (0, _utils.assertParams)(params, "pubkey", "body");
        await confirm("BTC", params.pubkey, JSON.stringify(params.body));
        const session = await (0, _session.getCurrentSignerSession)();
        return (await session.signBtc(params.pubkey, params.body)).data();
      }
    },
    5886: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        sanitize: function () {
          return sanitize;
        },
        ShapeError: function () {
          return ShapeError;
        }
      });
      function sanitize(untrustedObj, shape) {
        if (typeof untrustedObj !== "object") {
          throw new ShapeError(`Expected object, got ${typeof untrustedObj}`);
        }
        const obj = {};
        for (const [key, type] of Object.entries(shape)) {
          if (!Reflect.has(untrustedObj, key)) {
            throw new ShapeError(`Missing key: ${key}`);
          }
          const val = Reflect.get(untrustedObj, key);
          if (typeof type === "object") {
            obj[key] = sanitize(val, type);
          } else {
            if (typeof val !== type) {
              throw new ShapeError(`Invalid type for key ${key}. Expected ${type}, got ${typeof val}`);
            }
            obj[key] = val;
          }
        }
        return obj;
      }
      class ShapeError extends Error {
        constructor(message) {
          super(message);
          this.name = "ShapeError";
        }
      }
    },
    6297: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "assertParams", {
        enumerable: true,
        get: function () {
          return assertParams;
        }
      });
      const _rpcerrors = __webpack_require__(774);
      function assertParams(obj, ...paramNames) {
        paramNames.forEach(paramName => {
          if (!Reflect.has(obj, paramName)) {
            throw _rpcerrors.rpcErrors.invalidParams({
              message: `Invalid RPC Params: Parameter ${String(paramName)} is not defined`
            });
          }
        });
      }
    },
    82: module => {
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
      };
    },
    4895: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      var isArgumentsObject = __webpack_require__(2635);
      var isGeneratorFunction = __webpack_require__(3138);
      var whichTypedArray = __webpack_require__(2094);
      var isTypedArray = __webpack_require__(198);
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== 'undefined';
      var SymbolSupported = typeof Symbol !== 'undefined';
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      if (SymbolSupported) {
        var symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== 'object') {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === 'Uint8Array';
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === 'Uint8ClampedArray';
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === 'Uint16Array';
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === 'Uint32Array';
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === 'Int8Array';
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === 'Int16Array';
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === 'Int32Array';
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === 'Float32Array';
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === 'Float64Array';
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === 'BigInt64Array';
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === 'BigUint64Array';
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === '[object Map]';
      }
      isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
      function isMap(value) {
        if (typeof Map === 'undefined') {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === '[object Set]';
      }
      isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
      function isSet(value) {
        if (typeof Set === 'undefined') {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === '[object WeakMap]';
      }
      isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === 'undefined') {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === '[object WeakSet]';
      }
      isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === '[object ArrayBuffer]';
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === 'undefined') {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === '[object DataView]';
      }
      isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === 'undefined') {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === '[object SharedArrayBuffer]';
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === 'undefined') {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === 'undefined') {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === '[object AsyncFunction]';
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === '[object Map Iterator]';
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === '[object Set Iterator]';
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === '[object Generator]';
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === '[object WebAssembly.Module]';
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function () {
            throw new Error(method + ' is not supported in userland');
          }
        });
      });
    },
    3335: (__unused_webpack_module, exports, __webpack_require__) => {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function (f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(' ');
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function (x) {
          if (x === '%%') return '%';
          if (i >= len) return x;
          switch (x) {
            case '%s':
              return String(args[i++]);
            case '%d':
              return Number(args[i++]);
            case '%j':
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return '[Circular]';
              }
            default:
              return x;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += ' ' + x;
          } else {
            str += ' ' + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function (fn, msg) {
        if (typeof {
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        } !== 'undefined' && {
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        }.noDeprecation === true) {
          return fn;
        }
        if (typeof {
          "browser": true,
          "env": {},
          "versions": {
            "node": "v16.20.0"
          }
        } === 'undefined') {
          return function () {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if ({
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.throwDeprecation) {
              throw new Error(msg);
            } else if ({
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (false) {
        var debugEnv;
      }
      exports.debuglog = function (set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = {
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }.pid;
            debugs[set] = function () {
              var msg = exports.format.apply(exports, arguments);
              console.error('%s %d: %s', set, pid, msg);
            };
          } else {
            debugs[set] = function () {};
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined(ctx.depth)) ctx.depth = 2;
        if (isUndefined(ctx.colors)) ctx.colors = false;
        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        'bold': [1, 22],
        'italic': [3, 23],
        'underline': [4, 24],
        'inverse': [7, 27],
        'white': [37, 39],
        'grey': [90, 39],
        'black': [30, 39],
        'blue': [34, 39],
        'cyan': [36, 39],
        'green': [32, 39],
        'magenta': [35, 39],
        'red': [31, 39],
        'yellow': [33, 39]
      };
      inspect.styles = {
        'special': 'cyan',
        'number': 'yellow',
        'boolean': 'yellow',
        'undefined': 'grey',
        'null': 'bold',
        'string': 'green',
        'date': 'magenta',
        'regexp': 'red'
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function (val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), 'date');
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = '',
          array = false,
          braces = ['{', '}'];
        if (isArray(value)) {
          array = true;
          braces = ['[', ']'];
        }
        if (isFunction(value)) {
          var n = value.name ? ': ' + value.name : '';
          base = ' [Function' + n + ']';
        }
        if (isRegExp(value)) {
          base = ' ' + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = ' ' + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = ' ' + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          } else {
            return ctx.stylize('[Object]', 'special');
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function (key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
        if (isString(value)) {
          var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
          return ctx.stylize(simple, 'string');
        }
        if (isNumber(value)) return ctx.stylize('' + value, 'number');
        if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
        if (isNull(value)) return ctx.stylize('null', 'null');
      }
      function formatError(value) {
        return '[' + Error.prototype.toString.call(value) + ']';
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push('');
          }
        }
        keys.forEach(function (key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || {
          value: value[key]
        };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize('[Getter/Setter]', 'special');
          } else {
            str = ctx.stylize('[Getter]', 'special');
          }
        } else {
          if (desc.set) {
            str = ctx.stylize('[Setter]', 'special');
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = '[' + key + ']';
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
              if (array) {
                str = str.split('\n').map(function (line) {
                  return '  ' + line;
                }).join('\n').slice(2);
              } else {
                str = '\n' + str.split('\n').map(function (line) {
                  return '   ' + line;
                }).join('\n');
              }
            }
          } else {
            str = ctx.stylize('[Circular]', 'special');
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify('' + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, 'name');
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
          }
        }
        return name + ': ' + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function (prev, cur) {
          numLinesEst++;
          if (cur.indexOf('\n') >= 0) numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
        }
        return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
      }
      exports.types = __webpack_require__(4895);
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === 'boolean';
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === 'number';
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === 'string';
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === 'symbol';
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === '[object RegExp]';
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === '[object Date]';
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === 'function';
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = __webpack_require__(82);
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? '0' + n.toString(10) : n.toString(10);
      }
      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      function timestamp() {
        var d = new Date();
        var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
        return [d.getDate(), months[d.getMonth()], time].join(' ');
      }
      exports.log = function () {
        console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = __webpack_require__(1285);
      exports._extend = function (origin, add) {
        if (!add || !isObject(add)) return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
      exports.promisify = function promisify(original) {
        if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== 'function') {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function (resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function (err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error('Promise was rejected with a falsy value');
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== 'function') {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== 'function') {
            throw new TypeError('The last argument must be of type Function');
          }
          var self = this;
          var cb = function () {
            return maybeCb.apply(self, arguments);
          };
          original.apply(this, args).then(function (ret) {
            ({
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }).nextTick(cb.bind(null, null, ret));
          }, function (rej) {
            ({
              "browser": true,
              "env": {},
              "versions": {
                "node": "v16.20.0"
              }
            }).nextTick(callbackifyOnRejected.bind(null, rej, cb));
          });
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
        return callbackified;
      }
      exports.callbackify = callbackify;
    },
    2094: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var forEach = __webpack_require__(3243);
      var availableTypedArrays = __webpack_require__(2191);
      var callBind = __webpack_require__(9429);
      var callBound = __webpack_require__(2680);
      var gOPD = __webpack_require__(326);
      var $toString = callBound('Object.prototype.toString');
      var hasToStringTag = __webpack_require__(7226)();
      var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound('String.prototype.slice');
      var getPrototypeOf = Object.getPrototypeOf;
      var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var cache = {
        __proto__: null
      };
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function (typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            cache['$' + typedArray] = callBind(descriptor.get);
          }
        });
      } else {
        forEach(typedArrays, function (typedArray) {
          var arr = new g[typedArray]();
          cache['$' + typedArray] = callBind(arr.slice);
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var found = false;
        forEach(cache, function (getter, typedArray) {
          if (!found) {
            try {
              if ('$' + getter(value) === typedArray) {
                found = $slice(typedArray, 1);
              }
            } catch (e) {}
          }
        });
        return found;
      };
      var trySlices = function tryAllSlices(value) {
        var found = false;
        forEach(cache, function (getter, name) {
          if (!found) {
            try {
              getter(value);
              found = $slice(name, 1);
            } catch (e) {}
          }
        });
        return found;
      };
      module.exports = function whichTypedArray(value) {
        if (!value || typeof value !== 'object') {
          return false;
        }
        if (!hasToStringTag) {
          var tag = $slice($toString(value), 8, -1);
          if ($indexOf(typedArrays, tag) > -1) {
            return tag;
          }
          if (tag !== 'Object') {
            return false;
          }
          return trySlices(value);
        }
        if (!gOPD) {
          return null;
        }
        return tryTypedArrays(value);
      };
    },
    8268: module => {
      "use strict";

      module.exports = function (Yallist) {
        Yallist.prototype[Symbol.iterator] = function* () {
          for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
          }
        };
      };
    },
    8006: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      module.exports = Yallist;
      Yallist.Node = Node;
      Yallist.create = Yallist;
      function Yallist(list) {
        var self = this;
        if (!(self instanceof Yallist)) {
          self = new Yallist();
        }
        self.tail = null;
        self.head = null;
        self.length = 0;
        if (list && typeof list.forEach === 'function') {
          list.forEach(function (item) {
            self.push(item);
          });
        } else if (arguments.length > 0) {
          for (var i = 0, l = arguments.length; i < l; i++) {
            self.push(arguments[i]);
          }
        }
        return self;
      }
      Yallist.prototype.removeNode = function (node) {
        if (node.list !== this) {
          throw new Error('removing node which does not belong to this list');
        }
        var next = node.next;
        var prev = node.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node === this.head) {
          this.head = next;
        }
        if (node === this.tail) {
          this.tail = prev;
        }
        node.list.length--;
        node.next = null;
        node.prev = null;
        node.list = null;
        return next;
      };
      Yallist.prototype.unshiftNode = function (node) {
        if (node === this.head) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
          head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        this.length++;
      };
      Yallist.prototype.pushNode = function (node) {
        if (node === this.tail) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var tail = this.tail;
        node.list = this;
        node.prev = tail;
        if (tail) {
          tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
          this.head = node;
        }
        this.length++;
      };
      Yallist.prototype.push = function () {
        for (var i = 0, l = arguments.length; i < l; i++) {
          push(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.unshift = function () {
        for (var i = 0, l = arguments.length; i < l; i++) {
          unshift(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.pop = function () {
        if (!this.tail) {
          return undefined;
        }
        var res = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.shift = function () {
        if (!this.head) {
          return undefined;
        }
        var res = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.forEach = function (fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i = 0; walker !== null; i++) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.next;
        }
      };
      Yallist.prototype.forEachReverse = function (fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.prev;
        }
      };
      Yallist.prototype.get = function (n) {
        for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
          walker = walker.next;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.getReverse = function (n) {
        for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
          walker = walker.prev;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.map = function (fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.head; walker !== null;) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.next;
        }
        return res;
      };
      Yallist.prototype.mapReverse = function (fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.tail; walker !== null;) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.prev;
        }
        return res;
      };
      Yallist.prototype.reduce = function (fn, initial) {
        var acc;
        var walker = this.head;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.head) {
          walker = this.head.next;
          acc = this.head.value;
        } else {
          throw new TypeError('Reduce of empty list with no initial value');
        }
        for (var i = 0; walker !== null; i++) {
          acc = fn(acc, walker.value, i);
          walker = walker.next;
        }
        return acc;
      };
      Yallist.prototype.reduceReverse = function (fn, initial) {
        var acc;
        var walker = this.tail;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.tail) {
          walker = this.tail.prev;
          acc = this.tail.value;
        } else {
          throw new TypeError('Reduce of empty list with no initial value');
        }
        for (var i = this.length - 1; walker !== null; i--) {
          acc = fn(acc, walker.value, i);
          walker = walker.prev;
        }
        return acc;
      };
      Yallist.prototype.toArray = function () {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.head; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.next;
        }
        return arr;
      };
      Yallist.prototype.toArrayReverse = function () {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.tail; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.prev;
        }
        return arr;
      };
      Yallist.prototype.slice = function (from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
          walker = walker.next;
        }
        for (; walker !== null && i < to; i++, walker = walker.next) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.sliceReverse = function (from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
          walker = walker.prev;
        }
        for (; walker !== null && i > from; i--, walker = walker.prev) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
        if (start > this.length) {
          start = this.length - 1;
        }
        if (start < 0) {
          start = this.length + start;
        }
        for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
          walker = walker.next;
        }
        var ret = [];
        for (var i = 0; walker && i < deleteCount; i++) {
          ret.push(walker.value);
          walker = this.removeNode(walker);
        }
        if (walker === null) {
          walker = this.tail;
        }
        if (walker !== this.head && walker !== this.tail) {
          walker = walker.prev;
        }
        for (var i = 0; i < nodes.length; i++) {
          walker = insert(this, walker, nodes[i]);
        }
        return ret;
      };
      Yallist.prototype.reverse = function () {
        var head = this.head;
        var tail = this.tail;
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p = walker.prev;
          walker.prev = walker.next;
          walker.next = p;
        }
        this.head = tail;
        this.tail = head;
        return this;
      };
      function insert(self, node, value) {
        var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
        if (inserted.next === null) {
          self.tail = inserted;
        }
        if (inserted.prev === null) {
          self.head = inserted;
        }
        self.length++;
        return inserted;
      }
      function push(self, item) {
        self.tail = new Node(item, self.tail, null, self);
        if (!self.head) {
          self.head = self.tail;
        }
        self.length++;
      }
      function unshift(self, item) {
        self.head = new Node(item, null, self.head, self);
        if (!self.tail) {
          self.tail = self.head;
        }
        self.length++;
      }
      function Node(value, prev, next, list) {
        if (!(this instanceof Node)) {
          return new Node(value, prev, next, list);
        }
        this.list = list;
        this.value = value;
        if (prev) {
          prev.next = this;
          this.prev = prev;
        } else {
          this.prev = null;
        }
        if (next) {
          next.prev = this;
          this.next = next;
        } else {
          this.next = null;
        }
      }
      try {
        __webpack_require__(8268)(Yallist);
      } catch (er) {}
    },
    2466: () => {},
    7695: () => {},
    6608: (__unused_webpack_module, exports) => {
      "use strict";

      function decode_arithmetic(bytes) {
        let pos = 0;
        function u16() {
          return bytes[pos++] << 8 | bytes[pos++];
        }
        let symbol_count = u16();
        let total = 1;
        let acc = [0, 1];
        for (let i = 1; i < symbol_count; i++) {
          acc.push(total += u16());
        }
        let skip = u16();
        let pos_payload = pos;
        pos += skip;
        let read_width = 0;
        let read_buffer = 0;
        function read_bit() {
          if (read_width == 0) {
            read_buffer = read_buffer << 8 | bytes[pos++];
            read_width = 8;
          }
          return read_buffer >> --read_width & 1;
        }
        const N = 31;
        const FULL = 2 ** N;
        const HALF = FULL >>> 1;
        const QRTR = HALF >> 1;
        const MASK = FULL - 1;
        let register = 0;
        for (let i = 0; i < N; i++) register = register << 1 | read_bit();
        let symbols = [];
        let low = 0;
        let range = FULL;
        while (true) {
          let value = Math.floor(((register - low + 1) * total - 1) / range);
          let start = 0;
          let end = symbol_count;
          while (end - start > 1) {
            let mid = start + end >>> 1;
            if (value < acc[mid]) {
              end = mid;
            } else {
              start = mid;
            }
          }
          if (start == 0) break;
          symbols.push(start);
          let a = low + Math.floor(range * acc[start] / total);
          let b = low + Math.floor(range * acc[start + 1] / total) - 1;
          while (((a ^ b) & HALF) == 0) {
            register = register << 1 & MASK | read_bit();
            a = a << 1 & MASK;
            b = b << 1 & MASK | 1;
          }
          while (a & ~b & QRTR) {
            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
            a = a << 1 ^ HALF;
            b = (b ^ HALF) << 1 | HALF | 1;
          }
          low = a;
          range = 1 + b - a;
        }
        let offset = symbol_count - 4;
        return symbols.map(x => {
          switch (x - offset) {
            case 3:
              return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
            case 2:
              return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
            case 1:
              return offset + bytes[pos_payload++];
            default:
              return x - 1;
          }
        });
      }
      function read_payload(v) {
        let pos = 0;
        return () => v[pos++];
      }
      function read_compressed_payload(s) {
        return read_payload(decode_arithmetic(unsafe_atob(s)));
      }
      function unsafe_atob(s) {
        let lookup = [];
        [...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
        let n = s.length;
        let ret = new Uint8Array(6 * n >> 3);
        for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
          carry = carry << 6 | lookup[s.charCodeAt(i)];
          width += 6;
          if (width >= 8) {
            ret[pos++] = carry >> (width -= 8);
          }
        }
        return ret;
      }
      function signed(i) {
        return i & 1 ? ~i >> 1 : i >> 1;
      }
      function read_deltas(n, next) {
        let v = Array(n);
        for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
        return v;
      }
      function read_sorted(next, prev = 0) {
        let ret = [];
        while (true) {
          let x = next();
          let n = next();
          if (!n) break;
          prev += x;
          for (let i = 0; i < n; i++) {
            ret.push(prev + i);
          }
          prev += n + 1;
        }
        return ret;
      }
      function read_sorted_arrays(next) {
        return read_array_while(() => {
          let v = read_sorted(next);
          if (v.length) return v;
        });
      }
      function read_mapped(next) {
        let ret = [];
        while (true) {
          let w = next();
          if (w == 0) break;
          ret.push(read_linear_table(w, next));
        }
        while (true) {
          let w = next() - 1;
          if (w < 0) break;
          ret.push(read_replacement_table(w, next));
        }
        return ret.flat();
      }
      function read_array_while(next) {
        let v = [];
        while (true) {
          let x = next(v.length);
          if (!x) break;
          v.push(x);
        }
        return v;
      }
      function read_transposed(n, w, next) {
        let m = Array(n).fill().map(() => []);
        for (let i = 0; i < w; i++) {
          read_deltas(n, next).forEach((x, j) => m[j].push(x));
        }
        return m;
      }
      function read_linear_table(w, next) {
        let dx = 1 + next();
        let dy = next();
        let vN = read_array_while(next);
        let m = read_transposed(vN.length, 1 + w, next);
        return m.flatMap((v, i) => {
          let [x, ...ys] = v;
          return Array(vN[i]).fill().map((_, j) => {
            let j_dy = j * dy;
            return [x + j * dx, ys.map(y => y + j_dy)];
          });
        });
      }
      function read_replacement_table(w, next) {
        let n = 1 + next();
        let m = read_transposed(n, 1 + w, next);
        return m.map(v => [v[0], v.slice(1)]);
      }
      var r$1 = read_compressed_payload('AEgSbwjEDVYByQKaAQsBOQDpATQAngDUAHsAoABoANQAagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXAA0ADgAWAA8AFAAVBFsF1QEXE0o3xAXUALIArkABaACmAgPGAK6AMDAwMAE/qAYK7P4HQAblMgVYBVkAPSw5Afa3EgfJwgAPA8meNALGCjACjqIChtk/j2+KAsXMAoPzASDgCgDyrgFCAi6OCkCQAOQA4woWABjVuskNDD6eBBx4AP4COhi+D+wKBirqBgSCaA0cBy4ArABqku+mnIAAXAaUJAbqABwAPAyUFvyp/Mo8INAIvCoDshQ8APcubKQAon4ZABgEJtgXAR4AuhnOBPsKIE04CZgJiR8cVlpM5INDABQADQAWAA9sVQAiAA8ASO8W2T30OVnKluYvChEeX05ZPe0AFAANABYAD2wgXUCYAMPsABwAOgzGFryp/AHauQVcBeMC0KACxLEKTR2kZhR0Gm5M9gC8DmgC4gAMLjSKF8qSAoF8ARMcAL4OaALiAAwuAUlQJpJMCwMt/AUpCthqGK4B2EQAciwSeAIyFiIDKCi6OGwAOuIB9iYAyA7MtgEcZIIAsgYABgCK1EoFHNZsGACoKNIBogAAAAAAKy4DnABoAQoaPu43dQQZGACrAcgCIgDgLBJ0OvRQsTOiKDVJBfsoBVoFWbC5BWo7XkITO1hCmHuUZmCh+QwUA8YIJvJ4JASkTAJUVAJ2HKwoAZCkpjZcA0YYBIRiCgDSBqxAMCQHKgI6XgBsAWIgcgCEHhoAlgFKuAAoahgBsMYDOC4iRFQBcFoGZgJmAPJKGAMqAgYASkIArABeAHQALLYGCPTwGo6AAAAKIgAqALQcSAHSAdwIDDKXeYHpAAsAEgA1AD4AOTR3etTBEGAQXQJNCkxtOxUMAq0PpwvmERYM0irM09kANKoH7ANUB+wDVANUB+wH7ANUB+wDVANUA1QDVBwL8BvUwRBgD0kEbgWPBYwE1wiEJkoRggcpCNNUDnQfHEgDRgD9IyZJHTuUMwwlQ0wNTQQH/TZDbKh9OQNIMaxU9pCjA8wyUDltAh5yEqEAKw90HTW2Tn96SHGhCkxPr7WASWNOaAK/Oqk/+QoiCZRvvHdPBj4QGCeiEPQMMAGyATgN6kvVBO4GOATGH3oZFg/KlZkIoi3aDOom4C6egFcj8iqABepL8TzaC0pRZQ9WC2IJ4DpggUsDHgEKIogK2g02CGoQ8ArGaA3iEUIHNgPSSZcAogb+Cw4dMhWyJg1iqQsGOXQG+BrzC4wmrBMmevkF0BoeBkoBJhr8AMwu5IWtWi5cGU9cBgALIiPEFKVQHQ0iQLR4RRoYBxIlpgKOQ21KhFEzHpAh8zw6DWMuEFF5B/I8AhlMC348m0aoRQsRzz6KPUUiRkwpBDJ8LCwniAnMD4IMtnxvAVYJHgmuDG4TLhEUN8IINgcWKpchJxIIHkaSYJcE9JwD8BPOAwgFPAk+BxADshwqEysVJgUKgSHUAvA20i6wAoxWfQEUBcgPIh/cEE1H3Q7mCJgCYgOAJegAKhUeABQimAhAYABcj9VTAi7ICMRqaSNxA2QU5F4RcAeODlQHpBwwFbwc3nDFXgiGBSigrAlYAXIJlgFcBOAIBjVYjJ0gPmdQi1UYmCBeQTxd+QIuDGIVnES6h3UCiA9oEhgBMgFwBzYM/gJ0EeoRaBCSCOiGATWyM/U6IgRMIYAgDgokA0xsywskJvYM9WYBoBJfAwk0OnfrZ6hgsyEX+gcWMsJBXSHuC49PygyZGr4YP1QrGeEHvAPwGvAn50FUBfwDoAAQOkoz6wS6C2YIiAk8AEYOoBQH1BhnCm6MzQEuiAG0lgNUjoACbIwGNAcIAGQIhAV24gAaAqQIoAACAMwDVAA2AqoHmgAWAII+AToDJCwBHuICjAOQCC7IAZIsAfAmBBjADBIA9DRuRwLDrgKAZ2afBdpVAosCRjIBSiIEAktETgOsbt4A2ABIBhDcRAESqEfIF+BAAdxsKADEAPgAAjIHAj4BygHwagC0AVwLLgmfsLIBSuYmAIAAEmgB1AKGANoAMgB87gFQAEoFVvYF0AJMRgEOLhUoVF4BuAMcATABCgB2BsiKosYEHARqB9ACEBgV3gLvKweyAyLcE8pCwgK921IAMhMKNQqkCqNgWF0wAy5vPU0ACx+lPsQ/SwVOO1A7VTtQO1U7UDtVO1A7VTtQO1UDlLzfvN8KaV9CYegMow3RRMU6RhPYYE5gLxPFLbQUvhXLJVMZOhq5JwIl4VUGDwEt0GYtCCk0che5ADwpZYM+Y4MeLQpIHORTjlT1LRgArkufM6wNqRsSRD0FRHXqYicWCwofAmR+AmI/WEqsWDcdAqH0AmiVAmYGAp+BOBgIAmY4AmYjBGsEfAN/EAN+jzkDOXQUOX86ICACbBoCMjM4BwJtxAJtq+yHMGRCKAFkANsA3gBHAgeVDIoA+wi/AAqyAncsAnafPAJ5SEACeLcaWdhFq0bwAnw8AnrFAn0GAnztR/1IemAhACgSSVVKWBIUSskC0P4C0MlLJAOITAOH40TCkS8C8p5dAAMDq0vLTCoiAMxNSU2sAos8AorVvhgEGkBkArQCjjQCjlk9lH4CjtYCjll1UbFTMgdS0VSCApP4ApMJAOYAGVUbVaxVzQMsGCmSgzLeeGNFODYCl5wC769YHqUAViIClowClnmZAKZZqVoGfkoAOAKWsgKWS1xBXM4CmcgCmWFcx10EFgKcmDm/OpoCnBMCn5gCnrWHABoMLicMAp3uAp6PALI6YTFh7AKe0AKgawGmAp6cHAKeS6JjxWQkIigCJ6wCJnsCoPgCoEnUAqYsAqXLAqf8AHoCp+9oeWiuAABGahlqzgKs4AKsqwKtZAKs/wJXGgJV2QKx3tQDH0tslAKyugoCsuUUbN1tYG1FXAMlygK2WTg8bo0DKUICuFsCuUQSArkndHAzcN4CvRYDLa8DMg4CvoVx/wMzbgK+F3Mfc0wCw8gCwwFzf3RIMkJ03QM8pAM8lwM9vALFeQLGRALGDYYCyGZOAshBAslMAskrAmSaAt3PeHZeeKt5IkvNAxigZv8CYfEZ8JUhewhej164DgLPaALPaSxIUM/wEJwAw6oCz3ABJucDTg9+SAIC3CQC24cC0kwDUlkDU1wA/gNViYCGPMgT6l1CcoLLg4oC2sQC2duEDYRGpzkDhqIALANkC4ZuVvYAUgLfYgLetXB0AuIs7REB8y0kAfSYAfLPhALr8ALpbXYC6vYC6uEA9kQBtgLuhgLrmZanlwAC7jwDhd2YdnDdcZ4C8wAAZgOOE5mQAvcQA5FrA5KEAveVAvnWAvhjmhmaqLg0mxsDnYAC/vcBGAA2nxmfsAMFigOmZwOm1gDOwgMGZ6GFogIGAwxGAQwBHAdqBl62ZAIAuARovA6IHrAKABRyNgAgAzASSgOGfAFgJB4AjOwAHgDmoAScjgi0BhygwgCoBRK86h4+PxZ5BWk4P0EsQiJCtV9yEl+9AJbGBTMAkE0am7o7J2AzErrQDjAYxxiKyfcFWAVZBVgFWQVkBVkFWAVZBVgFWQVYBVkFWAVZRxYI2IZoAwMDCmVe6iwEygOyBjC8vAC8BKi8AOhBKhazBUc+aj5xQkBCt192OF/pAFgSM6wAjP/MbMv9puhGez4nJAUsFyg3Nn5u32vB8hnDLGoBbNdvMRgFYAVrycLJuQjQSlwBAQEKfV5+jL8AND+CAAQW0gbmriQGAIzEDAMCDgDlZh4+JSBLQrJCvUI5JF8oYDcoOSQJwj4KRT9EPnk+gj5xPnICikK9SkM8X8xPUGtOCy1sVTBrDG8gX+E0OxwJaJwKYyQsPR4nQqxCvSzMAsv9X8oPIC8KCQoAACN+nt9rOy5LGMmsya0JZsLMzQphQWAP5hCkEgCTjh5GQiYbqm06zjkKND9EPnFCQBwICx5NSG1cLS5a4rwTCn7uHixCQBxeCUsKDzRVREM4BTtEnC0KghwuQkAb9glUIyQZMTIBBo9i8F8KcmTKYAxgLiRvAERgGjoDHB9gtAcDbBFmT2BOEgIAZOhgFmCWYH5gtGBMYJJpFhgGtg/cVqq8WwtDF6wBvCzOwgMgFgEdBB8BegJtMDGWU4EBiwq5SBsA5SR0jwvLDqdN6wGcAoidUAVBYAD4AD4LATUXWHsMpg0lILuwSABQDTUAFhO4NVUC0wxLZhEcANlPBnYECx9bADIAtwKbKAsWcKwzOaAaAVwBhwn9A9ruEAarBksGugAey1aqWwq7YhOKCy1ADrwBvAEjA0hbKSkpIR8gIi0TJwciDY4AVQJvWJFKlgJvIA9ySAHUdRDPUiEaqrFN6wcSBU1gAPgAPgsBewAHJW0LiAymOTEuyLBXDgwAYL0MAGRKaFAiIhzAADIAtwKbKC08D88CkRh8ULxYyXRzjtilnA72mhU+G+0S2hIHDxwByAk7EJQGESwNNwwAPAC0zwEDAKUA4gCbizAAFQBcG8cvbXcrDsIRAzwlRNTiHR8MG34CfATCC6vxbQA4Oi4Opzkuz6IdB7wKABA7Ls8SGgB9rNsdD7wbSBzOoncfAT4qYB0C7KAJBE3z5R9mDL0M+wg9Cj8ABcELPgJMDbwIvQ09CT0KvS7PoisOvAaYAhwPjBriBBwLvBY8AKELPBC8BRihe90AO2wMPQACpwm9BRzR9QYFB2/LBnwAB7wSXBISvQECAOsCAAB1FVwHFswV/HAXvBg8AC68AuyovAAevAJWISuAAAG8AALkFT0VvCvso7zJqDwEAp8nTAACXADn3hm8CaVcD7/FAPUafAiiBQv/cQDfvKe8GNwavKOMeXMG/KmchAASvAcbDAADlABtvAcAC7ynPAIaPLsIopzLDvwHwak8AOF8L7dtvwNJAAPsABW8AAb8AAm8AGmMABq8AA68Axi8jmoV/AABXAAObAAuTB8ABrwAF7wIIgANSwC6vCcAA7wADpwq7ACyWwAcHAAbvAAB7AqiAAXHCxYV3AAHnABCvAEDAGm8AAt8AB28AAi8CaIABcsAbqAZ1gCSCCIABcsAATwAB9wAHZwIIgAGmwAJfAAbLABtHADmvIEACFwACDwAFLwAaPwJIgAGywDjjAAJPAuiDsX7YAAHPABunUBJAEgACrwFAAM8AAmuAzgABxwAGXwAAgym/AAKHAAKPAAJ/KfsBrwACRwAAwwAEDwBABQ8ABFsAA+MAA3sAA28ABkMBxYcABU8AG6cFrQBvAC7ABM8BABpLAsA4UwAAjwABFMAF3wFHAAG0QAYvB8BfClTADpGALAJBw4McwApK3EBpQYIXwJtJA0ACghwTG1gK4oggRVjLjcDogq1AALZABcC/ARvAXdzSFMVIgNQAhY/AS0GBHRHvnxTe0EAKgAyAvwAVAvcAHyRLQEsAHfmDhIzRwJLAFgGAAJRAQiLzQB5PAQhpgBbANcWAJZpOCCMAM5ssgDQ1RcJw3Z0HBlXHgrSAYmRrCNUVE5JEz3DivoAgB04QSos4RKYUABzASosMSlDGhADMVYE+MbvAExm3QBrAnICQBF7Osh4LzXWBhETIAUVCK6v/xPNACYAAQIbAIYAiQCONgDjALQA1QCdPQC7AKsApgChAOcAnwDTAJwA4AEBAPwAwAB6AFsAywDNAPwA1wDrAIkAogEqAOMA2ADVBAIIKzTT09PTtb/bzM/NQjEWAUsBVS5GAVMBYgFhAVQBRUpCRGcMAUwUBgkEMzcMBwAgDSQmKCs3OTk8PDw9Pg0/HVBQUFBSUlFSKFNUVlVVHFxgYF9hYCNlZ29ucXFxcXFxc3Nzc3Nzc3Nzc3N1dXZ1dFsAPesAQgCTAHEAKwBf8QCHAFAAUAAwAm/oAIT+8fEAXQCM6wCYAEgAWwBd+PipAH4AfgBiAE8AqgAdAK8AfAI5AjwA9QDgAPcA9wDhAPgA4gDiAOEA3wAoAnQBSgE5ATcBTQE3ATcBNwEyATEBMQExARUBURAAKgkBAEwYCxcEFhcPAIcAjwCfAEoAYxkCKgBvAGgAkAMOAyArAxpCP0gqAIoCSADAAlACnQC5Ao8CjwKPAo8CjwKPAoQCjwKPAo8CjwKPAo8CjgKOApECmQKQAo8CjwKNAo0CjQKNAosCjgJuAc0CkAKYAo8CjwKOF3oMAPcGA5gCWgIzGAFNETYC2xILLBQBRzgUTpIBdKU9AWJaAP4DOkgA/wCSKh4ZkGsAKmEAagAvAIoDlcyM8K+FWwa7LA/DEgKe1nUrCwQkWwGzAN5/gYB/gX+Cg4N/hIeFf4aJh4GIg4mDin+Lf4x/jYuOf49/kIORf5J/k3+Uf5WElomXg5h/AIMloQCEBDwEOQQ7BD4EPARCBD8EOgRABEIEQQQ9BD8EQgCkA4gAylIA0AINAPdbAPcBGgD3APUA9QD2APXVhSRmvwD3APUA9QD2APUdAIpbAPcAigEaAPcAigLtAPcAitWFJGa/HQD4WwEaAPcA9wD1APUA9gD1APgA9QD1APYA9dWFJGa/HQCKWwEaAPcAigD3AIoC7QD3AIrVhSRmvx0CRAE3AksBOgJMwgOfAu0Dn9WFJGa/HQCKWwEaA58AigOfAIoC7QOfAIrVhSRmvx0EMQCKBDIAigeOMm4hLQCKAT9vBCQA/gDHWwMAVVv/FDMDAIoDPtkASgMAigMAl2dBtv/TrfLzakaPh3aztmIuZQrR3ER2n5Yo+qNR2jK/aP/V04UK1njIJXLgkab9PjOxyJDVbIN3R/FZLoZVl2kYFQIZ7V6LpRqGDt9OdDohnJKp5yX/HLj0voPpLrneDaN11t5W3sSM4ALscgSw8fyWLVkKa/cNcQmjYOgTLZUgOLi2F05g4TR0RfgZ4PBdntxdV3qvdxQt8DeaMMgjJMgwUxYN3tUNpUNx21AvwADDAIa0+raTWaoBXmShAl5AThpMi282o+WzOKMlxjHj7a+DI6AM6VI9w+xyh3Eyg/1XvPmbqjeg2MGXugHt8wW03DQMRTd5iqqOhjLvyOCcKtViGwAHVLyl86KqvxVX7MxSW8HLq6KCrLpB8SspAOHO9IuOwCh9poLoMEha9CHCxlRAXJNDobducWjqhFHqCkzjTM2V9CHslwq4iU19IxqhIFZMve15lDTiMVZIPdADXGxTqzSTv0dDWyk1ht430yvaYCy9qY0MQ3cC5c1uw4mHcTGkMHTAGC99TkNXFAiLQgw9ZWhwKJjGCe+J5FIaMpYhhyUnEgfrF3zEtzn40DdgCIJUJfZ0mo3eXsDwneJ8AYCr7Vx2eHFnt2H6ZEyAHs9JoQ4Lzh5zBoGOGwAz37NOPuqSNmZf51hBEovtpm2T1wI79OBWDyvCFYkONqAKGVYgIL0F+uxTcMLSPtFbiNDbBPFgip8MGDmLLHbSyGXdCMO6f7teiW9EEmorZ+75KzanZwvUySgjoUQBTfHlOIerJs6Y9wLlgDw18AB1ne0tZRNgGjcrqHbtubSUooEpy4hWpDzTSrmvqw0H9AoXQLolMt9eOM+l9RitBB1OBnrdC1XL4yLFyXqZSgZhv7FnnDEXLUeffb4nVDqYTLY6X7gHVaK4ZZlepja2Oe6OhLDI/Ve5SQTCmJdH3HJeb14cw99XsBQAlDy5s5kil2sGezZA3tFok2IsNja7QuFgM30Hff3NGSsSVFYZLOcTBOvlPx8vLhjJrSI7xrNMA/BOzpBIJrdR1+v+zw4RZ7ry6aq4/tFfvPQxQCPDsXlcRvIZYl+E5g3kJ+zLMZon0yElBvEOQTh6SaAdIO6BwdqJqfvgU+e8Y65FQhdiHkZMVt9/39N2jGd26J6cNjq8cQIyp6RonRPgVn2fl89uRDcQ27GacaN0MPrcNyRlbUWelKfDfyrNVVGBG5sjd3jXzTx06ywyzuWn5jbvEfPPCTbpClkgEu9oPLKICxU5HuDe3jA1XnvU85IYYhaEtOU1YVWYhEFsa4/TQj3rHdsU2da2eVbF8YjSI0m619/8bLMZu3xildwqM7zf1cjn4Whx0PSYXcY5bR7wEQfGC7CTOXwZdmsdTO8q3uGm7Rh/RfCWwpzBHCAaVfjxgibL5vUeL0pH6bzDmI9yCXKC/okkmbc28OJvI87L/bjFzpq0DHepw4kT1Od+fL7cyuFaRgfaUWB2++TCFvz11J0leEtrGkpccfX9z2LY39sph4PBHCjNOOkd0ybUm+ZzS8GkFbqMpq8uiX2yHpa0jllTLfGTDBMYR6FT5FWLLDPMkYxt1Q0eyMvxJWztDjy0m6VvZPvamrFXjHmPpU6WxrZqH6WW//I37RwvqPQhPz8I3RPuXAk1C94ZprQWm9iGM/KgiGDO6SV9sjp+Jmk4TBajMNJ5zzWZ1k1jrteQQBp9C2dOvmbIeeEME8y573Q8TgGe+ZCzutM45gYLBzYm2LNvgq2kebAbMpHRDSyh6dQ27GbsAAdCqQVVXWC1C+zpwBM2Lr4eqtobmmu1vJEDlIQR1iN8CUWpztq50z7FFQBn3SKViX6wSqzVQCoYvAjByjeSa+h1PRnYWvBinTDB9cHt4eqDsPS4jcD3FwXJKT0RQsl8EvslI2SFaz2OtmYLFV8FwgvWroZ3fKmh7btewX9tfL2upXsrsqpLJzpzNGyNlnuZyetg7DIOxQTMBR7dqlrTlZ6FWi1g4j1NSjA2j1Yd7fzTH6k9LxCyUCneAKYCU581bnvKih6KJTeTeCX4Zhme/QIz7w2o+AdSgtLAkdrLS9nfweYEqrMLsrGGSWXtgWamAWp6+x6GM/Z8jNw3BqPNQ39hrzYLECn3tPvh/LqKbRSCiDGauDKBBj/kGbpnM1Bb/my8hv4NWStclkwjfl57y4oNDgw1JAG9VOti3QVVoSziMEsSdfEjaCPIDb7SgpLXykQsM+nbqbt97I0mIlzWv0uqFobLMAq8Rd9pszUBKxFhBPwOjf//gVOz2r7URJ2OnpviCXv9iz3a4X/YLBYbXoYwxBv/Kq0a5s4utQHzoTerJ7PmFW/no/ZAsid/hRIV82tD+Qabh5F1ssIM8Ri3chu0PuPD3sSJRMjDoxLAbwUbroiPAz/V52e8s3DIixxlO7OrvhMj3qfzA0kKxzwicr5wJmZwJxTXgrwYsqhRvpgC2Nfdyd+TYYxJSZgk+gk2g9KyHSlwQVAyPtWWgvVGyVBqsU2LpDlLNosSAtolC1uBKt5pQZLhAxTjeGCWIC/HVpagc5rRwkgpCHKEsjA8d+scp8aiMewwQBhp5dYTV5t/Nvl+HbDMu8F3S0psPyZb1bSnqlHPFUnMQeQqSqwDBT23fJO9gO3aVaa1icrXU0PKwlMM5K+iL3ATcVq2fFWKk0irCTF4LDVDG4gUpkyplq6efcZS+WDR1woApjD18x+2JQR9oOXzuA7uy4b+/91WsJd/tSd1QcAH8PVPXApieA37B7YXPhDPH1azP3PKR+HfHmOoDYLeuKsIi/ssSsdYs62qJo14Hw1P2N/6zpr8F3FTWmJ4ysAVcl84Iv/tl///Z8FaAWbBQbyMNDZjrZ2JwdRjtd1jOeNumSodFtr4/Zf45iRJf/8HSW+KIB/+GlKu8Rv1BPLr/4duoL+kFPRqrstEr41gfJupoJRf4hcYDWX93FOcfEBiIivxtjtV8g7mvOReiamYWKE7vfPbv3v2L9Kwq3cIDFGLyhyfOGuf/9vA5muH6Pjg7B4SUj2ydDXra9fSBI+DrsNHA6l51wfHssJb+11TfNk7B8OleUe3Y+ZmHboMFHdv7FFP2cfISFyeAQR0sk/Xv62HBTdW4HmnGSLFk/cqyWVVFJkdIIa+4hos3JRHcqLoRKM5h2Qtk1RZtzISMtlXTfTqIc77YsCCgQD0r61jtxskCctwJOtjE/pL8wC4LBD4AZFjh2wzzFCrT/PNqW0/DeBbkfMfzVm9yy06WiF+1mTdNNEAytVtohBKg3brWd2VQa+aF+cQ0mW5CvbwOlWCT07liX226PjiVLwFCRs/Ax2/u+ZNPjrNFIWIPf5GjHyUKp60OeXe9F01f7IaPf/SDTvyDAf7LSWWejtiZcsqtWZjrdn6A2MqBwnSeKhrZOlUMmgMionmiCIvXqKZfmhGZ1MwD3uMF4n9KJcfWLA3cL5pq48tm5NDYNh3SS/TKUtmFSlQR89MR4+kxcqJgpGbhm9gXneDELkyqAN5nitmIzTscKeJRXqd64RiaOALR2d295NWwbjHRNG2AU5oR9OS2oJg/5CY6BFPc1JvD2Mxdhp2/MZdI8dLePxiP4KRIp8VXmqfg+jqd/RNG7GNuq1U2SiI4735Bdc0MVFx6mH5UOWEa5HuhYykd6t4M1gYLVS8m1B+9bUqi5DziQq7qT8d94cxB6AB4WqMCOF/zPPtRSZUUaMSsvHOWxGASufywTX8ogy6HgUf9p+Z30wUEosl8qgmwm6o2AV6nO9HKQjRHpN6SUegI5pvR61RLnUJ1lqCtmfcsRQutEizVpAaPXN7xMp5UQ5OSZK6tniCK9CpyMd7LjR6+MxfoMEDPpWdf2p2m5N3KO4QMxf+V7vGdYjemQczQ+m2MGIkFNYDMf0Yop2eSx81sP36WHUczqEhKysp2iJSYAvfgJjinKwToPvRKb+HBi+7cJ96S5ngfLOXaHAFRLkulo4TnXTFO51gX0TCCo4ZUHdbpdgkMEwUZAPjh6M+hA8DzycbtxAgH3uD6i0nN1aTiIuQ4BYCE9dEHHwAmINU+4YEWx4EC3OZwFGfYZMPLScVlb+BAAJeARUh+gdWA3/gRqCrf1jecgqeFf1MdzrrP4SVlGm5mMihSP+zYYksAB7O+SBPwNQqSNMiLnkviY/klwgcRmvqtCqeWeA0gjuir4CMZqmw/ntP6M+l0pdN8/P9xI53aP7x/zavJbbKOz8VzO/nXxIr1tjparMnqd6iWdByHKw4lF4p/u57Yv07WeZPDnRl7wgmDVZZ44fQsjdYO/gmXQ+940PRGst8UMQApFC4OOV22e4N+lVOPyFLAOj4t8R3PFw/FjbSWy0ELuAFReNkee8ORcBOT2NPDcs7OfpUmzvn/F9Czk9o9naMyVYy/j8I5qVFmQDFcptBp65J/+sJA3w/j6y/eqUkKxTsf0CZjtNdRSBEmJ2tmfgmJbqpcsSagk+Ul9qdyV+NnqFBIJZFCB1XwPvWGDBOjVUmpWGHsWA5uDuMgLUNKZ4vlq5qfzY1LnRhCc/mh5/EX+hzuGdDy5aYYx4BAdwTTeZHcZpl3X0YyuxZFWNE6wFNppYs3LcFJePOyfKZ8KYb7dmRyvDOcORLPH0sytC6mH1US3JVj6paYM1GEr+CUmyHRnabHPqLlh6Kl0/BWd3ebziDfvpRQpPoR7N+LkUeYWtQ6Rn5v5+NtNeBPs2+DKDlzEVR5aYbTVPrZekJsZ9UC9qtVcP99thVIt1GREnN8zXP8mBfzS+wKYym8fcW6KqrE702Zco+hFQAEIR7qimo7dd7wO8B7R+QZPTuCWm1UAwblDTyURSbd85P4Pz+wBpQyGPeEpsEvxxIZkKsyfSOUcfE3UqzMFwZKYijb7sOkzpou+tC4bPXey5GI1GUAg9c3vLwIwAhcdPHRsYvpAfzkZHWY20vWxxJO0lvKfj6sG2g/pJ1vd/X2EBZkyEjLN4nUZOpOO7MewyHCrxQK8d5aF7rCeQlFX+XksK6l6z971BPuJqwdjj68ULOj9ZTDdOLopMdOLL0PFSS792SXE/EC9EDnIXZGYhr52aQb+9b2zEdBSnpkxAdBUkwJDqGCpZk/HkRidjdp0zKv/Cm52EenmfeKX6HkLUJgMbTTxxIZkIeL/6xuAaAAHbA7mONVduTHNX/UJj1nJEaI7f3HlUyiqKn7VfBE+bdb4HWln1HPJx001Ulq1tOxFf8WZEARvq5Da1+pE7fPVxLntGACz3nkoLsKcPdUqdCwwiyWkmXTd5+bv3j7HaReRt3ESn783Ew3SWsvkEjKtbocNksbrLmV+GVZn1+Uneo35MT1/4r8fngQX5/ptORfgmWfF6KSB/ssJmUSijXxQqUpzkANEkSkYgYj560OOjJr6uqckFuO15TRNgABEwNDjus1V3q2huLPYERMCLXUNmJJpbMrUQsSO7Qnxta55TvPWL6gWmMOvFknqETzqzFVO8SVkovEdYatypLGmDy9VWfgAc0KyIChiOhbd7UlbAeVLPZyEDp4POXKBwN/KP5pT6Cyqs6yaI00vXMn1ubk9OWT9Q/O2t/C25qlnO/zO0xcBzpMBCAB8vsdsh3U8fnPX1XlPEWfaYJxKVaTUgfCESWl4CCkIyjE6iQ5JFcwU6S4/IH0/Agacp8d5Gzq2+GzPnJ7+sqk40mfFQpKrDbAKwLlr3ONEati2k/ycLMSUu7V/7BBkDlNyXoN9tvqXCbbMc4SSQXgC/DBUY9QjtrCtQ+susEomCq8xcNJNNMWCH31GtlTw2BdCXkJBjT+/QNWlBWwQ5SWCh1LdQ99QVii/DyTxjSR6rmdap3l3L3aiplQpPYlrzNm9er88fXd2+ao+YdUNjtqmxiVxmyYPzJxl67OokDcTezEGqldkGgPbRdXA+fGcuZVkembZByo7J1dMnkGNjwwCny+FNcVcWvWYL9mg8oF7jACVWI3bA64EXpdM8bSIEVIAs5JJH+LHXgnCsgcMGPZyAAVBncvbLiexzg9YozcytjPXVlAbQAC7Tc4S0C8QN4LlAGjj4pQAVWrwkaDoUYGxxvkCWKRRHkdzJB5zpREleBDL1oDKEvAqmkDibVC4kTqF89YO6laUjgtJPebBfzr16tg4t10GmN1sJ5vezk2sUOq8blCn5mPZyT3ltaDcddKupQjqusNM9wtFVD0ABzv17fZDn7GPT1nkCtdcgYejcK1qOcTGtPxnCX1rErEjVWCnEJv5HaOAUjgpiKQjUKkQi64D5g2COgwas8FcgIl0Pw95H9dWxE3QG0VbMNffh6BPlAojLDf4es2/5Xfq7hw5NGcON2g8Qsy2UQm94KddKyy3kdJxWgpNaEc15xcylbLC3vnT26u8qS90qc2MU8LdOJc5VPF5KnSpXIhnj1eJJ/jszjZ01oR6JDFJRoeTPO/wh4IPFbdG9KljuSzeuI92p8JF/bpgDE8wG86/W2EBKgPrmzdLijxssQn8mM44ky/KLGOJcrSwXIpZa/Z3v7W6HCRk7ewds99LTsUW1LbeJytw8Q/BFZVZyfO9BUHOCe2suuEkO8DU4fLX0IQSQ2TdOkKXDtPf3sNV9tYhYFueuPRhfQlEEy+aYM/MCz7diDNmFSswYYlZZPmKr2Q5AxLsSVEqqBtn6hVl1BCFOFExnqnIsmyY/NA8jXnDaNzr7Zv3hu+I1Mf/PJjk0gALN2G8ABzdf9FNvWHvZHhv6xIoDCXf964MxG92vGZtx/LYU5PeZqgly8tT5tGeQGeJzMMsJc5p+a5Rn2PtEhiRzo/5Owjy1n0Lzx3ev8GHQmeWb8vagG6O5Qk5nrZuQTiKODI4UqL0LLAusS2Ve7j1Ivdxquu1BR9Rc4QkOiUPwQXJv6du2E8i5pDhVoQpUhyMWGUT2O2YODIhjAfI71gxep5r5zAY7GBUZpy51hAw0pcCCrhOmU8Wp6ujQTdZQsCjtq6SHX8QAMNiPCIIkoxhHEZPgsBcOlP4aErJZPhF7qvx6gHrn8hEwPwYbx8YmT/n7lbcmTip1v8kgsrIjFTAlvLY4Nuil0KDmgz3svYs0ZJ3O3Is/vSx4xpxF1e2VAtZE8dJxGYEIhCSuPvCjP54l/NSNDnwlKvAW8mG+AQkgp7a87Igh26uKMFGD0PoPHTSvoWxiHuk+su8XkQiHIjeYKl/RdcOHpxhQH3zHCNE3aARm83Bl6zGxU/vMltlVPQhubcqhW4RYkl6uXk5JdP/QpzaKFpw2M8zvysv2qj7xaQECuu2akM0Cssj/uB9+wDR7uA6XOnLNaoczalHoMj33eiiu+DRaFsUmlmUZuh9bjDY4INMNSSAivSh03uJvny4Gj+D+neudoa7iJi7c4VFlZ/J5gUR82308zSNAt/ZroBXDWw0fV3eVPAn3aX0mtJabF6RsUZmL+Ehn+wn51/4QipMjD+6y64t7bjL6bjENan2prQ4h7++hBJ9NXvX8CUocJqMC937IasLzm5K0qwXeFMAimMHkEIQIQI2LrQ9sLBfXuyp66zWvlsh74GPv7Xpabj993pRNNDuFud5oIcn/92isbADXdpRPbjmbCNOrwRbxGZx2XmYNGMiV5kjF4IKyxCBvKier9U4uVoheCdmk83rp5G0PihAm2fAtczI4b9BWqX+nrZTrJX5kSwQddi93NQrXG+Cl3eBGNkM77VBsMpEolhXex1MVvMkZN9fG59GGbciH11FEXaY1MxrArovaSjE/lUUqBg2cZBNmiWbvzCHCPJ4RVGFK2dTbObM1m+gJyEX53fa7u3+TZpm74mNEzWbkVL4vjNwfL9uzRCu1cgbrNx5Yv5dDruNrIOgwIk+UZWwJfdbu/WHul6PMmRflVCIzd7B37Pgm/Up/NuCiQW7RXyafevN3AL6ycciCc4ZPlTRzEu+aURGlUBOJbUEsheX7PPyrrhdUt5JAG12EEEZpY/N3Vhbl5uLAfT0CbC2XmpnryFkxZmBTs5prvEeuf0bn73i3O82WTiQtJWEPLsBXnQmdnKhB06NbbhLtlTZYJMxDMJpFeajSNRDB2v61BMUHqXggUwRJ19m6p5zl51v11q34T74lTXdJURuV6+bg2D6qpfGnLy7KGLuLZngobM4pIouz4+n0/UzFKxDgLM4h+fUwKZozQ9UGrHjcif51Ruonz7oIVZ56xWtZS8z7u5zay6J2LD4gCYh2RXoBRLDKsUlZ80R8kmoxlJiL8aZCy2wCAonnucFxCLT1HKoMhbPKt34D97EXPPh0joO93iJVF1Uruew61Qoy3ZUVNX9uIJDt9AQWKLLo+mSzmTibyLHq0D6hhzpvgUgI6ekyVEL3FD+Fi5R3A8MRHPXspN1VyKkfRlC+OGiNgPC4NREZpFETgVmdXrQ2TxChuS3aY+Ndc7CiYv5+CmzfiqeZrWIQJW/C4RvjbGUoJFf1K6ZdR2xL/bG4kVq1+I4jQWX+26YUijpp+lpN7o5c6ZodXJCF56UkFGsqz44sIg8jrdWvbjRCxi2Bk0iyM3a7ecAV93zB6h1Ei38c0s6+8nrbkopArccGP8vntQe1bFeEh2nJIFOHX/k3/UHb5PtKGpnzbkmnRETMX+9X/QduLZWw/feklW/kH/JnzToJe9Kgu9Hct1UGbH5BPCLo4OOtQnZonW0xnyCcdtKyPQ/sbLiSTYJdSx4sJqWLMnfn6fIqPB3WAgk00J+fCOkomPHqtS67pf0mFmKoItYZUlJu6BihSZ8qve8+/X+LX1MhQXF95AshfUleCtmdn6l6QFXzLg2sgLn1oyVFuZecv7fzsIHzoRlAGp0gwYDOn1S4qabWvB5xUaE+Svw4KmjWtxdnuQbI32dw87D4N95u8qQRJTSQg0wLxOLkxSrPMLEn1UIhNKjAa9VLs3WLaXGrtCIt8bKY2AQP/ZdyRU6zT/E8qP2ltyBE2CCZPgWgEYDoJJO4n92y61ylNaSFXKohJhLjkfvYWm592539sIpmBNLlDo1bExFBfmHJJ0lFEiC/fj8v42OoMC9Mo3whIoWvyHfq6Uacqq55mzFf/EGC+NP/gHjhd6urc6R0hES27VXux7UY8CGKPohplWIZtTrFSaPWslCWy78E22Pw8fvReSUZx/txqLtHrFqg1DY/Eus6Iq1heZdrdcqE0/c971Bz1HW/XNXHsXpUIbI4kHdOfCc6T5zHZzvzQJB0ggMFL6IGPAilU9bj/ASdPk6fNvNtZqPuwEDhMBtBnhCexo6D6VAGIOPvJPPV523Y8R8a9vCqZbswSZKzOT1291BsUbmUWehtbb1fdRX9hiJKXvwr1QX6GjnZMgyMvnwOo2Dr24amr7FqEAbVeJAjRNOceM2EQ1Mna9fInqPJ5mh5X8CzT1aDOv08An0blz0fF5Gq4mS2cwq5glwIOlY5nznE8X4j/UdZ3FJsVIXte1JH0A7iibuPfazStM5O/Vo3KXIpXBeGORV0M9XDXFvsYZUHGvFCUubWzTw248EHE0cpQM2zNg6rjavreq3NHCAWsoZ7wvVy7l5gvtKRmIj1MnvfWEm0yFnGcuOq192350a5WefpfKCcX3Sn+AgHU+qnpstNtddbdVebagJU390lq9ko4aI9rqdaWXYG8tv5O/ZQHSqDRYHC6zfH10l5z++opso7aOSaIczlQ13iAzXvLdEu0V7kwNUZ1c8Y8aq7SeIEe5p902FlNkW8DnwHyueHchbK8vVFJfmr9mz7P8nUSccl1ULaoWMRSI1ls32kvlK0h46h3J25Yd9AzfcJbp9qYF/SEt3H5j69mMdcsNxZcAzT/A89ov3tglTX54y/EwjMfuoDoxPwLJDm5I7q6F9Kp469yNy1zSxz0N4HbRRBj9xFFuogvBspv7DXUNIsGxTINEQfmctb42XImWAODgARNo7dfcTqFKq6aTfivmvunLmzP9f8yLsJvXD3JbcPcDGNriMAcjzeDTNr65t8YB5tsnFDFLa0Uwmd2OvUdkLMX9TsAUYUfooSv47sw5J88j7CpahRjjO3/UhOXjTS39W5YZAel2KTbQd1h7INOw9P23GW7GDAe4agIUFHP48MZr7ubq0efFmmtwYMyk7D0r1oeG/CGOODgb9Ur+JMHxkwzPbtCX2ZnENQuI0RN5SyTIZuoY4XS9Rd/tPe3vNAZGSHM/YYwqs9xkkENx0O+eC2YVW1cwOJ3ckE890nbQeHLKlW15L0P0W2VliyYrfNr0nrIYddoRyGaCtj4OYd2MT7ebApqZOAQIaSHJM4mphhfjNjtnjg6YRyx9qM2FT3xOiYIMqXPFWdzhSgFF8ItocqVV09CmIoO8k6U/oJB7++wSX/YksxfPXHyjSgAGZOj1aKEq9fSvXBqtp2wu8/FxEf5AxapAD06pPGuLVUYLdgEzHR8wqRGYEwiUO9MyYbgswstuLYhwYFpSVKOdzAihZ9LuHtD598EGhINU9xc9xhL+QgTLAstmPIvvm2xyRw/WTUPXkP3ZHu6GyPmj5xFH9/QGpkglKXRVUBgVmLOJx8uZO2AstxQYocZH2JhORlxawj66BAXUEs7K/gPxINIRAFyK3WLuyq9oBTF9wEbnmCot82WjIg7CPNwYK3KrZMrKAz5yFszg4wCVLJVnIL8+OYA0xRDH8cHQjQUiQ2i1mr/be32k/3Xej9sdf3iuGvZHyLFSJvPSqz/wltnxumTJYKZsrWXtx/Rmu39jjV9lFaJttfFn57/No2h/unsJmMHbrnZ8csxkp5HQ4xR1s0HH+t3Iz82a3iQWTUDGq/+l2W3TUYLE8zNdL8Y+5oXaIH/Y2UUcX67cXeN4WvENZjz4+8q7vjhowOI3rSjFhGZ6KzwmU7+5nFV+kGWAZ5z2UWvzq0TK0pk1hPwAN4jbw//1CApRvIaIjhSGhioY6TUmsToek9cF9XjJdHvLPcyyCV3lbR5Jiz/ts46ay2F820VjTXvllElwrGzKcNSyvQlWDXdwrUINXmHorAM3fE19ngLZmgeUaCJLsSITf2VcfAOuWwX7mTPdP8Zb/04KqRniufCpwnDUk7sP0RX6cud/sanFMagnzKInSRVey0YzlVSOtA/AjrofmSH6RYbJQ8b4NDeTkIGc6247+Mnbez/qhJ9GAv9fGNFercPnnrf285Qgs+UqThLRgflcAKFuqWhLzZaR4QqvSwa3xe0LPkqj9xJWub195r7NrrR0e78FR+0mRBNMPsraqZctAUVAJfYKehTDV1MGGQSeDsOK9J3sbUuKRIS/WilX/64CBms9jCZocBlsBSZaIAjWm/SUZ8daWL2a/cJFyUOFqE3Epc2RWbtjNyPwOGpWtzu32kUooUqsJud7IV4E8rstUBXM7tGEtBx99x60g1duhyvxeKJSl8s5E34HTMmADT0836aEdg5Dv9rVyCz8i2REOmiz6wtIVFN0HsjAoN37SrY0bV1Ms8CRUILhvZvvRaDzoVCaSI0u8EPuTe4b7OPowgRGODl22UBBmHSTUY8e4DyL+Bc7bngo+2T8HtNvzyATSL5iJZgFPKpmUyZv54vVL90+/RQGATUmNKnrIvcJMYON9fl83naW5sf6hRkbbTC9RUEE6XADwjgA46wWfUQ+QWZl0J4PVTWAln/YfAz/SV3q3J9+yCYDleruoN5uoc/wT2f4YONGTb6zTGq3V+3JqzmCOjwebKln+fExVLN7sqtqfMnsKVXWbb2Ai5m3D/fCTgX7oKYzTZvj+m28XnDqPbXuP4MyWdmPezcesdrh7rCzA7BWdObiuyDEKjjzBbQ0qnuwjliz+b+j7aPMKlkXyIznV3tGzAfYwIbzGGt098oh4eq3ruDjdgHtjxfFCjHrjjRbHajoz/YOY4raojPFQ910GIlBV7hq47UDgpyajBxQUmD8NctiLV1rTSLAEsQDLTeRKcmPBMVMFF0SPBBhZ5oXoxtD3lMhuAQXmA+57OcciczVW9e9zwSIAHS+FJmvfXMJGF1dMBsIUMaPjvgaVqUc3p32qVCMQYFEiRLzlVSOGMCmv/HJIxAHe3mL/XnoZ1IkWLeRZfgyByjnDbbeRK5KL7bYHSVJZ9UFq+yCiNKeRUaYjgbC3hVUvfJAhy/QNl/JqLKVvGMk9ZcfyGidNeo/VTxK9vUpodzfQI9Z2eAre4nmrkzgxKSnT5IJ1D69oHuUS5hp7pK9IAWuNrAOtOH0mAuwCrY8mXAtVXUeaNK3OXr6PRvmWg4VQqFSy+a1GZfFYgdsJELG8N0kvqmzvwZ02Plf5fH9QTy6br0oY/IDsEA+GBf9pEVWCIuBCjsup3LDSDqI+5+0IKSUFr7A96A2f0FbcU9fqljdqvsd8sG55KcKloHIFZem2Wb6pCLXybnVSB0sjCXzdS8IKvE');
      const FENCED = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
      const NSM_MAX = 4;
      function hex_cp(cp) {
        return cp.toString(16).toUpperCase().padStart(2, '0');
      }
      function quote_cp(cp) {
        return `{${hex_cp(cp)}}`;
      }
      function explode_cp(s) {
        let cps = [];
        for (let pos = 0, len = s.length; pos < len;) {
          let cp = s.codePointAt(pos);
          pos += cp < 0x10000 ? 1 : 2;
          cps.push(cp);
        }
        return cps;
      }
      function str_from_cps(cps) {
        const chunk = 4096;
        let len = cps.length;
        if (len < chunk) return String.fromCodePoint(...cps);
        let buf = [];
        for (let i = 0; i < len;) {
          buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
        }
        return buf.join('');
      }
      function compare_arrays(a, b) {
        let n = a.length;
        let c = n - b.length;
        for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
        return c;
      }
      var r = read_compressed_payload('AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g');
      function unpack_cc(packed) {
        return packed >> 24 & 0xFF;
      }
      function unpack_cp(packed) {
        return packed & 0xFFFFFF;
      }
      const SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, i + 1 << 24])));
      const EXCLUSIONS = new Set(read_sorted(r));
      const DECOMP = new Map();
      const RECOMP = new Map();
      for (let [cp, cps] of read_mapped(r)) {
        if (!EXCLUSIONS.has(cp) && cps.length == 2) {
          let [a, b] = cps;
          let bucket = RECOMP.get(a);
          if (!bucket) {
            bucket = new Map();
            RECOMP.set(a, bucket);
          }
          bucket.set(b, cp);
        }
        DECOMP.set(cp, cps.reverse());
      }
      const S0 = 0xAC00;
      const L0 = 0x1100;
      const V0 = 0x1161;
      const T0 = 0x11A7;
      const L_COUNT = 19;
      const V_COUNT = 21;
      const T_COUNT = 28;
      const N_COUNT = V_COUNT * T_COUNT;
      const S_COUNT = L_COUNT * N_COUNT;
      const S1 = S0 + S_COUNT;
      const L1 = L0 + L_COUNT;
      const V1 = V0 + V_COUNT;
      const T1 = T0 + T_COUNT;
      function is_hangul(cp) {
        return cp >= S0 && cp < S1;
      }
      function compose_pair(a, b) {
        if (a >= L0 && a < L1 && b >= V0 && b < V1) {
          return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
        } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
          return a + (b - T0);
        } else {
          let recomp = RECOMP.get(a);
          if (recomp) {
            recomp = recomp.get(b);
            if (recomp) {
              return recomp;
            }
          }
          return -1;
        }
      }
      function decomposed(cps) {
        let ret = [];
        let buf = [];
        let check_order = false;
        function add(cp) {
          let cc = SHIFTED_RANK.get(cp);
          if (cc) {
            check_order = true;
            cp |= cc;
          }
          ret.push(cp);
        }
        for (let cp of cps) {
          while (true) {
            if (cp < 0x80) {
              ret.push(cp);
            } else if (is_hangul(cp)) {
              let s_index = cp - S0;
              let l_index = s_index / N_COUNT | 0;
              let v_index = s_index % N_COUNT / T_COUNT | 0;
              let t_index = s_index % T_COUNT;
              add(L0 + l_index);
              add(V0 + v_index);
              if (t_index > 0) add(T0 + t_index);
            } else {
              let mapped = DECOMP.get(cp);
              if (mapped) {
                buf.push(...mapped);
              } else {
                add(cp);
              }
            }
            if (!buf.length) break;
            cp = buf.pop();
          }
        }
        if (check_order && ret.length > 1) {
          let prev_cc = unpack_cc(ret[0]);
          for (let i = 1; i < ret.length; i++) {
            let cc = unpack_cc(ret[i]);
            if (cc == 0 || prev_cc <= cc) {
              prev_cc = cc;
              continue;
            }
            let j = i - 1;
            while (true) {
              let tmp = ret[j + 1];
              ret[j + 1] = ret[j];
              ret[j] = tmp;
              if (!j) break;
              prev_cc = unpack_cc(ret[--j]);
              if (prev_cc <= cc) break;
            }
            prev_cc = unpack_cc(ret[i]);
          }
        }
        return ret;
      }
      function composed_from_decomposed(v) {
        let ret = [];
        let stack = [];
        let prev_cp = -1;
        let prev_cc = 0;
        for (let packed of v) {
          let cc = unpack_cc(packed);
          let cp = unpack_cp(packed);
          if (prev_cp == -1) {
            if (cc == 0) {
              prev_cp = cp;
            } else {
              ret.push(cp);
            }
          } else if (prev_cc > 0 && prev_cc >= cc) {
            if (cc == 0) {
              ret.push(prev_cp, ...stack);
              stack.length = 0;
              prev_cp = cp;
            } else {
              stack.push(cp);
            }
            prev_cc = cc;
          } else {
            let composed = compose_pair(prev_cp, cp);
            if (composed >= 0) {
              prev_cp = composed;
            } else if (prev_cc == 0 && cc == 0) {
              ret.push(prev_cp);
              prev_cp = cp;
            } else {
              stack.push(cp);
              prev_cc = cc;
            }
          }
        }
        if (prev_cp >= 0) {
          ret.push(prev_cp, ...stack);
        }
        return ret;
      }
      function nfd(cps) {
        return decomposed(cps).map(unpack_cp);
      }
      function nfc(cps) {
        return composed_from_decomposed(decomposed(cps));
      }
      const STOP = 0x2E;
      const FE0F = 0xFE0F;
      const STOP_CH = '.';
      const UNIQUE_PH = 1;
      const HYPHEN = 0x2D;
      function read_set() {
        return new Set(read_sorted(r$1));
      }
      const MAPPED = new Map(read_mapped(r$1));
      const IGNORED = read_set();
      const CM = read_set();
      const NSM = new Set(read_sorted(r$1).map(function (i) {
        return this[i];
      }, [...CM]));
      const ESCAPE = read_set();
      const NFC_CHECK = read_set();
      const CHUNKS = read_sorted_arrays(r$1);
      function read_chunked() {
        return new Set([read_sorted(r$1).map(i => CHUNKS[i]), read_sorted(r$1)].flat(2));
      }
      const UNRESTRICTED = r$1();
      const GROUPS = read_array_while(i => {
        let N = read_array_while(r$1).map(x => x + 0x60);
        if (N.length) {
          let R = i >= UNRESTRICTED;
          N[0] -= 32;
          N = str_from_cps(N);
          if (R) N = `Restricted[${N}]`;
          let P = read_chunked();
          let Q = read_chunked();
          let V = [...P, ...Q].sort((a, b) => a - b);
          let M = !r$1();
          return {
            N,
            P,
            M,
            R,
            V: new Set(V)
          };
        }
      });
      const WHOLE_VALID = read_set();
      const WHOLE_MAP = new Map();
      [...WHOLE_VALID, ...read_set()].sort((a, b) => a - b).map((cp, i, v) => {
        let d = r$1();
        let w = v[i] = d ? v[i - d] : {
          V: [],
          M: new Map()
        };
        w.V.push(cp);
        if (!WHOLE_VALID.has(cp)) {
          WHOLE_MAP.set(cp, w);
        }
      });
      for (let {
        V,
        M
      } of new Set(WHOLE_MAP.values())) {
        let recs = [];
        for (let cp of V) {
          let gs = GROUPS.filter(g => g.V.has(cp));
          let rec = recs.find(({
            G
          }) => gs.some(g => G.has(g)));
          if (!rec) {
            rec = {
              G: new Set(),
              V: []
            };
            recs.push(rec);
          }
          rec.V.push(cp);
          gs.forEach(g => rec.G.add(g));
        }
        let union = recs.flatMap(({
          G
        }) => [...G]);
        for (let {
          G,
          V
        } of recs) {
          let complement = new Set(union.filter(g => !G.has(g)));
          for (let cp of V) {
            M.set(cp, complement);
          }
        }
      }
      let union = new Set();
      let multi = new Set();
      for (let g of GROUPS) {
        for (let cp of g.V) {
          (union.has(cp) ? multi : union).add(cp);
        }
      }
      for (let cp of union) {
        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
          WHOLE_MAP.set(cp, UNIQUE_PH);
        }
      }
      const VALID = new Set([...union, ...nfd(union)]);
      const EMOJI_SORTED = read_sorted(r$1);
      const EMOJI_ROOT = read_emoji_trie([]);
      function read_emoji_trie(cps) {
        let B = read_array_while(() => {
          let keys = read_sorted(r$1).map(i => EMOJI_SORTED[i]);
          if (keys.length) return read_emoji_trie(keys);
        }).sort((a, b) => b.Q.size - a.Q.size);
        let temp = r$1();
        let V = temp % 3;
        temp = temp / 3 | 0;
        let F = temp & 1;
        temp >>= 1;
        let S = temp & 1;
        let C = temp & 2;
        return {
          B,
          V,
          F,
          S,
          C,
          Q: new Set(cps)
        };
      }
      class Emoji extends Array {
        get is_emoji() {
          return true;
        }
      }
      function safe_str_from_cps(cps, quoter = quote_cp) {
        let buf = [];
        if (is_combining_mark(cps[0])) buf.push('');
        let prev = 0;
        let n = cps.length;
        for (let i = 0; i < n; i++) {
          let cp = cps[i];
          if (should_escape(cp)) {
            buf.push(str_from_cps(cps.slice(prev, i)));
            buf.push(quoter(cp));
            prev = i + 1;
          }
        }
        buf.push(str_from_cps(cps.slice(prev, n)));
        return buf.join('');
      }
      function quoted_cp(cp) {
        return (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
      }
      function bidi_qq(s) {
        return `"${s}"\u200E`;
      }
      function check_label_extension(cps) {
        if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
          throw new Error('invalid label extension');
        }
      }
      function check_leading_underscore(cps) {
        const UNDERSCORE = 0x5F;
        for (let i = cps.lastIndexOf(UNDERSCORE); i > 0;) {
          if (cps[--i] !== UNDERSCORE) {
            throw new Error('underscore allowed only at start');
          }
        }
      }
      function check_fenced(cps) {
        let cp = cps[0];
        let prev = FENCED.get(cp);
        if (prev) throw error_placement(`leading ${prev}`);
        let n = cps.length;
        let last = -1;
        for (let i = 1; i < n; i++) {
          cp = cps[i];
          let match = FENCED.get(cp);
          if (match) {
            if (last == i) throw error_placement(`${prev} + ${match}`);
            last = i + 1;
            prev = match;
          }
        }
        if (last == n) throw error_placement(`trailing ${prev}`);
      }
      function is_combining_mark(cp) {
        return CM.has(cp);
      }
      function should_escape(cp) {
        return ESCAPE.has(cp);
      }
      function ens_normalize_fragment(frag, decompose) {
        let nf = decompose ? nfd : nfc;
        return frag.split(STOP_CH).map(label => str_from_cps(process(explode_cp(label), nf).flatMap(x => x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);
      }
      function ens_normalize(name) {
        return flatten(ens_split(name));
      }
      function ens_beautify(name) {
        let split = ens_split(name, true);
        for (let {
          type,
          output,
          error
        } of split) {
          if (error) continue;
          if (type !== 'Greek') {
            let prev = 0;
            while (true) {
              let next = output.indexOf(0x3BE, prev);
              if (next < 0) break;
              output[next] = 0x39E;
              prev = next + 1;
            }
          }
        }
        return flatten(split);
      }
      function ens_split(name, preserve_emoji) {
        let offset = 0;
        return name.split(STOP_CH).map(label => {
          let input = explode_cp(label);
          let info = {
            input,
            offset
          };
          offset += input.length + 1;
          let norm;
          try {
            let tokens = info.tokens = process(input, nfc);
            let token_count = tokens.length;
            let type;
            if (!token_count) {
              throw new Error(`empty label`);
            } else {
              let chars = tokens[0];
              let emoji = token_count > 1 || chars.is_emoji;
              if (!emoji && chars.every(cp => cp < 0x80)) {
                norm = chars;
                check_leading_underscore(norm);
                check_label_extension(norm);
                type = 'ASCII';
              } else {
                if (emoji) {
                  info.emoji = true;
                  chars = tokens.flatMap(x => x.is_emoji ? [] : x);
                }
                norm = tokens.flatMap(x => !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);
                check_leading_underscore(norm);
                if (!chars.length) {
                  type = 'Emoji';
                } else {
                  if (CM.has(norm[0])) throw error_placement('leading combining mark');
                  for (let i = 1; i < token_count; i++) {
                    let cps = tokens[i];
                    if (!cps.is_emoji && CM.has(cps[0])) {
                      throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
                    }
                  }
                  check_fenced(norm);
                  let unique = [...new Set(chars)];
                  let [g] = determine_group(unique);
                  check_group(g, chars);
                  check_whole(g, unique);
                  type = g.N;
                }
              }
            }
            info.type = type;
          } catch (err) {
            info.error = err;
          }
          info.output = norm;
          return info;
        });
      }
      function check_whole(group, unique) {
        let maker;
        let shared = [];
        for (let cp of unique) {
          let whole = WHOLE_MAP.get(cp);
          if (whole === UNIQUE_PH) return;
          if (whole) {
            let set = whole.M.get(cp);
            maker = maker ? maker.filter(g => set.has(g)) : [...set];
            if (!maker.length) return;
          } else {
            shared.push(cp);
          }
        }
        if (maker) {
          for (let g of maker) {
            if (shared.every(cp => g.V.has(cp))) {
              throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
            }
          }
        }
      }
      function determine_group(unique) {
        let groups = GROUPS;
        for (let cp of unique) {
          let gs = groups.filter(g => g.V.has(cp));
          if (!gs.length) {
            if (groups === GROUPS) {
              throw error_disallowed(cp);
            } else {
              throw error_group_member(groups[0], cp);
            }
          }
          groups = gs;
          if (gs.length == 1) break;
        }
        return groups;
      }
      function flatten(split) {
        return split.map(({
          input,
          error,
          output
        }) => {
          if (error) {
            let msg = error.message;
            throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);
          }
          return str_from_cps(output);
        }).join(STOP_CH);
      }
      function error_disallowed(cp) {
        return new Error(`disallowed character: ${quoted_cp(cp)}`);
      }
      function error_group_member(g, cp) {
        let quoted = quoted_cp(cp);
        let gg = GROUPS.find(g => g.P.has(cp));
        if (gg) {
          quoted = `${gg.N} ${quoted}`;
        }
        return new Error(`illegal mixture: ${g.N} + ${quoted}`);
      }
      function error_placement(where) {
        return new Error(`illegal placement: ${where}`);
      }
      function check_group(g, cps) {
        let {
          V,
          M
        } = g;
        for (let cp of cps) {
          if (!V.has(cp)) {
            throw error_group_member(g, cp);
          }
        }
        if (M) {
          let decomposed = nfd(cps);
          for (let i = 1, e = decomposed.length; i < e; i++) {
            if (NSM.has(decomposed[i])) {
              let j = i + 1;
              for (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {
                for (let k = i; k < j; k++) {
                  if (decomposed[k] == cp) {
                    throw new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);
                  }
                }
              }
              if (j - i > NSM_MAX) {
                throw new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
              }
              i = j;
            }
          }
        }
      }
      function process(input, nf) {
        let ret = [];
        let chars = [];
        input = input.slice().reverse();
        while (input.length) {
          let emoji = consume_emoji_reversed(input);
          if (emoji) {
            if (chars.length) {
              ret.push(nf(chars));
              chars = [];
            }
            ret.push(emoji);
          } else {
            let cp = input.pop();
            if (VALID.has(cp)) {
              chars.push(cp);
            } else {
              let cps = MAPPED.get(cp);
              if (cps) {
                chars.push(...cps);
              } else if (!IGNORED.has(cp)) {
                throw error_disallowed(cp);
              }
            }
          }
        }
        if (chars.length) {
          ret.push(nf(chars));
        }
        return ret;
      }
      function filter_fe0f(cps) {
        return cps.filter(cp => cp != FE0F);
      }
      function consume_emoji_reversed(cps, eaten) {
        let node = EMOJI_ROOT;
        let emoji;
        let saved;
        let stack = [];
        let pos = cps.length;
        if (eaten) eaten.length = 0;
        while (pos) {
          let cp = cps[--pos];
          node = node.B.find(x => x.Q.has(cp));
          if (!node) break;
          if (node.S) {
            saved = cp;
          } else if (node.C) {
            if (cp === saved) break;
          }
          stack.push(cp);
          if (node.F) {
            stack.push(FE0F);
            if (pos > 0 && cps[pos - 1] == FE0F) pos--;
          }
          if (node.V) {
            emoji = conform_emoji_copy(stack, node);
            if (eaten) eaten.push(...cps.slice(pos).reverse());
            cps.length = pos;
          }
        }
        return emoji;
      }
      function conform_emoji_copy(cps, node) {
        let copy = Emoji.from(cps);
        if (node.V == 2) copy.splice(1, 1);
        return copy;
      }
      function ens_emoji() {
        let ret = [];
        build(EMOJI_ROOT, []);
        return ret.sort(compare_arrays);
        function build(node, cps, saved) {
          if (node.S) {
            saved = cps[cps.length - 1];
          } else if (node.C) {
            if (saved === cps[cps.length - 1]) return;
          }
          if (node.F) cps.push(FE0F);
          if (node.V) ret.push(conform_emoji_copy(cps, node));
          for (let br of node.B) {
            for (let cp of br.Q) {
              build(br, [...cps, cp], saved);
            }
          }
        }
      }
      const TY_VALID = 'valid';
      const TY_MAPPED = 'mapped';
      const TY_IGNORED = 'ignored';
      const TY_DISALLOWED = 'disallowed';
      const TY_EMOJI = 'emoji';
      const TY_NFC = 'nfc';
      const TY_STOP = 'stop';
      function ens_tokenize(name, {
        nf = true
      } = {}) {
        let input = explode_cp(name).reverse();
        let eaten = [];
        let tokens = [];
        while (input.length) {
          let emoji = consume_emoji_reversed(input, eaten);
          if (emoji) {
            tokens.push({
              type: TY_EMOJI,
              emoji,
              input: eaten.slice(),
              cps: filter_fe0f(emoji)
            });
          } else {
            let cp = input.pop();
            if (cp == STOP) {
              tokens.push({
                type: TY_STOP,
                cp
              });
            } else if (VALID.has(cp)) {
              tokens.push({
                type: TY_VALID,
                cps: [cp]
              });
            } else if (IGNORED.has(cp)) {
              tokens.push({
                type: TY_IGNORED,
                cp
              });
            } else {
              let cps = MAPPED.get(cp);
              if (cps) {
                tokens.push({
                  type: TY_MAPPED,
                  cp,
                  cps: cps.slice()
                });
              } else {
                tokens.push({
                  type: TY_DISALLOWED,
                  cp
                });
              }
            }
          }
        }
        if (nf) {
          for (let i = 0, start = -1; i < tokens.length; i++) {
            let token = tokens[i];
            if (is_valid_or_mapped(token.type)) {
              if (requires_check(token.cps)) {
                let end = i + 1;
                for (let pos = end; pos < tokens.length; pos++) {
                  let {
                    type,
                    cps
                  } = tokens[pos];
                  if (is_valid_or_mapped(type)) {
                    if (!requires_check(cps)) break;
                    end = pos + 1;
                  } else if (type !== TY_IGNORED) {
                    break;
                  }
                }
                if (start < 0) start = i;
                let slice = tokens.slice(start, end);
                let cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []);
                let cps = nfc(cps0);
                if (compare_arrays(cps, cps0)) {
                  tokens.splice(start, end - start, {
                    type: TY_NFC,
                    input: cps0,
                    cps,
                    tokens0: collapse_valid_tokens(slice),
                    tokens: ens_tokenize(str_from_cps(cps), {
                      nf: false
                    })
                  });
                  i = start;
                } else {
                  i = end - 1;
                }
                start = -1;
              } else {
                start = i;
              }
            } else if (token.type !== TY_IGNORED) {
              start = -1;
            }
          }
        }
        return collapse_valid_tokens(tokens);
      }
      function is_valid_or_mapped(type) {
        return type == TY_VALID || type == TY_MAPPED;
      }
      function requires_check(cps) {
        return cps.some(cp => NFC_CHECK.has(cp));
      }
      function collapse_valid_tokens(tokens) {
        for (let i = 0; i < tokens.length; i++) {
          if (tokens[i].type == TY_VALID) {
            let j = i + 1;
            while (j < tokens.length && tokens[j].type == TY_VALID) j++;
            tokens.splice(i, j - i, {
              type: TY_VALID,
              cps: tokens.slice(i, j).flatMap(x => x.cps)
            });
          }
        }
        return tokens;
      }
      exports.ens_beautify = ens_beautify;
      exports.ens_emoji = ens_emoji;
      exports.ens_normalize = ens_normalize;
      exports.ens_normalize_fragment = ens_normalize_fragment;
      exports.ens_split = ens_split;
      exports.ens_tokenize = ens_tokenize;
      exports.is_combining_mark = is_combining_mark;
      exports.nfc = nfc;
      exports.nfd = nfd;
      exports.safe_str_from_cps = safe_str_from_cps;
      exports.should_escape = should_escape;
    },
    17: function (__unused_webpack_module, exports) {
      "use strict";

      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var _AES_key, _AES_Kd, _AES_Ke;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AES = void 0;
      const numberOfRounds = {
        16: 10,
        24: 12,
        32: 14
      };
      const rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];
      const S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
      const Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];
      const T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
      const T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
      const T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
      const T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];
      const T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
      const T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
      const T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
      const T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];
      const U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
      const U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
      const U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
      const U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
      function convertToInt32(bytes) {
        const result = [];
        for (let i = 0; i < bytes.length; i += 4) {
          result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
        }
        return result;
      }
      class AES {
        get key() {
          return __classPrivateFieldGet(this, _AES_key, "f").slice();
        }
        constructor(key) {
          _AES_key.set(this, void 0);
          _AES_Kd.set(this, void 0);
          _AES_Ke.set(this, void 0);
          if (!(this instanceof AES)) {
            throw Error('AES must be instanitated with `new`');
          }
          __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), "f");
          const rounds = numberOfRounds[this.key.length];
          if (rounds == null) {
            throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');
          }
          __classPrivateFieldSet(this, _AES_Ke, [], "f");
          __classPrivateFieldSet(this, _AES_Kd, [], "f");
          for (let i = 0; i <= rounds; i++) {
            __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
            __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
          }
          const roundKeyCount = (rounds + 1) * 4;
          const KC = this.key.length / 4;
          const tk = convertToInt32(this.key);
          let index;
          for (let i = 0; i < KC; i++) {
            index = i >> 2;
            __classPrivateFieldGet(this, _AES_Ke, "f")[index][i % 4] = tk[i];
            __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
          }
          let rconpointer = 0;
          let t = KC,
            tt;
          while (t < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
            rconpointer += 1;
            if (KC != 8) {
              for (let i = 1; i < KC; i++) {
                tk[i] ^= tk[i - 1];
              }
            } else {
              for (let i = 1; i < KC / 2; i++) {
                tk[i] ^= tk[i - 1];
              }
              tt = tk[KC / 2 - 1];
              tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;
              for (let i = KC / 2 + 1; i < KC; i++) {
                tk[i] ^= tk[i - 1];
              }
            }
            let i = 0,
              r,
              c;
            while (i < KC && t < roundKeyCount) {
              r = t >> 2;
              c = t % 4;
              __classPrivateFieldGet(this, _AES_Ke, "f")[r][c] = tk[i];
              __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r][c] = tk[i++];
              t++;
            }
          }
          for (let r = 1; r < rounds; r++) {
            for (let c = 0; c < 4; c++) {
              tt = __classPrivateFieldGet(this, _AES_Kd, "f")[r][c];
              __classPrivateFieldGet(this, _AES_Kd, "f")[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
            }
          }
        }
        encrypt(plaintext) {
          if (plaintext.length != 16) {
            throw new TypeError('invalid plaintext size (must be 16 bytes)');
          }
          const rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
          const a = [0, 0, 0, 0];
          let t = convertToInt32(plaintext);
          for (let i = 0; i < 4; i++) {
            t[i] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i];
          }
          for (let r = 1; r < rounds; r++) {
            for (let i = 0; i < 4; i++) {
              a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Ke, "f")[r][i];
            }
            t = a.slice();
          }
          const result = new Uint8Array(16);
          let tt = 0;
          for (let i = 0; i < 4; i++) {
            tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][i];
            result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
            result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
            result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
          }
          return result;
        }
        decrypt(ciphertext) {
          if (ciphertext.length != 16) {
            throw new TypeError('invalid ciphertext size (must be 16 bytes)');
          }
          const rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
          const a = [0, 0, 0, 0];
          let t = convertToInt32(ciphertext);
          for (let i = 0; i < 4; i++) {
            t[i] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i];
          }
          for (let r = 1; r < rounds; r++) {
            for (let i = 0; i < 4; i++) {
              a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Kd, "f")[r][i];
            }
            t = a.slice();
          }
          const result = new Uint8Array(16);
          let tt = 0;
          for (let i = 0; i < 4; i++) {
            tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][i];
            result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
            result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
            result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
          }
          return result;
        }
      }
      exports.AES = AES;
      _AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();
    },
    205: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pkcs7Strip = exports.pkcs7Pad = exports.OFB = exports.ECB = exports.CTR = exports.CFB = exports.CBC = exports.ModeOfOperation = exports.AES = void 0;
      var aes_js_1 = __webpack_require__(17);
      Object.defineProperty(exports, "AES", {
        enumerable: true,
        get: function () {
          return aes_js_1.AES;
        }
      });
      var mode_js_1 = __webpack_require__(6756);
      Object.defineProperty(exports, "ModeOfOperation", {
        enumerable: true,
        get: function () {
          return mode_js_1.ModeOfOperation;
        }
      });
      var mode_cbc_js_1 = __webpack_require__(9193);
      Object.defineProperty(exports, "CBC", {
        enumerable: true,
        get: function () {
          return mode_cbc_js_1.CBC;
        }
      });
      var mode_cfb_js_1 = __webpack_require__(8150);
      Object.defineProperty(exports, "CFB", {
        enumerable: true,
        get: function () {
          return mode_cfb_js_1.CFB;
        }
      });
      var mode_ctr_js_1 = __webpack_require__(9505);
      Object.defineProperty(exports, "CTR", {
        enumerable: true,
        get: function () {
          return mode_ctr_js_1.CTR;
        }
      });
      var mode_ecb_js_1 = __webpack_require__(3161);
      Object.defineProperty(exports, "ECB", {
        enumerable: true,
        get: function () {
          return mode_ecb_js_1.ECB;
        }
      });
      var mode_ofb_js_1 = __webpack_require__(6386);
      Object.defineProperty(exports, "OFB", {
        enumerable: true,
        get: function () {
          return mode_ofb_js_1.OFB;
        }
      });
      var padding_js_1 = __webpack_require__(7431);
      Object.defineProperty(exports, "pkcs7Pad", {
        enumerable: true,
        get: function () {
          return padding_js_1.pkcs7Pad;
        }
      });
      Object.defineProperty(exports, "pkcs7Strip", {
        enumerable: true,
        get: function () {
          return padding_js_1.pkcs7Strip;
        }
      });
    },
    9193: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _CBC_iv, _CBC_lastBlock;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CBC = void 0;
      const mode_js_1 = __webpack_require__(6756);
      class CBC extends mode_js_1.ModeOfOperation {
        constructor(key, iv) {
          super("ECC", key, CBC);
          _CBC_iv.set(this, void 0);
          _CBC_lastBlock.set(this, void 0);
          if (iv) {
            if (iv.length % 16) {
              throw new TypeError("invalid iv size (must be 16 bytes)");
            }
            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(iv), "f");
          } else {
            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(16), "f");
          }
          __classPrivateFieldSet(this, _CBC_lastBlock, this.iv, "f");
        }
        get iv() {
          return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, "f"));
        }
        encrypt(plaintext) {
          if (plaintext.length % 16) {
            throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
          }
          const ciphertext = new Uint8Array(plaintext.length);
          for (let i = 0; i < plaintext.length; i += 16) {
            for (let j = 0; j < 16; j++) {
              __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
            }
            __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, "f")), "f");
            ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, "f"), i);
          }
          return ciphertext;
        }
        decrypt(ciphertext) {
          if (ciphertext.length % 16) {
            throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          const plaintext = new Uint8Array(ciphertext.length);
          for (let i = 0; i < ciphertext.length; i += 16) {
            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
            for (let j = 0; j < 16; j++) {
              plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j];
              __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
            }
          }
          return plaintext;
        }
      }
      exports.CBC = CBC;
      _CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();
    },
    8150: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CFB = void 0;
      const mode_js_1 = __webpack_require__(6756);
      class CFB extends mode_js_1.ModeOfOperation {
        constructor(key, iv, segmentSize = 8) {
          super("CFB", key, CFB);
          _CFB_instances.add(this);
          _CFB_iv.set(this, void 0);
          _CFB_shiftRegister.set(this, void 0);
          if (!Number.isInteger(segmentSize) || segmentSize % 8) {
            throw new TypeError("invalid segmentSize");
          }
          Object.defineProperties(this, {
            segmentSize: {
              enumerable: true,
              value: segmentSize
            }
          });
          if (iv) {
            if (iv.length % 16) {
              throw new TypeError("invalid iv size (must be 16 bytes)");
            }
            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), "f");
          } else {
            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), "f");
          }
          __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, "f");
        }
        get iv() {
          return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, "f"));
        }
        encrypt(plaintext) {
          if (8 * plaintext.length % this.segmentSize) {
            throw new TypeError("invalid plaintext size (must be multiple of segmentSize bytes)");
          }
          const segmentSize = this.segmentSize / 8;
          const ciphertext = new Uint8Array(plaintext);
          for (let i = 0; i < ciphertext.length; i += segmentSize) {
            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, "f"));
            for (let j = 0; j < segmentSize; j++) {
              ciphertext[i + j] ^= xorSegment[j];
            }
            __classPrivateFieldGet(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i));
          }
          return ciphertext;
        }
        decrypt(ciphertext) {
          if (8 * ciphertext.length % this.segmentSize) {
            throw new TypeError("invalid ciphertext size (must be multiple of segmentSize bytes)");
          }
          const segmentSize = this.segmentSize / 8;
          const plaintext = new Uint8Array(ciphertext);
          for (let i = 0; i < plaintext.length; i += segmentSize) {
            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, "f"));
            for (let j = 0; j < segmentSize; j++) {
              plaintext[i + j] ^= xorSegment[j];
            }
            __classPrivateFieldGet(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i));
          }
          return plaintext;
        }
      }
      exports.CFB = CFB;
      _CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {
        const segmentSize = this.segmentSize / 8;
        __classPrivateFieldGet(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet(this, _CFB_shiftRegister, "f").subarray(segmentSize));
        __classPrivateFieldGet(this, _CFB_shiftRegister, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
      };
    },
    9505: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CTR = void 0;
      const mode_js_1 = __webpack_require__(6756);
      class CTR extends mode_js_1.ModeOfOperation {
        constructor(key, initialValue) {
          super("CTR", key, CTR);
          _CTR_remaining.set(this, void 0);
          _CTR_remainingIndex.set(this, void 0);
          _CTR_counter.set(this, void 0);
          __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
          __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
          __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, "f"), "f");
          __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
          if (initialValue == null) {
            initialValue = 1;
          }
          if (typeof initialValue === "number") {
            this.setCounterValue(initialValue);
          } else {
            this.setCounterBytes(initialValue);
          }
        }
        get counter() {
          return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f"));
        }
        setCounterValue(value) {
          if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
            throw new TypeError("invalid counter initial integer value");
          }
          for (let index = 15; index >= 0; --index) {
            __classPrivateFieldGet(this, _CTR_counter, "f")[index] = value % 256;
            value = Math.floor(value / 256);
          }
        }
        setCounterBytes(value) {
          if (value.length !== 16) {
            throw new TypeError("invalid counter initial Uint8Array value length");
          }
          __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
        }
        increment() {
          for (let i = 15; i >= 0; i--) {
            if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
              __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
            } else {
              __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
              break;
            }
          }
        }
        encrypt(plaintext) {
          var _a, _b;
          const crypttext = new Uint8Array(plaintext);
          for (let i = 0; i < crypttext.length; i++) {
            if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
              __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
              __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
              this.increment();
            }
            crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[(__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a)];
          }
          return crypttext;
        }
        decrypt(ciphertext) {
          return this.encrypt(ciphertext);
        }
      }
      exports.CTR = CTR;
      _CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();
    },
    3161: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ECB = void 0;
      const mode_js_1 = __webpack_require__(6756);
      class ECB extends mode_js_1.ModeOfOperation {
        constructor(key) {
          super("ECB", key, ECB);
        }
        encrypt(plaintext) {
          if (plaintext.length % 16) {
            throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
          }
          const crypttext = new Uint8Array(plaintext.length);
          for (let i = 0; i < plaintext.length; i += 16) {
            crypttext.set(this.aes.encrypt(plaintext.subarray(i, i + 16)), i);
          }
          return crypttext;
        }
        decrypt(crypttext) {
          if (crypttext.length % 16) {
            throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          const plaintext = new Uint8Array(crypttext.length);
          for (let i = 0; i < crypttext.length; i += 16) {
            plaintext.set(this.aes.decrypt(crypttext.subarray(i, i + 16)), i);
          }
          return plaintext;
        }
      }
      exports.ECB = ECB;
    },
    6386: function (__unused_webpack_module, exports, __webpack_require__) {
      "use strict";

      var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OFB = void 0;
      const mode_js_1 = __webpack_require__(6756);
      class OFB extends mode_js_1.ModeOfOperation {
        constructor(key, iv) {
          super("OFB", key, OFB);
          _OFB_iv.set(this, void 0);
          _OFB_lastPrecipher.set(this, void 0);
          _OFB_lastPrecipherIndex.set(this, void 0);
          if (iv) {
            if (iv.length % 16) {
              throw new TypeError("invalid iv size (must be 16 bytes)");
            }
            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(iv), "f");
          } else {
            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(16), "f");
          }
          __classPrivateFieldSet(this, _OFB_lastPrecipher, this.iv, "f");
          __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 16, "f");
        }
        get iv() {
          return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, "f"));
        }
        encrypt(plaintext) {
          var _a, _b;
          if (plaintext.length % 16) {
            throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
          }
          const ciphertext = new Uint8Array(plaintext);
          for (let i = 0; i < ciphertext.length; i++) {
            if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f") === 16) {
              __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, "f")), "f");
              __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, "f");
            }
            ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, "f")[(__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f"), _a = _b++, _b), "f"), _a)];
          }
          return ciphertext;
        }
        decrypt(ciphertext) {
          if (ciphertext.length % 16) {
            throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          return this.encrypt(ciphertext);
        }
      }
      exports.OFB = OFB;
      _OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap();
    },
    6756: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ModeOfOperation = void 0;
      const aes_js_1 = __webpack_require__(17);
      class ModeOfOperation {
        constructor(name, key, cls) {
          if (cls && !(this instanceof cls)) {
            throw new Error(`${name} must be instantiated with "new"`);
          }
          Object.defineProperties(this, {
            aes: {
              enumerable: true,
              value: new aes_js_1.AES(key)
            },
            name: {
              enumerable: true,
              value: name
            }
          });
        }
      }
      exports.ModeOfOperation = ModeOfOperation;
    },
    7431: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pkcs7Strip = exports.pkcs7Pad = void 0;
      function pkcs7Pad(data) {
        const padder = 16 - data.length % 16;
        const result = new Uint8Array(data.length + padder);
        result.set(data);
        for (let i = data.length; i < result.length; i++) {
          result[i] = padder;
        }
        return result;
      }
      exports.pkcs7Pad = pkcs7Pad;
      function pkcs7Strip(data) {
        if (data.length < 16) {
          throw new TypeError('PKCS#7 invalid length');
        }
        const padder = data[data.length - 1];
        if (padder > 16) {
          throw new TypeError('PKCS#7 padding byte out of range');
        }
        const length = data.length - padder;
        for (let i = 0; i < padder; i++) {
          if (data[length + i] !== padder) {
            throw new TypeError('PKCS#7 invalid padding byte');
          }
        }
        return new Uint8Array(data.subarray(0, length));
      }
      exports.pkcs7Strip = pkcs7Strip;
    },
    2191: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";

      var possibleNames = ['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'];
      var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
      module.exports = function availableTypedArrays() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g[possibleNames[i]] === 'function') {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
    },
    9737: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.version = void 0;
      exports.version = "6.7.1";
    },
    3126: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AbiCoder = void 0;
      const index_js_1 = __webpack_require__(9830);
      const abstract_coder_js_1 = __webpack_require__(6094);
      const address_js_1 = __webpack_require__(5411);
      const array_js_1 = __webpack_require__(734);
      const boolean_js_1 = __webpack_require__(5192);
      const bytes_js_1 = __webpack_require__(8342);
      const fixed_bytes_js_1 = __webpack_require__(3151);
      const null_js_1 = __webpack_require__(6255);
      const number_js_1 = __webpack_require__(4482);
      const string_js_1 = __webpack_require__(1193);
      const tuple_js_1 = __webpack_require__(8198);
      const fragments_js_1 = __webpack_require__(8569);
      const index_js_2 = __webpack_require__(2134);
      const index_js_3 = __webpack_require__(9830);
      const PanicReasons = new Map();
      PanicReasons.set(0x00, "GENERIC_PANIC");
      PanicReasons.set(0x01, "ASSERT_FALSE");
      PanicReasons.set(0x11, "OVERFLOW");
      PanicReasons.set(0x12, "DIVIDE_BY_ZERO");
      PanicReasons.set(0x21, "ENUM_RANGE_ERROR");
      PanicReasons.set(0x22, "BAD_STORAGE_DATA");
      PanicReasons.set(0x31, "STACK_UNDERFLOW");
      PanicReasons.set(0x32, "ARRAY_RANGE_ERROR");
      PanicReasons.set(0x41, "OUT_OF_MEMORY");
      PanicReasons.set(0x51, "UNINITIALIZED_FUNCTION_CALL");
      const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
      const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
      let defaultCoder = null;
      function getBuiltinCallException(action, tx, data, abiCoder) {
        let message = "missing revert data";
        let reason = null;
        const invocation = null;
        let revert = null;
        if (data) {
          message = "execution reverted";
          const bytes = (0, index_js_3.getBytes)(data);
          data = (0, index_js_3.hexlify)(data);
          if (bytes.length === 0) {
            message += " (no data present; likely require(false) occurred";
            reason = "require(false)";
          } else if (bytes.length % 32 !== 4) {
            message += " (could not decode reason; invalid data length)";
          } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x08c379a0") {
            try {
              reason = abiCoder.decode(["string"], bytes.slice(4))[0];
              revert = {
                signature: "Error(string)",
                name: "Error",
                args: [reason]
              };
              message += `: ${JSON.stringify(reason)}`;
            } catch (error) {
              message += " (could not decode reason; invalid string data)";
            }
          } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x4e487b71") {
            try {
              const code = Number(abiCoder.decode(["uint256"], bytes.slice(4))[0]);
              revert = {
                signature: "Panic(uint256)",
                name: "Panic",
                args: [code]
              };
              reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
              message += `: ${reason}`;
            } catch (error) {
              message += " (could not decode panic code)";
            }
          } else {
            message += " (unknown custom error)";
          }
        }
        const transaction = {
          to: tx.to ? (0, index_js_2.getAddress)(tx.to) : null,
          data: tx.data || "0x"
        };
        if (tx.from) {
          transaction.from = (0, index_js_2.getAddress)(tx.from);
        }
        return (0, index_js_3.makeError)(message, "CALL_EXCEPTION", {
          action,
          data,
          reason,
          transaction,
          invocation,
          revert
        });
      }
      class AbiCoder {
        #getCoder(param) {
          if (param.isArray()) {
            return new array_js_1.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
          }
          if (param.isTuple()) {
            return new tuple_js_1.TupleCoder(param.components.map(c => this.#getCoder(c)), param.name);
          }
          switch (param.baseType) {
            case "address":
              return new address_js_1.AddressCoder(param.name);
            case "bool":
              return new boolean_js_1.BooleanCoder(param.name);
            case "string":
              return new string_js_1.StringCoder(param.name);
            case "bytes":
              return new bytes_js_1.BytesCoder(param.name);
            case "":
              return new null_js_1.NullCoder(param.name);
          }
          let match = param.type.match(paramTypeNumber);
          if (match) {
            let size = parseInt(match[2] || "256");
            (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
            return new number_js_1.NumberCoder(size / 8, match[1] === "int", param.name);
          }
          match = param.type.match(paramTypeBytes);
          if (match) {
            let size = parseInt(match[1]);
            (0, index_js_1.assertArgument)(size !== 0 && size <= 32, "invalid bytes length", "param", param);
            return new fixed_bytes_js_1.FixedBytesCoder(size, param.name);
          }
          (0, index_js_1.assertArgument)(false, "invalid type", "type", param.type);
        }
        getDefaultValue(types) {
          const coders = types.map(type => this.#getCoder(fragments_js_1.ParamType.from(type)));
          const coder = new tuple_js_1.TupleCoder(coders, "_");
          return coder.defaultValue();
        }
        encode(types, values) {
          (0, index_js_1.assertArgumentCount)(values.length, types.length, "types/values length mismatch");
          const coders = types.map(type => this.#getCoder(fragments_js_1.ParamType.from(type)));
          const coder = new tuple_js_1.TupleCoder(coders, "_");
          const writer = new abstract_coder_js_1.Writer();
          coder.encode(writer, values);
          return writer.data;
        }
        decode(types, data, loose) {
          const coders = types.map(type => this.#getCoder(fragments_js_1.ParamType.from(type)));
          const coder = new tuple_js_1.TupleCoder(coders, "_");
          return coder.decode(new abstract_coder_js_1.Reader(data, loose));
        }
        static defaultAbiCoder() {
          if (defaultCoder == null) {
            defaultCoder = new AbiCoder();
          }
          return defaultCoder;
        }
        static getBuiltinCallException(action, tx, data) {
          return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
        }
      }
      exports.AbiCoder = AbiCoder;
    },
    5670: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decodeBytes32String = exports.encodeBytes32String = void 0;
      const index_js_1 = __webpack_require__(9830);
      function encodeBytes32String(text) {
        const bytes = (0, index_js_1.toUtf8Bytes)(text);
        if (bytes.length > 31) {
          throw new Error("bytes32 string must be less than 32 bytes");
        }
        return (0, index_js_1.zeroPadBytes)(bytes, 32);
      }
      exports.encodeBytes32String = encodeBytes32String;
      function decodeBytes32String(_bytes) {
        const data = (0, index_js_1.getBytes)(_bytes, "bytes");
        if (data.length !== 32) {
          throw new Error("invalid bytes32 - not 32 bytes long");
        }
        if (data[31] !== 0) {
          throw new Error("invalid bytes32 string - no null terminator");
        }
        let length = 31;
        while (data[length - 1] === 0) {
          length--;
        }
        return (0, index_js_1.toUtf8String)(data.slice(0, length));
      }
      exports.decodeBytes32String = decodeBytes32String;
    },
    6094: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;
      const index_js_1 = __webpack_require__(9830);
      exports.WordSize = 32;
      const Padding = new Uint8Array(exports.WordSize);
      const passProperties = ["then"];
      const _guard = {};
      function throwError(name, error) {
        const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
        wrapped.error = error;
        throw wrapped;
      }
      class Result extends Array {
        #names;
        constructor(...args) {
          const guard = args[0];
          let items = args[1];
          let names = (args[2] || []).slice();
          let wrap = true;
          if (guard !== _guard) {
            items = args;
            names = [];
            wrap = false;
          }
          super(items.length);
          items.forEach((item, index) => {
            this[index] = item;
          });
          const nameCounts = names.reduce((accum, name) => {
            if (typeof name === "string") {
              accum.set(name, (accum.get(name) || 0) + 1);
            }
            return accum;
          }, new Map());
          this.#names = Object.freeze(items.map((item, index) => {
            const name = names[index];
            if (name != null && nameCounts.get(name) === 1) {
              return name;
            }
            return null;
          }));
          if (!wrap) {
            return;
          }
          Object.freeze(this);
          return new Proxy(this, {
            get: (target, prop, receiver) => {
              if (typeof prop === "string") {
                if (prop.match(/^[0-9]+$/)) {
                  const index = (0, index_js_1.getNumber)(prop, "%index");
                  if (index < 0 || index >= this.length) {
                    throw new RangeError("out of result range");
                  }
                  const item = target[index];
                  if (item instanceof Error) {
                    throwError(`index ${index}`, item);
                  }
                  return item;
                }
                if (passProperties.indexOf(prop) >= 0) {
                  return Reflect.get(target, prop, receiver);
                }
                const value = target[prop];
                if (value instanceof Function) {
                  return function (...args) {
                    return value.apply(this === receiver ? target : this, args);
                  };
                } else if (!(prop in target)) {
                  return target.getValue.apply(this === receiver ? target : this, [prop]);
                }
              }
              return Reflect.get(target, prop, receiver);
            }
          });
        }
        toArray() {
          const result = [];
          this.forEach((item, index) => {
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            result.push(item);
          });
          return result;
        }
        toObject() {
          return this.#names.reduce((accum, name, index) => {
            (0, index_js_1.assert)(name != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
              operation: "toObject()"
            });
            if (!(name in accum)) {
              accum[name] = this.getValue(name);
            }
            return accum;
          }, {});
        }
        slice(start, end) {
          if (start == null) {
            start = 0;
          }
          if (start < 0) {
            start += this.length;
            if (start < 0) {
              start = 0;
            }
          }
          if (end == null) {
            end = this.length;
          }
          if (end < 0) {
            end += this.length;
            if (end < 0) {
              end = 0;
            }
          }
          if (end > this.length) {
            end = this.length;
          }
          const result = [],
            names = [];
          for (let i = start; i < end; i++) {
            result.push(this[i]);
            names.push(this.#names[i]);
          }
          return new Result(_guard, result, names);
        }
        filter(callback, thisArg) {
          const result = [],
            names = [];
          for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
              throwError(`index ${i}`, item);
            }
            if (callback.call(thisArg, item, i, this)) {
              result.push(item);
              names.push(this.#names[i]);
            }
          }
          return new Result(_guard, result, names);
        }
        map(callback, thisArg) {
          const result = [];
          for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
              throwError(`index ${i}`, item);
            }
            result.push(callback.call(thisArg, item, i, this));
          }
          return result;
        }
        getValue(name) {
          const index = this.#names.indexOf(name);
          if (index === -1) {
            return undefined;
          }
          const value = this[index];
          if (value instanceof Error) {
            throwError(`property ${JSON.stringify(name)}`, value.error);
          }
          return value;
        }
        static fromItems(items, keys) {
          return new Result(_guard, items, keys);
        }
      }
      exports.Result = Result;
      function checkResultErrors(result) {
        const errors = [];
        const checkErrors = function (path, object) {
          if (!Array.isArray(object)) {
            return;
          }
          for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
              checkErrors(childPath, object[key]);
            } catch (error) {
              errors.push({
                path: childPath,
                error: error
              });
            }
          }
        };
        checkErrors([], result);
        return errors;
      }
      exports.checkResultErrors = checkResultErrors;
      function getValue(value) {
        let bytes = (0, index_js_1.toBeArray)(value);
        (0, index_js_1.assert)(bytes.length <= exports.WordSize, "value out-of-bounds", "BUFFER_OVERRUN", {
          buffer: bytes,
          length: exports.WordSize,
          offset: bytes.length
        });
        if (bytes.length !== exports.WordSize) {
          bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));
        }
        return bytes;
      }
      class Coder {
        name;
        type;
        localName;
        dynamic;
        constructor(name, type, localName, dynamic) {
          (0, index_js_1.defineProperties)(this, {
            name,
            type,
            localName,
            dynamic
          }, {
            name: "string",
            type: "string",
            localName: "string",
            dynamic: "boolean"
          });
        }
        _throwError(message, value) {
          (0, index_js_1.assertArgument)(false, message, this.localName, value);
        }
      }
      exports.Coder = Coder;
      class Writer {
        #data;
        #dataLength;
        constructor() {
          this.#data = [];
          this.#dataLength = 0;
        }
        get data() {
          return (0, index_js_1.concat)(this.#data);
        }
        get length() {
          return this.#dataLength;
        }
        #writeData(data) {
          this.#data.push(data);
          this.#dataLength += data.length;
          return data.length;
        }
        appendWriter(writer) {
          return this.#writeData((0, index_js_1.getBytesCopy)(writer.data));
        }
        writeBytes(value) {
          let bytes = (0, index_js_1.getBytesCopy)(value);
          const paddingOffset = bytes.length % exports.WordSize;
          if (paddingOffset) {
            bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));
          }
          return this.#writeData(bytes);
        }
        writeValue(value) {
          return this.#writeData(getValue(value));
        }
        writeUpdatableValue() {
          const offset = this.#data.length;
          this.#data.push(Padding);
          this.#dataLength += exports.WordSize;
          return value => {
            this.#data[offset] = getValue(value);
          };
        }
      }
      exports.Writer = Writer;
      class Reader {
        allowLoose;
        #data;
        #offset;
        constructor(data, allowLoose) {
          (0, index_js_1.defineProperties)(this, {
            allowLoose: !!allowLoose
          });
          this.#data = (0, index_js_1.getBytesCopy)(data);
          this.#offset = 0;
        }
        get data() {
          return (0, index_js_1.hexlify)(this.#data);
        }
        get dataLength() {
          return this.#data.length;
        }
        get consumed() {
          return this.#offset;
        }
        get bytes() {
          return new Uint8Array(this.#data);
        }
        #peekBytes(offset, length, loose) {
          let alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;
          if (this.#offset + alignedLength > this.#data.length) {
            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
              alignedLength = length;
            } else {
              (0, index_js_1.assert)(false, "data out-of-bounds", "BUFFER_OVERRUN", {
                buffer: (0, index_js_1.getBytesCopy)(this.#data),
                length: this.#data.length,
                offset: this.#offset + alignedLength
              });
            }
          }
          return this.#data.slice(this.#offset, this.#offset + alignedLength);
        }
        subReader(offset) {
          return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);
        }
        readBytes(length, loose) {
          let bytes = this.#peekBytes(0, length, !!loose);
          this.#offset += bytes.length;
          return bytes.slice(0, length);
        }
        readValue() {
          return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));
        }
        readIndex() {
          return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));
        }
      }
      exports.Reader = Reader;
    },
    5411: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AddressCoder = void 0;
      const index_js_1 = __webpack_require__(2134);
      const maths_js_1 = __webpack_require__(9018);
      const typed_js_1 = __webpack_require__(7673);
      const abstract_coder_js_1 = __webpack_require__(6094);
      class AddressCoder extends abstract_coder_js_1.Coder {
        constructor(localName) {
          super("address", "address", localName, false);
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000";
        }
        encode(writer, _value) {
          let value = typed_js_1.Typed.dereference(_value, "string");
          try {
            value = (0, index_js_1.getAddress)(value);
          } catch (error) {
            return this._throwError(error.message, _value);
          }
          return writer.writeValue(value);
        }
        decode(reader) {
          return (0, index_js_1.getAddress)((0, maths_js_1.toBeHex)(reader.readValue(), 20));
        }
      }
      exports.AddressCoder = AddressCoder;
    },
    5624: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AnonymousCoder = void 0;
      const abstract_coder_js_1 = __webpack_require__(6094);
      class AnonymousCoder extends abstract_coder_js_1.Coder {
        coder;
        constructor(coder) {
          super(coder.name, coder.type, "_", coder.dynamic);
          this.coder = coder;
        }
        defaultValue() {
          return this.coder.defaultValue();
        }
        encode(writer, value) {
          return this.coder.encode(writer, value);
        }
        decode(reader) {
          return this.coder.decode(reader);
        }
      }
      exports.AnonymousCoder = AnonymousCoder;
    },
    734: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArrayCoder = exports.unpack = exports.pack = void 0;
      const index_js_1 = __webpack_require__(9830);
      const typed_js_1 = __webpack_require__(7673);
      const abstract_coder_js_1 = __webpack_require__(6094);
      const anonymous_js_1 = __webpack_require__(5624);
      function pack(writer, coders, values) {
        let arrayValues = [];
        if (Array.isArray(values)) {
          arrayValues = values;
        } else if (values && typeof values === "object") {
          let unique = {};
          arrayValues = coders.map(coder => {
            const name = coder.localName;
            (0, index_js_1.assert)(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
              argument: "values",
              info: {
                coder
              },
              value: values
            });
            (0, index_js_1.assert)(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
              argument: "values",
              info: {
                coder
              },
              value: values
            });
            unique[name] = true;
            return values[name];
          });
        } else {
          (0, index_js_1.assertArgument)(false, "invalid tuple value", "tuple", values);
        }
        (0, index_js_1.assertArgument)(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
        let staticWriter = new abstract_coder_js_1.Writer();
        let dynamicWriter = new abstract_coder_js_1.Writer();
        let updateFuncs = [];
        coders.forEach((coder, index) => {
          let value = arrayValues[index];
          if (coder.dynamic) {
            let dynamicOffset = dynamicWriter.length;
            coder.encode(dynamicWriter, value);
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push(baseOffset => {
              updateFunc(baseOffset + dynamicOffset);
            });
          } else {
            coder.encode(staticWriter, value);
          }
        });
        updateFuncs.forEach(func => {
          func(staticWriter.length);
        });
        let length = writer.appendWriter(staticWriter);
        length += writer.appendWriter(dynamicWriter);
        return length;
      }
      exports.pack = pack;
      function unpack(reader, coders) {
        let values = [];
        let keys = [];
        let baseReader = reader.subReader(0);
        coders.forEach(coder => {
          let value = null;
          if (coder.dynamic) {
            let offset = reader.readIndex();
            let offsetReader = baseReader.subReader(offset);
            try {
              value = coder.decode(offsetReader);
            } catch (error) {
              if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
                throw error;
              }
              value = error;
              value.baseType = coder.name;
              value.name = coder.localName;
              value.type = coder.type;
            }
          } else {
            try {
              value = coder.decode(reader);
            } catch (error) {
              if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
                throw error;
              }
              value = error;
              value.baseType = coder.name;
              value.name = coder.localName;
              value.type = coder.type;
            }
          }
          if (value == undefined) {
            throw new Error("investigate");
          }
          values.push(value);
          keys.push(coder.localName || null);
        });
        return abstract_coder_js_1.Result.fromItems(values, keys);
      }
      exports.unpack = unpack;
      class ArrayCoder extends abstract_coder_js_1.Coder {
        coder;
        length;
        constructor(coder, length, localName) {
          const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
          const dynamic = length === -1 || coder.dynamic;
          super("array", type, localName, dynamic);
          (0, index_js_1.defineProperties)(this, {
            coder,
            length
          });
        }
        defaultValue() {
          const defaultChild = this.coder.defaultValue();
          const result = [];
          for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
          }
          return result;
        }
        encode(writer, _value) {
          const value = typed_js_1.Typed.dereference(_value, "array");
          if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
          }
          let count = this.length;
          if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
          }
          (0, index_js_1.assertArgumentCount)(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
          let coders = [];
          for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
          }
          return pack(writer, coders, value);
        }
        decode(reader) {
          let count = this.length;
          if (count === -1) {
            count = reader.readIndex();
            (0, index_js_1.assert)(count * abstract_coder_js_1.WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
              buffer: reader.bytes,
              offset: count * abstract_coder_js_1.WordSize,
              length: reader.dataLength
            });
          }
          let coders = [];
          for (let i = 0; i < count; i++) {
            coders.push(new anonymous_js_1.AnonymousCoder(this.coder));
          }
          return unpack(reader, coders);
        }
      }
      exports.ArrayCoder = ArrayCoder;
    },
    5192: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BooleanCoder = void 0;
      const typed_js_1 = __webpack_require__(7673);
      const abstract_coder_js_1 = __webpack_require__(6094);
      class BooleanCoder extends abstract_coder_js_1.Coder {
        constructor(localName) {
          super("bool", "bool", localName, false);
        }
        defaultValue() {
          return false;
        }
        encode(writer, _value) {
          const value = typed_js_1.Typed.dereference(_value, "bool");
          return writer.writeValue(value ? 1 : 0);
        }
        decode(reader) {
          return !!reader.readValue();
        }
      }
      exports.BooleanCoder = BooleanCoder;
    },
    8342: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BytesCoder = exports.DynamicBytesCoder = void 0;
      const index_js_1 = __webpack_require__(9830);
      const abstract_coder_js_1 = __webpack_require__(6094);
      class DynamicBytesCoder extends abstract_coder_js_1.Coder {
        constructor(type, localName) {
          super(type, type, localName, true);
        }
        defaultValue() {
          return "0x";
        }
        encode(writer, value) {
          value = (0, index_js_1.getBytesCopy)(value);
          let length = writer.writeValue(value.length);
          length += writer.writeBytes(value);
          return length;
        }
        decode(reader) {
          return reader.readBytes(reader.readIndex(), true);
        }
      }
      exports.DynamicBytesCoder = DynamicBytesCoder;
      class BytesCoder extends DynamicBytesCoder {
        constructor(localName) {
          super("bytes", localName);
        }
        decode(reader) {
          return (0, index_js_1.hexlify)(super.decode(reader));
        }
      }
      exports.BytesCoder = BytesCoder;
    },
    3151: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FixedBytesCoder = void 0;
      const index_js_1 = __webpack_require__(9830);
      const typed_js_1 = __webpack_require__(7673);
      const abstract_coder_js_1 = __webpack_require__(6094);
      class FixedBytesCoder extends abstract_coder_js_1.Coder {
        size;
        constructor(size, localName) {
          let name = "bytes" + String(size);
          super(name, name, localName, false);
          (0, index_js_1.defineProperties)(this, {
            size
          }, {
            size: "number"
          });
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
        }
        encode(writer, _value) {
          let data = (0, index_js_1.getBytesCopy)(typed_js_1.Typed.dereference(_value, this.type));
          if (data.length !== this.size) {
            this._throwError("incorrect data length", _value);
          }
          return writer.writeBytes(data);
        }
        decode(reader) {
          return (0, index_js_1.hexlify)(reader.readBytes(this.size));
        }
      }
      exports.FixedBytesCoder = FixedBytesCoder;
    },
    6255: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NullCoder = void 0;
      const abstract_coder_js_1 = __webpack_require__(6094);
      const Empty = new Uint8Array([]);
      class NullCoder extends abstract_coder_js_1.Coder {
        constructor(localName) {
          super("null", "", localName, false);
        }
        defaultValue() {
          return null;
        }
        encode(writer, value) {
          if (value != null) {
            this._throwError("not null", value);
          }
          return writer.writeBytes(Empty);
        }
        decode(reader) {
          reader.readBytes(0);
          return null;
        }
      }
      exports.NullCoder = NullCoder;
    },
    4482: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NumberCoder = void 0;
      const index_js_1 = __webpack_require__(9830);
      const typed_js_1 = __webpack_require__(7673);
      const abstract_coder_js_1 = __webpack_require__(6094);
      const BN_0 = BigInt(0);
      const BN_1 = BigInt(1);
      const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      class NumberCoder extends abstract_coder_js_1.Coder {
        size;
        signed;
        constructor(size, signed, localName) {
          const name = (signed ? "int" : "uint") + size * 8;
          super(name, name, localName, false);
          (0, index_js_1.defineProperties)(this, {
            size,
            signed
          }, {
            size: "number",
            signed: "boolean"
          });
        }
        defaultValue() {
          return 0;
        }
        encode(writer, _value) {
          let value = (0, index_js_1.getBigInt)(typed_js_1.Typed.dereference(_value, this.type));
          let maxUintValue = (0, index_js_1.mask)(BN_MAX_UINT256, abstract_coder_js_1.WordSize * 8);
          if (this.signed) {
            let bounds = (0, index_js_1.mask)(maxUintValue, this.size * 8 - 1);
            if (value > bounds || value < -(bounds + BN_1)) {
              this._throwError("value out-of-bounds", _value);
            }
            value = (0, index_js_1.toTwos)(value, 8 * abstract_coder_js_1.WordSize);
          } else if (value < BN_0 || value > (0, index_js_1.mask)(maxUintValue, this.size * 8)) {
            this._throwError("value out-of-bounds", _value);
          }
          return writer.writeValue(value);
        }
        decode(reader) {
          let value = (0, index_js_1.mask)(reader.readValue(), this.size * 8);
          if (this.signed) {
            value = (0, index_js_1.fromTwos)(value, this.size * 8);
          }
          return value;
        }
      }
      exports.NumberCoder = NumberCoder;
    },
    1193: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.StringCoder = void 0;
      const utf8_js_1 = __webpack_require__(8002);
      const typed_js_1 = __webpack_require__(7673);
      const bytes_js_1 = __webpack_require__(8342);
      class StringCoder extends bytes_js_1.DynamicBytesCoder {
        constructor(localName) {
          super("string", localName);
        }
        defaultValue() {
          return "";
        }
        encode(writer, _value) {
          return super.encode(writer, (0, utf8_js_1.toUtf8Bytes)(typed_js_1.Typed.dereference(_value, "string")));
        }
        decode(reader) {
          return (0, utf8_js_1.toUtf8String)(super.decode(reader));
        }
      }
      exports.StringCoder = StringCoder;
    },
    8198: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TupleCoder = void 0;
      const properties_js_1 = __webpack_require__(9795);
      const typed_js_1 = __webpack_require__(7673);
      const abstract_coder_js_1 = __webpack_require__(6094);
      const array_js_1 = __webpack_require__(734);
      class TupleCoder extends abstract_coder_js_1.Coder {
        coders;
        constructor(coders, localName) {
          let dynamic = false;
          const types = [];
          coders.forEach(coder => {
            if (coder.dynamic) {
              dynamic = true;
            }
            types.push(coder.type);
          });
          const type = "tuple(" + types.join(",") + ")";
          super("tuple", type, localName, dynamic);
          (0, properties_js_1.defineProperties)(this, {
            coders: Object.freeze(coders.slice())
          });
        }
        defaultValue() {
          const values = [];
          this.coders.forEach(coder => {
            values.push(coder.defaultValue());
          });
          const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
              if (!accum[name]) {
                accum[name] = 0;
              }
              accum[name]++;
            }
            return accum;
          }, {});
          this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
              return;
            }
            if (name === "length") {
              name = "_length";
            }
            if (values[name] != null) {
              return;
            }
            values[name] = values[index];
          });
          return Object.freeze(values);
        }
        encode(writer, _value) {
          const value = typed_js_1.Typed.dereference(_value, "tuple");
          return (0, array_js_1.pack)(writer, this.coders, value);
        }
        decode(reader) {
          return (0, array_js_1.unpack)(reader, this.coders);
        }
      }
      exports.TupleCoder = TupleCoder;
    },
    8569: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;
      const index_js_1 = __webpack_require__(9830);
      const index_js_2 = __webpack_require__(5714);
      ;
      function setify(items) {
        const result = new Set();
        items.forEach(k => result.add(k));
        return Object.freeze(result);
      }
      const _kwVisibDeploy = "external public payable";
      const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
      const _kwVisib = "constant external internal payable private public pure view";
      const KwVisib = setify(_kwVisib.split(" "));
      const _kwTypes = "constructor error event fallback function receive struct";
      const KwTypes = setify(_kwTypes.split(" "));
      const _kwModifiers = "calldata memory storage payable indexed";
      const KwModifiers = setify(_kwModifiers.split(" "));
      const _kwOther = "tuple returns";
      const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
      const Keywords = setify(_keywords.split(" "));
      const SimpleTokens = {
        "(": "OPEN_PAREN",
        ")": "CLOSE_PAREN",
        "[": "OPEN_BRACKET",
        "]": "CLOSE_BRACKET",
        ",": "COMMA",
        "@": "AT"
      };
      const regexWhitespacePrefix = new RegExp("^(\\s*)");
      const regexNumberPrefix = new RegExp("^([0-9]+)");
      const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
      const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
      const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
      class TokenString {
        #offset;
        #tokens;
        get offset() {
          return this.#offset;
        }
        get length() {
          return this.#tokens.length - this.#offset;
        }
        constructor(tokens) {
          this.#offset = 0;
          this.#tokens = tokens.slice();
        }
        clone() {
          return new TokenString(this.#tokens);
        }
        reset() {
          this.#offset = 0;
        }
        #subTokenString(from = 0, to = 0) {
          return new TokenString(this.#tokens.slice(from, to).map(t => {
            return Object.freeze(Object.assign({}, t, {
              match: t.match - from,
              linkBack: t.linkBack - from,
              linkNext: t.linkNext - from
            }));
          }));
        }
        popKeyword(allowed) {
          const top = this.peek();
          if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
            throw new Error(`expected keyword ${top.text}`);
          }
          return this.pop().text;
        }
        popType(type) {
          if (this.peek().type !== type) {
            throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);
          }
          return this.pop().text;
        }
        popParen() {
          const top = this.peek();
          if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
          }
          const result = this.#subTokenString(this.#offset + 1, top.match + 1);
          this.#offset = top.match + 1;
          return result;
        }
        popParams() {
          const top = this.peek();
          if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
          }
          const result = [];
          while (this.#offset < top.match - 1) {
            const link = this.peek().linkNext;
            result.push(this.#subTokenString(this.#offset + 1, link));
            this.#offset = link;
          }
          this.#offset = top.match + 1;
          return result;
        }
        peek() {
          if (this.#offset >= this.#tokens.length) {
            throw new Error("out-of-bounds");
          }
          return this.#tokens[this.#offset];
        }
        peekKeyword(allowed) {
          const top = this.peekType("KEYWORD");
          return top != null && allowed.has(top) ? top : null;
        }
        peekType(type) {
          if (this.length === 0) {
            return null;
          }
          const top = this.peek();
          return top.type === type ? top.text : null;
        }
        pop() {
          const result = this.peek();
          this.#offset++;
          return result;
        }
        toString() {
          const tokens = [];
          for (let i = this.#offset; i < this.#tokens.length; i++) {
            const token = this.#tokens[i];
            tokens.push(`${token.type}:${token.text}`);
          }
          return `<TokenString ${tokens.join(" ")}>`;
        }
      }
      function lex(text) {
        const tokens = [];
        const throwError = message => {
          const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
          throw new Error(`invalid token ${token} at ${offset}: ${message}`);
        };
        let brackets = [];
        let commas = [];
        let offset = 0;
        while (offset < text.length) {
          let cur = text.substring(offset);
          let match = cur.match(regexWhitespacePrefix);
          if (match) {
            offset += match[1].length;
            cur = text.substring(offset);
          }
          const token = {
            depth: brackets.length,
            linkBack: -1,
            linkNext: -1,
            match: -1,
            type: "",
            text: "",
            offset,
            value: -1
          };
          tokens.push(token);
          let type = SimpleTokens[cur[0]] || "";
          if (type) {
            token.type = type;
            token.text = cur[0];
            offset++;
            if (type === "OPEN_PAREN") {
              brackets.push(tokens.length - 1);
              commas.push(tokens.length - 1);
            } else if (type == "CLOSE_PAREN") {
              if (brackets.length === 0) {
                throwError("no matching open bracket");
              }
              token.match = brackets.pop();
              tokens[token.match].match = tokens.length - 1;
              token.depth--;
              token.linkBack = commas.pop();
              tokens[token.linkBack].linkNext = tokens.length - 1;
            } else if (type === "COMMA") {
              token.linkBack = commas.pop();
              tokens[token.linkBack].linkNext = tokens.length - 1;
              commas.push(tokens.length - 1);
            } else if (type === "OPEN_BRACKET") {
              token.type = "BRACKET";
            } else if (type === "CLOSE_BRACKET") {
              let suffix = tokens.pop().text;
              if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
                const value = tokens.pop().text;
                suffix = value + suffix;
                tokens[tokens.length - 1].value = (0, index_js_1.getNumber)(value);
              }
              if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
                throw new Error("missing opening bracket");
              }
              tokens[tokens.length - 1].text += suffix;
            }
            continue;
          }
          match = cur.match(regexIdPrefix);
          if (match) {
            token.text = match[1];
            offset += token.text.length;
            if (Keywords.has(token.text)) {
              token.type = "KEYWORD";
              continue;
            }
            if (token.text.match(regexType)) {
              token.type = "TYPE";
              continue;
            }
            token.type = "ID";
            continue;
          }
          match = cur.match(regexNumberPrefix);
          if (match) {
            token.text = match[1];
            token.type = "NUMBER";
            offset += token.text.length;
            continue;
          }
          throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
        }
        return new TokenString(tokens.map(t => Object.freeze(t)));
      }
      function allowSingle(set, allowed) {
        let included = [];
        for (const key in allowed.keys()) {
          if (set.has(key)) {
            included.push(key);
          }
        }
        if (included.length > 1) {
          throw new Error(`conflicting types: ${included.join(", ")}`);
        }
      }
      function consumeName(type, tokens) {
        if (tokens.peekKeyword(KwTypes)) {
          const keyword = tokens.pop().text;
          if (keyword !== type) {
            throw new Error(`expected ${type}, got ${keyword}`);
          }
        }
        return tokens.popType("ID");
      }
      function consumeKeywords(tokens, allowed) {
        const keywords = new Set();
        while (true) {
          const keyword = tokens.peekType("KEYWORD");
          if (keyword == null || allowed && !allowed.has(keyword)) {
            break;
          }
          tokens.pop();
          if (keywords.has(keyword)) {
            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
          }
          keywords.add(keyword);
        }
        return Object.freeze(keywords);
      }
      function consumeMutability(tokens) {
        let modifiers = consumeKeywords(tokens, KwVisib);
        allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
        allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
        if (modifiers.has("view")) {
          return "view";
        }
        if (modifiers.has("pure")) {
          return "pure";
        }
        if (modifiers.has("payable")) {
          return "payable";
        }
        if (modifiers.has("nonpayable")) {
          return "nonpayable";
        }
        if (modifiers.has("constant")) {
          return "view";
        }
        return "nonpayable";
      }
      function consumeParams(tokens, allowIndexed) {
        return tokens.popParams().map(t => ParamType.from(t, allowIndexed));
      }
      function consumeGas(tokens) {
        if (tokens.peekType("AT")) {
          tokens.pop();
          if (tokens.peekType("NUMBER")) {
            return (0, index_js_1.getBigInt)(tokens.pop().text);
          }
          throw new Error("invalid gas");
        }
        return null;
      }
      function consumeEoi(tokens) {
        if (tokens.length) {
          throw new Error(`unexpected tokens: ${tokens.toString()}`);
        }
      }
      const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
      function verifyBasicType(type) {
        const match = type.match(regexType);
        (0, index_js_1.assertArgument)(match, "invalid type", "type", type);
        if (type === "uint") {
          return "uint256";
        }
        if (type === "int") {
          return "int256";
        }
        if (match[2]) {
          const length = parseInt(match[2]);
          (0, index_js_1.assertArgument)(length !== 0 && length <= 32, "invalid bytes length", "type", type);
        } else if (match[3]) {
          const size = parseInt(match[3]);
          (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
        }
        return type;
      }
      const _guard = {};
      const internal = Symbol.for("_ethers_internal");
      const ParamTypeInternal = "_ParamTypeInternal";
      const ErrorFragmentInternal = "_ErrorInternal";
      const EventFragmentInternal = "_EventInternal";
      const ConstructorFragmentInternal = "_ConstructorInternal";
      const FallbackFragmentInternal = "_FallbackInternal";
      const FunctionFragmentInternal = "_FunctionInternal";
      const StructFragmentInternal = "_StructInternal";
      class ParamType {
        name;
        type;
        baseType;
        indexed;
        components;
        arrayLength;
        arrayChildren;
        constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
          (0, index_js_1.assertPrivate)(guard, _guard, "ParamType");
          Object.defineProperty(this, internal, {
            value: ParamTypeInternal
          });
          if (components) {
            components = Object.freeze(components.slice());
          }
          if (baseType === "array") {
            if (arrayLength == null || arrayChildren == null) {
              throw new Error("");
            }
          } else if (arrayLength != null || arrayChildren != null) {
            throw new Error("");
          }
          if (baseType === "tuple") {
            if (components == null) {
              throw new Error("");
            }
          } else if (components != null) {
            throw new Error("");
          }
          (0, index_js_1.defineProperties)(this, {
            name,
            type,
            baseType,
            indexed,
            components,
            arrayLength,
            arrayChildren
          });
        }
        format(format) {
          if (format == null) {
            format = "sighash";
          }
          if (format === "json") {
            const name = this.name || "";
            if (this.isArray()) {
              const result = JSON.parse(this.arrayChildren.format("json"));
              result.name = name;
              result.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
              return JSON.stringify(result);
            }
            const result = {
              type: this.baseType === "tuple" ? "tuple" : this.type,
              name
            };
            if (typeof this.indexed === "boolean") {
              result.indexed = this.indexed;
            }
            if (this.isTuple()) {
              result.components = this.components.map(c => JSON.parse(c.format(format)));
            }
            return JSON.stringify(result);
          }
          let result = "";
          if (this.isArray()) {
            result += this.arrayChildren.format(format);
            result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
          } else {
            if (this.isTuple()) {
              if (format !== "sighash") {
                result += this.type;
              }
              result += "(" + this.components.map(comp => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
            } else {
              result += this.type;
            }
          }
          if (format !== "sighash") {
            if (this.indexed === true) {
              result += " indexed";
            }
            if (format === "full" && this.name) {
              result += " " + this.name;
            }
          }
          return result;
        }
        isArray() {
          return this.baseType === "array";
        }
        isTuple() {
          return this.baseType === "tuple";
        }
        isIndexable() {
          return this.indexed != null;
        }
        walk(value, process) {
          if (this.isArray()) {
            if (!Array.isArray(value)) {
              throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
              throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map(v => _this.arrayChildren.walk(v, process));
          }
          if (this.isTuple()) {
            if (!Array.isArray(value)) {
              throw new Error("invalid tuple value");
            }
            if (value.length !== this.components.length) {
              throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v, i) => _this.components[i].walk(v, process));
          }
          return process(this.type, value);
        }
        #walkAsync(promises, value, process, setValue) {
          if (this.isArray()) {
            if (!Array.isArray(value)) {
              throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
              throw new Error("array is wrong length");
            }
            const childType = this.arrayChildren;
            const result = value.slice();
            result.forEach((value, index) => {
              childType.#walkAsync(promises, value, process, value => {
                result[index] = value;
              });
            });
            setValue(result);
            return;
          }
          if (this.isTuple()) {
            const components = this.components;
            let result;
            if (Array.isArray(value)) {
              result = value.slice();
            } else {
              if (value == null || typeof value !== "object") {
                throw new Error("invalid tuple value");
              }
              result = components.map(param => {
                if (!param.name) {
                  throw new Error("cannot use object value with unnamed components");
                }
                if (!(param.name in value)) {
                  throw new Error(`missing value for component ${param.name}`);
                }
                return value[param.name];
              });
            }
            if (result.length !== this.components.length) {
              throw new Error("array is wrong length");
            }
            result.forEach((value, index) => {
              components[index].#walkAsync(promises, value, process, value => {
                result[index] = value;
              });
            });
            setValue(result);
            return;
          }
          const result = process(this.type, value);
          if (result.then) {
            promises.push(async function () {
              setValue(await result);
            }());
          } else {
            setValue(result);
          }
        }
        async walkAsync(value, process) {
          const promises = [];
          const result = [value];
          this.#walkAsync(promises, value, process, value => {
            result[0] = value;
          });
          if (promises.length) {
            await Promise.all(promises);
          }
          return result[0];
        }
        static from(obj, allowIndexed) {
          if (ParamType.isParamType(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return ParamType.from(lex(obj), allowIndexed);
            } catch (error) {
              (0, index_js_1.assertArgument)(false, "invalid param type", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            let type = "",
              baseType = "";
            let comps = null;
            if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
              baseType = "tuple";
              comps = obj.popParams().map(t => ParamType.from(t));
              type = `tuple(${comps.map(c => c.format()).join(",")})`;
            } else {
              type = verifyBasicType(obj.popType("TYPE"));
              baseType = type;
            }
            let arrayChildren = null;
            let arrayLength = null;
            while (obj.length && obj.peekType("BRACKET")) {
              const bracket = obj.pop();
              arrayChildren = new ParamType(_guard, "", type, baseType, null, comps, arrayLength, arrayChildren);
              arrayLength = bracket.value;
              type += bracket.text;
              baseType = "array";
              comps = null;
            }
            let indexed = null;
            const keywords = consumeKeywords(obj, KwModifiers);
            if (keywords.has("indexed")) {
              if (!allowIndexed) {
                throw new Error("");
              }
              indexed = true;
            }
            const name = obj.peekType("ID") ? obj.pop().text : "";
            if (obj.length) {
              throw new Error("leftover tokens");
            }
            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);
          }
          const name = obj.name;
          (0, index_js_1.assertArgument)(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
          let indexed = obj.indexed;
          if (indexed != null) {
            (0, index_js_1.assertArgument)(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
            indexed = !!indexed;
          }
          let type = obj.type;
          let arrayMatch = type.match(regexArrayType);
          if (arrayMatch) {
            const arrayLength = parseInt(arrayMatch[2] || "-1");
            const arrayChildren = ParamType.from({
              type: arrayMatch[1],
              components: obj.components
            });
            return new ParamType(_guard, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
          }
          if (type === "tuple" || type.startsWith("tuple(") || type.startsWith("(")) {
            const comps = obj.components != null ? obj.components.map(c => ParamType.from(c)) : null;
            const tuple = new ParamType(_guard, name || "", type, "tuple", indexed, comps, null, null);
            return tuple;
          }
          type = verifyBasicType(obj.type);
          return new ParamType(_guard, name || "", type, type, indexed, null, null, null);
        }
        static isParamType(value) {
          return value && value[internal] === ParamTypeInternal;
        }
      }
      exports.ParamType = ParamType;
      class Fragment {
        type;
        inputs;
        constructor(guard, type, inputs) {
          (0, index_js_1.assertPrivate)(guard, _guard, "Fragment");
          inputs = Object.freeze(inputs.slice());
          (0, index_js_1.defineProperties)(this, {
            type,
            inputs
          });
        }
        static from(obj) {
          if (typeof obj === "string") {
            try {
              Fragment.from(JSON.parse(obj));
            } catch (e) {}
            return Fragment.from(lex(obj));
          }
          if (obj instanceof TokenString) {
            const type = obj.peekKeyword(KwTypes);
            switch (type) {
              case "constructor":
                return ConstructorFragment.from(obj);
              case "error":
                return ErrorFragment.from(obj);
              case "event":
                return EventFragment.from(obj);
              case "fallback":
              case "receive":
                return FallbackFragment.from(obj);
              case "function":
                return FunctionFragment.from(obj);
              case "struct":
                return StructFragment.from(obj);
            }
          } else if (typeof obj === "object") {
            switch (obj.type) {
              case "constructor":
                return ConstructorFragment.from(obj);
              case "error":
                return ErrorFragment.from(obj);
              case "event":
                return EventFragment.from(obj);
              case "fallback":
              case "receive":
                return FallbackFragment.from(obj);
              case "function":
                return FunctionFragment.from(obj);
              case "struct":
                return StructFragment.from(obj);
            }
            (0, index_js_1.assert)(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
              operation: "Fragment.from"
            });
          }
          (0, index_js_1.assertArgument)(false, "unsupported frgament object", "obj", obj);
        }
        static isConstructor(value) {
          return ConstructorFragment.isFragment(value);
        }
        static isError(value) {
          return ErrorFragment.isFragment(value);
        }
        static isEvent(value) {
          return EventFragment.isFragment(value);
        }
        static isFunction(value) {
          return FunctionFragment.isFragment(value);
        }
        static isStruct(value) {
          return StructFragment.isFragment(value);
        }
      }
      exports.Fragment = Fragment;
      class NamedFragment extends Fragment {
        name;
        constructor(guard, type, name, inputs) {
          super(guard, type, inputs);
          (0, index_js_1.assertArgument)(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
          inputs = Object.freeze(inputs.slice());
          (0, index_js_1.defineProperties)(this, {
            name
          });
        }
      }
      exports.NamedFragment = NamedFragment;
      function joinParams(format, params) {
        return "(" + params.map(p => p.format(format)).join(format === "full" ? ", " : ",") + ")";
      }
      class ErrorFragment extends NamedFragment {
        constructor(guard, name, inputs) {
          super(guard, "error", name, inputs);
          Object.defineProperty(this, internal, {
            value: ErrorFragmentInternal
          });
        }
        get selector() {
          return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
        }
        format(format) {
          if (format == null) {
            format = "sighash";
          }
          if (format === "json") {
            return JSON.stringify({
              type: "error",
              name: this.name,
              inputs: this.inputs.map(input => JSON.parse(input.format(format)))
            });
          }
          const result = [];
          if (format !== "sighash") {
            result.push("error");
          }
          result.push(this.name + joinParams(format, this.inputs));
          return result.join(" ");
        }
        static from(obj) {
          if (ErrorFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            return ErrorFragment.from(lex(obj));
          } else if (obj instanceof TokenString) {
            const name = consumeName("error", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new ErrorFragment(_guard, name, inputs);
          }
          return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
        }
        static isFragment(value) {
          return value && value[internal] === ErrorFragmentInternal;
        }
      }
      exports.ErrorFragment = ErrorFragment;
      class EventFragment extends NamedFragment {
        anonymous;
        constructor(guard, name, inputs, anonymous) {
          super(guard, "event", name, inputs);
          Object.defineProperty(this, internal, {
            value: EventFragmentInternal
          });
          (0, index_js_1.defineProperties)(this, {
            anonymous
          });
        }
        get topicHash() {
          return (0, index_js_2.id)(this.format("sighash"));
        }
        format(format) {
          if (format == null) {
            format = "sighash";
          }
          if (format === "json") {
            return JSON.stringify({
              type: "event",
              anonymous: this.anonymous,
              name: this.name,
              inputs: this.inputs.map(i => JSON.parse(i.format(format)))
            });
          }
          const result = [];
          if (format !== "sighash") {
            result.push("event");
          }
          result.push(this.name + joinParams(format, this.inputs));
          if (format !== "sighash" && this.anonymous) {
            result.push("anonymous");
          }
          return result.join(" ");
        }
        static getTopicHash(name, params) {
          params = (params || []).map(p => ParamType.from(p));
          const fragment = new EventFragment(_guard, name, params, false);
          return fragment.topicHash;
        }
        static from(obj) {
          if (EventFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return EventFragment.from(lex(obj));
            } catch (error) {
              (0, index_js_1.assertArgument)(false, "invalid event fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            const name = consumeName("event", obj);
            const inputs = consumeParams(obj, true);
            const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
            consumeEoi(obj);
            return new EventFragment(_guard, name, inputs, anonymous);
          }
          return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(p => ParamType.from(p, true)) : [], !!obj.anonymous);
        }
        static isFragment(value) {
          return value && value[internal] === EventFragmentInternal;
        }
      }
      exports.EventFragment = EventFragment;
      class ConstructorFragment extends Fragment {
        payable;
        gas;
        constructor(guard, type, inputs, payable, gas) {
          super(guard, type, inputs);
          Object.defineProperty(this, internal, {
            value: ConstructorFragmentInternal
          });
          (0, index_js_1.defineProperties)(this, {
            payable,
            gas
          });
        }
        format(format) {
          (0, index_js_1.assert)(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
            operation: "format(sighash)"
          });
          if (format === "json") {
            return JSON.stringify({
              type: "constructor",
              stateMutability: this.payable ? "payable" : "undefined",
              payable: this.payable,
              gas: this.gas != null ? this.gas : undefined,
              inputs: this.inputs.map(i => JSON.parse(i.format(format)))
            });
          }
          const result = [`constructor${joinParams(format, this.inputs)}`];
          result.push(this.payable ? "payable" : "nonpayable");
          if (this.gas != null) {
            result.push(`@${this.gas.toString()}`);
          }
          return result.join(" ");
        }
        static from(obj) {
          if (ConstructorFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return ConstructorFragment.from(lex(obj));
            } catch (error) {
              (0, index_js_1.assertArgument)(false, "invalid constuctor fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            consumeKeywords(obj, setify(["constructor"]));
            const inputs = consumeParams(obj);
            const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
          }
          return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
        }
        static isFragment(value) {
          return value && value[internal] === ConstructorFragmentInternal;
        }
      }
      exports.ConstructorFragment = ConstructorFragment;
      class FallbackFragment extends Fragment {
        payable;
        constructor(guard, inputs, payable) {
          super(guard, "fallback", inputs);
          Object.defineProperty(this, internal, {
            value: FallbackFragmentInternal
          });
          (0, index_js_1.defineProperties)(this, {
            payable
          });
        }
        format(format) {
          const type = this.inputs.length === 0 ? "receive" : "fallback";
          if (format === "json") {
            const stateMutability = this.payable ? "payable" : "nonpayable";
            return JSON.stringify({
              type,
              stateMutability
            });
          }
          return `${type}()${this.payable ? " payable" : ""}`;
        }
        static from(obj) {
          if (FallbackFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return FallbackFragment.from(lex(obj));
            } catch (error) {
              (0, index_js_1.assertArgument)(false, "invalid fallback fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            const errorObj = obj.toString();
            const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
            (0, index_js_1.assertArgument)(topIsValid, "type must be fallback or receive", "obj", errorObj);
            const type = obj.popKeyword(setify(["fallback", "receive"]));
            if (type === "receive") {
              const inputs = consumeParams(obj);
              (0, index_js_1.assertArgument)(inputs.length === 0, `receive cannot have arguments`, "obj.inputs", inputs);
              consumeKeywords(obj, setify(["payable"]));
              consumeEoi(obj);
              return new FallbackFragment(_guard, [], true);
            }
            let inputs = consumeParams(obj);
            if (inputs.length) {
              (0, index_js_1.assertArgument)(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map(i => i.format("minimal")).join(", "));
            } else {
              inputs = [ParamType.from("bytes")];
            }
            const mutability = consumeMutability(obj);
            (0, index_js_1.assertArgument)(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
              const outputs = consumeParams(obj);
              (0, index_js_1.assertArgument)(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map(i => i.format("minimal")).join(", "));
            }
            consumeEoi(obj);
            return new FallbackFragment(_guard, inputs, mutability === "payable");
          }
          if (obj.type === "receive") {
            return new FallbackFragment(_guard, [], true);
          }
          if (obj.type === "fallback") {
            const inputs = [ParamType.from("bytes")];
            const payable = obj.stateMutability === "payable";
            return new FallbackFragment(_guard, inputs, payable);
          }
          (0, index_js_1.assertArgument)(false, "invalid fallback description", "obj", obj);
        }
        static isFragment(value) {
          return value && value[internal] === FallbackFragmentInternal;
        }
      }
      exports.FallbackFragment = FallbackFragment;
      class FunctionFragment extends NamedFragment {
        constant;
        outputs;
        stateMutability;
        payable;
        gas;
        constructor(guard, name, stateMutability, inputs, outputs, gas) {
          super(guard, "function", name, inputs);
          Object.defineProperty(this, internal, {
            value: FunctionFragmentInternal
          });
          outputs = Object.freeze(outputs.slice());
          const constant = stateMutability === "view" || stateMutability === "pure";
          const payable = stateMutability === "payable";
          (0, index_js_1.defineProperties)(this, {
            constant,
            gas,
            outputs,
            payable,
            stateMutability
          });
        }
        get selector() {
          return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
        }
        format(format) {
          if (format == null) {
            format = "sighash";
          }
          if (format === "json") {
            return JSON.stringify({
              type: "function",
              name: this.name,
              constant: this.constant,
              stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
              payable: this.payable,
              gas: this.gas != null ? this.gas : undefined,
              inputs: this.inputs.map(i => JSON.parse(i.format(format))),
              outputs: this.outputs.map(o => JSON.parse(o.format(format)))
            });
          }
          const result = [];
          if (format !== "sighash") {
            result.push("function");
          }
          result.push(this.name + joinParams(format, this.inputs));
          if (format !== "sighash") {
            if (this.stateMutability !== "nonpayable") {
              result.push(this.stateMutability);
            }
            if (this.outputs && this.outputs.length) {
              result.push("returns");
              result.push(joinParams(format, this.outputs));
            }
            if (this.gas != null) {
              result.push(`@${this.gas.toString()}`);
            }
          }
          return result.join(" ");
        }
        static getSelector(name, params) {
          params = (params || []).map(p => ParamType.from(p));
          const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
          return fragment.selector;
        }
        static from(obj) {
          if (FunctionFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return FunctionFragment.from(lex(obj));
            } catch (error) {
              (0, index_js_1.assertArgument)(false, "invalid function fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            const name = consumeName("function", obj);
            const inputs = consumeParams(obj);
            const mutability = consumeMutability(obj);
            let outputs = [];
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
              outputs = consumeParams(obj);
            }
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
          }
          let stateMutability = obj.stateMutability;
          if (stateMutability == null) {
            stateMutability = "payable";
            if (typeof obj.constant === "boolean") {
              stateMutability = "view";
              if (!obj.constant) {
                stateMutability = "payable";
                if (typeof obj.payable === "boolean" && !obj.payable) {
                  stateMutability = "nonpayable";
                }
              }
            } else if (typeof obj.payable === "boolean" && !obj.payable) {
              stateMutability = "nonpayable";
            }
          }
          return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
        }
        static isFragment(value) {
          return value && value[internal] === FunctionFragmentInternal;
        }
      }
      exports.FunctionFragment = FunctionFragment;
      class StructFragment extends NamedFragment {
        constructor(guard, name, inputs) {
          super(guard, "struct", name, inputs);
          Object.defineProperty(this, internal, {
            value: StructFragmentInternal
          });
        }
        format() {
          throw new Error("@TODO");
        }
        static from(obj) {
          if (typeof obj === "string") {
            try {
              return StructFragment.from(lex(obj));
            } catch (error) {
              (0, index_js_1.assertArgument)(false, "invalid struct fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            const name = consumeName("struct", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new StructFragment(_guard, name, inputs);
          }
          return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
        }
        static isFragment(value) {
          return value && value[internal] === StructFragmentInternal;
        }
      }
      exports.StructFragment = StructFragment;
    },
    5262: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Typed = exports.Result = exports.TransactionDescription = exports.LogDescription = exports.ErrorDescription = exports.Interface = exports.Indexed = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.Fragment = exports.FallbackFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.encodeBytes32String = exports.decodeBytes32String = exports.AbiCoder = void 0;
      var abi_coder_js_1 = __webpack_require__(3126);
      Object.defineProperty(exports, "AbiCoder", {
        enumerable: true,
        get: function () {
          return abi_coder_js_1.AbiCoder;
        }
      });
      var bytes32_js_1 = __webpack_require__(5670);
      Object.defineProperty(exports, "decodeBytes32String", {
        enumerable: true,
        get: function () {
          return bytes32_js_1.decodeBytes32String;
        }
      });
      Object.defineProperty(exports, "encodeBytes32String", {
        enumerable: true,
        get: function () {
          return bytes32_js_1.encodeBytes32String;
        }
      });
      var fragments_js_1 = __webpack_require__(8569);
      Object.defineProperty(exports, "ConstructorFragment", {
        enumerable: true,
        get: function () {
          return fragments_js_1.ConstructorFragment;
        }
      });
      Object.defineProperty(exports, "ErrorFragment", {
        enumerable: true,
        get: function () {
          return fragments_js_1.ErrorFragment;
        }
      });
      Object.defineProperty(exports, "EventFragment", {
        enumerable: true,
        get: function () {
          return fragments_js_1.EventFragment;
        }
      });
      Object.defineProperty(exports, "FallbackFragment", {
        enumerable: true,
        get: function () {
          return fragments_js_1.FallbackFragment;
        }
      });
      Object.defineProperty(exports, "Fragment", {
        enumerable: true,
        get: function () {
          return fragments_js_1.Fragment;
        }
      });
      Object.defineProperty(exports, "FunctionFragment", {
        enumerable: true,
        get: function () {
          return fragments_js_1.FunctionFragment;
        }
      });
      Object.defineProperty(exports, "NamedFragment", {
        enumerable: true,
        get: function () {
          return fragments_js_1.NamedFragment;
        }
      });
      Object.defineProperty(exports, "ParamType", {
        enumerable: true,
        get: function () {
          return fragments_js_1.ParamType;
        }
      });
      Object.defineProperty(exports, "StructFragment", {
        enumerable: true,
        get: function () {
          return fragments_js_1.StructFragment;
        }
      });
      var interface_js_1 = __webpack_require__(5318);
      Object.defineProperty(exports, "checkResultErrors", {
        enumerable: true,
        get: function () {
          return interface_js_1.checkResultErrors;
        }
      });
      Object.defineProperty(exports, "Indexed", {
        enumerable: true,
        get: function () {
          return interface_js_1.Indexed;
        }
      });
      Object.defineProperty(exports, "Interface", {
        enumerable: true,
        get: function () {
          return interface_js_1.Interface;
        }
      });
      Object.defineProperty(exports, "ErrorDescription", {
        enumerable: true,
        get: function () {
          return interface_js_1.ErrorDescription;
        }
      });
      Object.defineProperty(exports, "LogDescription", {
        enumerable: true,
        get: function () {
          return interface_js_1.LogDescription;
        }
      });
      Object.defineProperty(exports, "TransactionDescription", {
        enumerable: true,
        get: function () {
          return interface_js_1.TransactionDescription;
        }
      });
      Object.defineProperty(exports, "Result", {
        enumerable: true,
        get: function () {
          return interface_js_1.Result;
        }
      });
      var typed_js_1 = __webpack_require__(7673);
      Object.defineProperty(exports, "Typed", {
        enumerable: true,
        get: function () {
          return typed_js_1.Typed;
        }
      });
    },
    5318: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.Result = exports.checkResultErrors = void 0;
      const index_js_1 = __webpack_require__(9420);
      const index_js_2 = __webpack_require__(5714);
      const index_js_3 = __webpack_require__(9830);
      const abi_coder_js_1 = __webpack_require__(3126);
      const abstract_coder_js_1 = __webpack_require__(6094);
      Object.defineProperty(exports, "checkResultErrors", {
        enumerable: true,
        get: function () {
          return abstract_coder_js_1.checkResultErrors;
        }
      });
      Object.defineProperty(exports, "Result", {
        enumerable: true,
        get: function () {
          return abstract_coder_js_1.Result;
        }
      });
      const fragments_js_1 = __webpack_require__(8569);
      const typed_js_1 = __webpack_require__(7673);
      class LogDescription {
        fragment;
        name;
        signature;
        topic;
        args;
        constructor(fragment, topic, args) {
          const name = fragment.name,
            signature = fragment.format();
          (0, index_js_3.defineProperties)(this, {
            fragment,
            name,
            signature,
            topic,
            args
          });
        }
      }
      exports.LogDescription = LogDescription;
      class TransactionDescription {
        fragment;
        name;
        args;
        signature;
        selector;
        value;
        constructor(fragment, selector, args, value) {
          const name = fragment.name,
            signature = fragment.format();
          (0, index_js_3.defineProperties)(this, {
            fragment,
            name,
            args,
            signature,
            selector,
            value
          });
        }
      }
      exports.TransactionDescription = TransactionDescription;
      class ErrorDescription {
        fragment;
        name;
        args;
        signature;
        selector;
        constructor(fragment, selector, args) {
          const name = fragment.name,
            signature = fragment.format();
          (0, index_js_3.defineProperties)(this, {
            fragment,
            name,
            args,
            signature,
            selector
          });
        }
      }
      exports.ErrorDescription = ErrorDescription;
      class Indexed {
        hash;
        _isIndexed;
        static isIndexed(value) {
          return !!(value && value._isIndexed);
        }
        constructor(hash) {
          (0, index_js_3.defineProperties)(this, {
            hash,
            _isIndexed: true
          });
        }
      }
      exports.Indexed = Indexed;
      const PanicReasons = {
        "0": "generic panic",
        "1": "assert(false)",
        "17": "arithmetic overflow",
        "18": "division or modulo by zero",
        "33": "enum overflow",
        "34": "invalid encoded storage byte array accessed",
        "49": "out-of-bounds array access; popping on an empty array",
        "50": "out-of-bounds access of an array or bytesN",
        "65": "out of memory",
        "81": "uninitialized function"
      };
      const BuiltinErrors = {
        "0x08c379a0": {
          signature: "Error(string)",
          name: "Error",
          inputs: ["string"],
          reason: message => {
            return `reverted with reason string ${JSON.stringify(message)}`;
          }
        },
        "0x4e487b71": {
          signature: "Panic(uint256)",
          name: "Panic",
          inputs: ["uint256"],
          reason: code => {
            let reason = "unknown panic code";
            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {
              reason = PanicReasons[code.toString()];
            }
            return `reverted with panic code 0x${code.toString(16)} (${reason})`;
          }
        }
      };
      class Interface {
        fragments;
        deploy;
        fallback;
        receive;
        #errors;
        #events;
        #functions;
        #abiCoder;
        constructor(fragments) {
          let abi = [];
          if (typeof fragments === "string") {
            abi = JSON.parse(fragments);
          } else {
            abi = fragments;
          }
          this.#functions = new Map();
          this.#errors = new Map();
          this.#events = new Map();
          const frags = [];
          for (const a of abi) {
            try {
              frags.push(fragments_js_1.Fragment.from(a));
            } catch (error) {
              console.log("EE", error);
            }
          }
          (0, index_js_3.defineProperties)(this, {
            fragments: Object.freeze(frags)
          });
          let fallback = null;
          let receive = false;
          this.#abiCoder = this.getAbiCoder();
          this.fragments.forEach((fragment, index) => {
            let bucket;
            switch (fragment.type) {
              case "constructor":
                if (this.deploy) {
                  console.log("duplicate definition - constructor");
                  return;
                }
                (0, index_js_3.defineProperties)(this, {
                  deploy: fragment
                });
                return;
              case "fallback":
                if (fragment.inputs.length === 0) {
                  receive = true;
                } else {
                  (0, index_js_3.assertArgument)(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
                  fallback = fragment;
                  receive = fallback.payable;
                }
                return;
              case "function":
                bucket = this.#functions;
                break;
              case "event":
                bucket = this.#events;
                break;
              case "error":
                bucket = this.#errors;
                break;
              default:
                return;
            }
            const signature = fragment.format();
            if (bucket.has(signature)) {
              return;
            }
            bucket.set(signature, fragment);
          });
          if (!this.deploy) {
            (0, index_js_3.defineProperties)(this, {
              deploy: fragments_js_1.ConstructorFragment.from("constructor()")
            });
          }
          (0, index_js_3.defineProperties)(this, {
            fallback,
            receive
          });
        }
        format(minimal) {
          const format = minimal ? "minimal" : "full";
          const abi = this.fragments.map(f => f.format(format));
          return abi;
        }
        formatJson() {
          const abi = this.fragments.map(f => f.format("json"));
          return JSON.stringify(abi.map(j => JSON.parse(j)));
        }
        getAbiCoder() {
          return abi_coder_js_1.AbiCoder.defaultAbiCoder();
        }
        #getFunction(key, values, forceUnique) {
          if ((0, index_js_3.isHexString)(key)) {
            const selector = key.toLowerCase();
            for (const fragment of this.#functions.values()) {
              if (selector === fragment.selector) {
                return fragment;
              }
            }
            return null;
          }
          if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#functions) {
              if (name.split("(")[0] === key) {
                matching.push(fragment);
              }
            }
            if (values) {
              const lastValue = values.length > 0 ? values[values.length - 1] : null;
              let valueLength = values.length;
              let allowOptions = true;
              if (typed_js_1.Typed.isTyped(lastValue) && lastValue.type === "overrides") {
                allowOptions = false;
                valueLength--;
              }
              for (let i = matching.length - 1; i >= 0; i--) {
                const inputs = matching[i].inputs.length;
                if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
                  matching.splice(i, 1);
                }
              }
              for (let i = matching.length - 1; i >= 0; i--) {
                const inputs = matching[i].inputs;
                for (let j = 0; j < values.length; j++) {
                  if (!typed_js_1.Typed.isTyped(values[j])) {
                    continue;
                  }
                  if (j >= inputs.length) {
                    if (values[j].type === "overrides") {
                      continue;
                    }
                    matching.splice(i, 1);
                    break;
                  }
                  if (values[j].type !== inputs[j].baseType) {
                    matching.splice(i, 1);
                    break;
                  }
                }
              }
            }
            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
              const lastArg = values[values.length - 1];
              if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
                matching.splice(0, 1);
              }
            }
            if (matching.length === 0) {
              return null;
            }
            if (matching.length > 1 && forceUnique) {
              const matchStr = matching.map(m => JSON.stringify(m.format())).join(", ");
              (0, index_js_3.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
            }
            return matching[0];
          }
          const result = this.#functions.get(fragments_js_1.FunctionFragment.from(key).format());
          if (result) {
            return result;
          }
          return null;
        }
        getFunctionName(key) {
          const fragment = this.#getFunction(key, null, false);
          (0, index_js_3.assertArgument)(fragment, "no matching function", "key", key);
          return fragment.name;
        }
        hasFunction(key) {
          return !!this.#getFunction(key, null, false);
        }
        getFunction(key, values) {
          return this.#getFunction(key, values || null, true);
        }
        forEachFunction(callback) {
          const names = Array.from(this.#functions.keys());
          names.sort((a, b) => a.localeCompare(b));
          for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback(this.#functions.get(name), i);
          }
        }
        #getEvent(key, values, forceUnique) {
          if ((0, index_js_3.isHexString)(key)) {
            const eventTopic = key.toLowerCase();
            for (const fragment of this.#events.values()) {
              if (eventTopic === fragment.topicHash) {
                return fragment;
              }
            }
            return null;
          }
          if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#events) {
              if (name.split("(")[0] === key) {
                matching.push(fragment);
              }
            }
            if (values) {
              for (let i = matching.length - 1; i >= 0; i--) {
                if (matching[i].inputs.length < values.length) {
                  matching.splice(i, 1);
                }
              }
              for (let i = matching.length - 1; i >= 0; i--) {
                const inputs = matching[i].inputs;
                for (let j = 0; j < values.length; j++) {
                  if (!typed_js_1.Typed.isTyped(values[j])) {
                    continue;
                  }
                  if (values[j].type !== inputs[j].baseType) {
                    matching.splice(i, 1);
                    break;
                  }
                }
              }
            }
            if (matching.length === 0) {
              return null;
            }
            if (matching.length > 1 && forceUnique) {
              const matchStr = matching.map(m => JSON.stringify(m.format())).join(", ");
              (0, index_js_3.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
            }
            return matching[0];
          }
          const result = this.#events.get(fragments_js_1.EventFragment.from(key).format());
          if (result) {
            return result;
          }
          return null;
        }
        getEventName(key) {
          const fragment = this.#getEvent(key, null, false);
          (0, index_js_3.assertArgument)(fragment, "no matching event", "key", key);
          return fragment.name;
        }
        hasEvent(key) {
          return !!this.#getEvent(key, null, false);
        }
        getEvent(key, values) {
          return this.#getEvent(key, values || null, true);
        }
        forEachEvent(callback) {
          const names = Array.from(this.#events.keys());
          names.sort((a, b) => a.localeCompare(b));
          for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback(this.#events.get(name), i);
          }
        }
        getError(key, values) {
          if ((0, index_js_3.isHexString)(key)) {
            const selector = key.toLowerCase();
            if (BuiltinErrors[selector]) {
              return fragments_js_1.ErrorFragment.from(BuiltinErrors[selector].signature);
            }
            for (const fragment of this.#errors.values()) {
              if (selector === fragment.selector) {
                return fragment;
              }
            }
            return null;
          }
          if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of this.#errors) {
              if (name.split("(")[0] === key) {
                matching.push(fragment);
              }
            }
            if (matching.length === 0) {
              if (key === "Error") {
                return fragments_js_1.ErrorFragment.from("error Error(string)");
              }
              if (key === "Panic") {
                return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
              }
              return null;
            } else if (matching.length > 1) {
              const matchStr = matching.map(m => JSON.stringify(m.format())).join(", ");
              (0, index_js_3.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
            }
            return matching[0];
          }
          key = fragments_js_1.ErrorFragment.from(key).format();
          if (key === "Error(string)") {
            return fragments_js_1.ErrorFragment.from("error Error(string)");
          }
          if (key === "Panic(uint256)") {
            return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
          }
          const result = this.#errors.get(key);
          if (result) {
            return result;
          }
          return null;
        }
        forEachError(callback) {
          const names = Array.from(this.#errors.keys());
          names.sort((a, b) => a.localeCompare(b));
          for (let i = 0; i < names.length; i++) {
            const name = names[i];
            callback(this.#errors.get(name), i);
          }
        }
        _decodeParams(params, data) {
          return this.#abiCoder.decode(params, data);
        }
        _encodeParams(params, values) {
          return this.#abiCoder.encode(params, values);
        }
        encodeDeploy(values) {
          return this._encodeParams(this.deploy.inputs, values || []);
        }
        decodeErrorResult(fragment, data) {
          if (typeof fragment === "string") {
            const f = this.getError(fragment);
            (0, index_js_3.assertArgument)(f, "unknown error", "fragment", fragment);
            fragment = f;
          }
          (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
          return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
        }
        encodeErrorResult(fragment, values) {
          if (typeof fragment === "string") {
            const f = this.getError(fragment);
            (0, index_js_3.assertArgument)(f, "unknown error", "fragment", fragment);
            fragment = f;
          }
          return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
        }
        decodeFunctionData(fragment, data) {
          if (typeof fragment === "string") {
            const f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
          }
          (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
          return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
        }
        encodeFunctionData(fragment, values) {
          if (typeof fragment === "string") {
            const f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
          }
          return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
        }
        decodeFunctionResult(fragment, data) {
          if (typeof fragment === "string") {
            const f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
          }
          let message = "invalid length for result data";
          const bytes = (0, index_js_3.getBytesCopy)(data);
          if (bytes.length % 32 === 0) {
            try {
              return this.#abiCoder.decode(fragment.outputs, bytes);
            } catch (error) {
              message = "could not decode result data";
            }
          }
          (0, index_js_3.assert)(false, message, "BAD_DATA", {
            value: (0, index_js_3.hexlify)(bytes),
            info: {
              method: fragment.name,
              signature: fragment.format()
            }
          });
        }
        makeError(_data, tx) {
          const data = (0, index_js_3.getBytes)(_data, "data");
          const error = abi_coder_js_1.AbiCoder.getBuiltinCallException("call", tx, data);
          const customPrefix = "execution reverted (unknown custom error)";
          if (error.message.startsWith(customPrefix)) {
            const selector = (0, index_js_3.hexlify)(data.slice(0, 4));
            const ef = this.getError(selector);
            if (ef) {
              try {
                const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
                error.revert = {
                  name: ef.name,
                  signature: ef.format(),
                  args
                };
                error.reason = error.revert.signature;
                error.message = `execution reverted: ${error.reason}`;
              } catch (e) {
                error.message = `execution reverted (coult not decode custom error)`;
              }
            }
          }
          const parsed = this.parseTransaction(tx);
          if (parsed) {
            error.invocation = {
              method: parsed.name,
              signature: parsed.signature,
              args: parsed.args
            };
          }
          return error;
        }
        encodeFunctionResult(fragment, values) {
          if (typeof fragment === "string") {
            const f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
          }
          return (0, index_js_3.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));
        }
        encodeFilterTopics(fragment, values) {
          if (typeof fragment === "string") {
            const f = this.getEvent(fragment);
            (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
            fragment = f;
          }
          (0, index_js_3.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", {
            count: values.length,
            expectedCount: fragment.inputs.length
          });
          const topics = [];
          if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
          }
          const encodeTopic = (param, value) => {
            if (param.type === "string") {
              return (0, index_js_2.id)(value);
            } else if (param.type === "bytes") {
              return (0, index_js_1.keccak256)((0, index_js_3.hexlify)(value));
            }
            if (param.type === "bool" && typeof value === "boolean") {
              value = value ? "0x01" : "0x00";
            } else if (param.type.match(/^u?int/)) {
              value = (0, index_js_3.toBeHex)(value);
            } else if (param.type.match(/^bytes/)) {
              value = (0, index_js_3.zeroPadBytes)(value, 32);
            } else if (param.type === "address") {
              this.#abiCoder.encode(["address"], [value]);
            }
            return (0, index_js_3.zeroPadValue)((0, index_js_3.hexlify)(value), 32);
          };
          values.forEach((value, index) => {
            const param = fragment.inputs[index];
            if (!param.indexed) {
              (0, index_js_3.assertArgument)(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
              return;
            }
            if (value == null) {
              topics.push(null);
            } else if (param.baseType === "array" || param.baseType === "tuple") {
              (0, index_js_3.assertArgument)(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
            } else if (Array.isArray(value)) {
              topics.push(value.map(value => encodeTopic(param, value)));
            } else {
              topics.push(encodeTopic(param, value));
            }
          });
          while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
          }
          return topics;
        }
        encodeEventLog(fragment, values) {
          if (typeof fragment === "string") {
            const f = this.getEvent(fragment);
            (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
            fragment = f;
          }
          const topics = [];
          const dataTypes = [];
          const dataValues = [];
          if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
          }
          (0, index_js_3.assertArgument)(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
          fragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
              if (param.type === "string") {
                topics.push((0, index_js_2.id)(value));
              } else if (param.type === "bytes") {
                topics.push((0, index_js_1.keccak256)(value));
              } else if (param.baseType === "tuple" || param.baseType === "array") {
                throw new Error("not implemented");
              } else {
                topics.push(this.#abiCoder.encode([param.type], [value]));
              }
            } else {
              dataTypes.push(param);
              dataValues.push(value);
            }
          });
          return {
            data: this.#abiCoder.encode(dataTypes, dataValues),
            topics: topics
          };
        }
        decodeEventLog(fragment, data, topics) {
          if (typeof fragment === "string") {
            const f = this.getEvent(fragment);
            (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
            fragment = f;
          }
          if (topics != null && !fragment.anonymous) {
            const eventTopic = fragment.topicHash;
            (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
            topics = topics.slice(1);
          }
          const indexed = [];
          const nonIndexed = [];
          const dynamic = [];
          fragment.inputs.forEach((param, index) => {
            if (param.indexed) {
              if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                indexed.push(fragments_js_1.ParamType.from({
                  type: "bytes32",
                  name: param.name
                }));
                dynamic.push(true);
              } else {
                indexed.push(param);
                dynamic.push(false);
              }
            } else {
              nonIndexed.push(param);
              dynamic.push(false);
            }
          });
          const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, (0, index_js_3.concat)(topics)) : null;
          const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
          const values = [];
          const keys = [];
          let nonIndexedIndex = 0,
            indexedIndex = 0;
          fragment.inputs.forEach((param, index) => {
            let value = null;
            if (param.indexed) {
              if (resultIndexed == null) {
                value = new Indexed(null);
              } else if (dynamic[index]) {
                value = new Indexed(resultIndexed[indexedIndex++]);
              } else {
                try {
                  value = resultIndexed[indexedIndex++];
                } catch (error) {
                  value = error;
                }
              }
            } else {
              try {
                value = resultNonIndexed[nonIndexedIndex++];
              } catch (error) {
                value = error;
              }
            }
            values.push(value);
            keys.push(param.name || null);
          });
          return abstract_coder_js_1.Result.fromItems(values, keys);
        }
        parseTransaction(tx) {
          const data = (0, index_js_3.getBytes)(tx.data, "tx.data");
          const value = (0, index_js_3.getBigInt)(tx.value != null ? tx.value : 0, "tx.value");
          const fragment = this.getFunction((0, index_js_3.hexlify)(data.slice(0, 4)));
          if (!fragment) {
            return null;
          }
          const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
          return new TransactionDescription(fragment, fragment.selector, args, value);
        }
        parseCallResult(data) {
          throw new Error("@TODO");
        }
        parseLog(log) {
          const fragment = this.getEvent(log.topics[0]);
          if (!fragment || fragment.anonymous) {
            return null;
          }
          return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
        }
        parseError(data) {
          const hexData = (0, index_js_3.hexlify)(data);
          const fragment = this.getError((0, index_js_3.dataSlice)(hexData, 0, 4));
          if (!fragment) {
            return null;
          }
          const args = this.#abiCoder.decode(fragment.inputs, (0, index_js_3.dataSlice)(hexData, 4));
          return new ErrorDescription(fragment, fragment.selector, args);
        }
        static from(value) {
          if (value instanceof Interface) {
            return value;
          }
          if (typeof value === "string") {
            return new Interface(JSON.parse(value));
          }
          if (typeof value.format === "function") {
            return new Interface(value.format("json"));
          }
          return new Interface(value);
        }
      }
      exports.Interface = Interface;
    },
    7673: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Typed = void 0;
      const index_js_1 = __webpack_require__(9830);
      const _gaurd = {};
      function n(value, width) {
        let signed = false;
        if (width < 0) {
          signed = true;
          width *= -1;
        }
        return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, {
          signed,
          width
        });
      }
      function b(value, size) {
        return new Typed(_gaurd, `bytes${size ? size : ""}`, value, {
          size
        });
      }
      const _typedSymbol = Symbol.for("_ethers_typed");
      class Typed {
        type;
        value;
        #options;
        _typedSymbol;
        constructor(gaurd, type, value, options) {
          if (options == null) {
            options = null;
          }
          (0, index_js_1.assertPrivate)(_gaurd, gaurd, "Typed");
          (0, index_js_1.defineProperties)(this, {
            _typedSymbol,
            type,
            value
          });
          this.#options = options;
          this.format();
        }
        format() {
          if (this.type === "array") {
            throw new Error("");
          } else if (this.type === "dynamicArray") {
            throw new Error("");
          } else if (this.type === "tuple") {
            return `tuple(${this.value.map(v => v.format()).join(",")})`;
          }
          return this.type;
        }
        defaultValue() {
          return 0;
        }
        minValue() {
          return 0;
        }
        maxValue() {
          return 0;
        }
        isBigInt() {
          return !!this.type.match(/^u?int[0-9]+$/);
        }
        isData() {
          return this.type.startsWith("bytes");
        }
        isString() {
          return this.type === "string";
        }
        get tupleName() {
          if (this.type !== "tuple") {
            throw TypeError("not a tuple");
          }
          return this.#options;
        }
        get arrayLength() {
          if (this.type !== "array") {
            throw TypeError("not an array");
          }
          if (this.#options === true) {
            return -1;
          }
          if (this.#options === false) {
            return this.value.length;
          }
          return null;
        }
        static from(type, value) {
          return new Typed(_gaurd, type, value);
        }
        static uint8(v) {
          return n(v, 8);
        }
        static uint16(v) {
          return n(v, 16);
        }
        static uint24(v) {
          return n(v, 24);
        }
        static uint32(v) {
          return n(v, 32);
        }
        static uint40(v) {
          return n(v, 40);
        }
        static uint48(v) {
          return n(v, 48);
        }
        static uint56(v) {
          return n(v, 56);
        }
        static uint64(v) {
          return n(v, 64);
        }
        static uint72(v) {
          return n(v, 72);
        }
        static uint80(v) {
          return n(v, 80);
        }
        static uint88(v) {
          return n(v, 88);
        }
        static uint96(v) {
          return n(v, 96);
        }
        static uint104(v) {
          return n(v, 104);
        }
        static uint112(v) {
          return n(v, 112);
        }
        static uint120(v) {
          return n(v, 120);
        }
        static uint128(v) {
          return n(v, 128);
        }
        static uint136(v) {
          return n(v, 136);
        }
        static uint144(v) {
          return n(v, 144);
        }
        static uint152(v) {
          return n(v, 152);
        }
        static uint160(v) {
          return n(v, 160);
        }
        static uint168(v) {
          return n(v, 168);
        }
        static uint176(v) {
          return n(v, 176);
        }
        static uint184(v) {
          return n(v, 184);
        }
        static uint192(v) {
          return n(v, 192);
        }
        static uint200(v) {
          return n(v, 200);
        }
        static uint208(v) {
          return n(v, 208);
        }
        static uint216(v) {
          return n(v, 216);
        }
        static uint224(v) {
          return n(v, 224);
        }
        static uint232(v) {
          return n(v, 232);
        }
        static uint240(v) {
          return n(v, 240);
        }
        static uint248(v) {
          return n(v, 248);
        }
        static uint256(v) {
          return n(v, 256);
        }
        static uint(v) {
          return n(v, 256);
        }
        static int8(v) {
          return n(v, -8);
        }
        static int16(v) {
          return n(v, -16);
        }
        static int24(v) {
          return n(v, -24);
        }
        static int32(v) {
          return n(v, -32);
        }
        static int40(v) {
          return n(v, -40);
        }
        static int48(v) {
          return n(v, -48);
        }
        static int56(v) {
          return n(v, -56);
        }
        static int64(v) {
          return n(v, -64);
        }
        static int72(v) {
          return n(v, -72);
        }
        static int80(v) {
          return n(v, -80);
        }
        static int88(v) {
          return n(v, -88);
        }
        static int96(v) {
          return n(v, -96);
        }
        static int104(v) {
          return n(v, -104);
        }
        static int112(v) {
          return n(v, -112);
        }
        static int120(v) {
          return n(v, -120);
        }
        static int128(v) {
          return n(v, -128);
        }
        static int136(v) {
          return n(v, -136);
        }
        static int144(v) {
          return n(v, -144);
        }
        static int152(v) {
          return n(v, -152);
        }
        static int160(v) {
          return n(v, -160);
        }
        static int168(v) {
          return n(v, -168);
        }
        static int176(v) {
          return n(v, -176);
        }
        static int184(v) {
          return n(v, -184);
        }
        static int192(v) {
          return n(v, -192);
        }
        static int200(v) {
          return n(v, -200);
        }
        static int208(v) {
          return n(v, -208);
        }
        static int216(v) {
          return n(v, -216);
        }
        static int224(v) {
          return n(v, -224);
        }
        static int232(v) {
          return n(v, -232);
        }
        static int240(v) {
          return n(v, -240);
        }
        static int248(v) {
          return n(v, -248);
        }
        static int256(v) {
          return n(v, -256);
        }
        static int(v) {
          return n(v, -256);
        }
        static bytes1(v) {
          return b(v, 1);
        }
        static bytes2(v) {
          return b(v, 2);
        }
        static bytes3(v) {
          return b(v, 3);
        }
        static bytes4(v) {
          return b(v, 4);
        }
        static bytes5(v) {
          return b(v, 5);
        }
        static bytes6(v) {
          return b(v, 6);
        }
        static bytes7(v) {
          return b(v, 7);
        }
        static bytes8(v) {
          return b(v, 8);
        }
        static bytes9(v) {
          return b(v, 9);
        }
        static bytes10(v) {
          return b(v, 10);
        }
        static bytes11(v) {
          return b(v, 11);
        }
        static bytes12(v) {
          return b(v, 12);
        }
        static bytes13(v) {
          return b(v, 13);
        }
        static bytes14(v) {
          return b(v, 14);
        }
        static bytes15(v) {
          return b(v, 15);
        }
        static bytes16(v) {
          return b(v, 16);
        }
        static bytes17(v) {
          return b(v, 17);
        }
        static bytes18(v) {
          return b(v, 18);
        }
        static bytes19(v) {
          return b(v, 19);
        }
        static bytes20(v) {
          return b(v, 20);
        }
        static bytes21(v) {
          return b(v, 21);
        }
        static bytes22(v) {
          return b(v, 22);
        }
        static bytes23(v) {
          return b(v, 23);
        }
        static bytes24(v) {
          return b(v, 24);
        }
        static bytes25(v) {
          return b(v, 25);
        }
        static bytes26(v) {
          return b(v, 26);
        }
        static bytes27(v) {
          return b(v, 27);
        }
        static bytes28(v) {
          return b(v, 28);
        }
        static bytes29(v) {
          return b(v, 29);
        }
        static bytes30(v) {
          return b(v, 30);
        }
        static bytes31(v) {
          return b(v, 31);
        }
        static bytes32(v) {
          return b(v, 32);
        }
        static address(v) {
          return new Typed(_gaurd, "address", v);
        }
        static bool(v) {
          return new Typed(_gaurd, "bool", !!v);
        }
        static bytes(v) {
          return new Typed(_gaurd, "bytes", v);
        }
        static string(v) {
          return new Typed(_gaurd, "string", v);
        }
        static array(v, dynamic) {
          throw new Error("not implemented yet");
          return new Typed(_gaurd, "array", v, dynamic);
        }
        static tuple(v, name) {
          throw new Error("not implemented yet");
          return new Typed(_gaurd, "tuple", v, name);
        }
        static overrides(v) {
          return new Typed(_gaurd, "overrides", Object.assign({}, v));
        }
        static isTyped(value) {
          return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
        }
        static dereference(value, type) {
          if (Typed.isTyped(value)) {
            if (value.type !== type) {
              throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
            }
            return value.value;
          }
          return value;
        }
      }
      exports.Typed = Typed;
    },
    2579: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getIcapAddress = exports.getAddress = void 0;
      const index_js_1 = __webpack_require__(9420);
      const index_js_2 = __webpack_require__(9830);
      const BN_0 = BigInt(0);
      const BN_36 = BigInt(36);
      function getChecksumAddress(address) {
        address = address.toLowerCase();
        const chars = address.substring(2).split("");
        const expanded = new Uint8Array(40);
        for (let i = 0; i < 40; i++) {
          expanded[i] = chars[i].charCodeAt(0);
        }
        const hashed = (0, index_js_2.getBytes)((0, index_js_1.keccak256)(expanded));
        for (let i = 0; i < 40; i += 2) {
          if (hashed[i >> 1] >> 4 >= 8) {
            chars[i] = chars[i].toUpperCase();
          }
          if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
          }
        }
        return "0x" + chars.join("");
      }
      const ibanLookup = {};
      for (let i = 0; i < 10; i++) {
        ibanLookup[String(i)] = String(i);
      }
      for (let i = 0; i < 26; i++) {
        ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
      }
      const safeDigits = 15;
      function ibanChecksum(address) {
        address = address.toUpperCase();
        address = address.substring(4) + address.substring(0, 2) + "00";
        let expanded = address.split("").map(c => {
          return ibanLookup[c];
        }).join("");
        while (expanded.length >= safeDigits) {
          let block = expanded.substring(0, safeDigits);
          expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
        }
        let checksum = String(98 - parseInt(expanded, 10) % 97);
        while (checksum.length < 2) {
          checksum = "0" + checksum;
        }
        return checksum;
      }
      ;
      const Base36 = function () {
        ;
        const result = {};
        for (let i = 0; i < 36; i++) {
          const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
          result[key] = BigInt(i);
        }
        return result;
      }();
      function fromBase36(value) {
        value = value.toLowerCase();
        let result = BN_0;
        for (let i = 0; i < value.length; i++) {
          result = result * BN_36 + Base36[value[i]];
        }
        return result;
      }
      function getAddress(address) {
        (0, index_js_2.assertArgument)(typeof address === "string", "invalid address", "address", address);
        if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
          if (!address.startsWith("0x")) {
            address = "0x" + address;
          }
          const result = getChecksumAddress(address);
          (0, index_js_2.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
          return result;
        }
        if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
          (0, index_js_2.assertArgument)(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
          let result = fromBase36(address.substring(4)).toString(16);
          while (result.length < 40) {
            result = "0" + result;
          }
          return getChecksumAddress("0x" + result);
        }
        (0, index_js_2.assertArgument)(false, "invalid address", "address", address);
      }
      exports.getAddress = getAddress;
      function getIcapAddress(address) {
        let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
        while (base36.length < 30) {
          base36 = "0" + base36;
        }
        return "XE" + ibanChecksum("XE00" + base36) + base36;
      }
      exports.getIcapAddress = getIcapAddress;
    },
    5013: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;
      const index_js_1 = __webpack_require__(9830);
      const address_js_1 = __webpack_require__(2579);
      function isAddressable(value) {
        return value && typeof value.getAddress === "function";
      }
      exports.isAddressable = isAddressable;
      function isAddress(value) {
        try {
          (0, address_js_1.getAddress)(value);
          return true;
        } catch (error) {}
        return false;
      }
      exports.isAddress = isAddress;
      async function checkAddress(target, promise) {
        const result = await promise;
        if (result == null || result === "0x0000000000000000000000000000000000000000") {
          (0, index_js_1.assert)(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", {
            value: target
          });
          (0, index_js_1.assertArgument)(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
        }
        return (0, address_js_1.getAddress)(result);
      }
      function resolveAddress(target, resolver) {
        if (typeof target === "string") {
          if (target.match(/^0x[0-9a-f]{40}$/i)) {
            return (0, address_js_1.getAddress)(target);
          }
          (0, index_js_1.assert)(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
          return checkAddress(target, resolver.resolveName(target));
        } else if (isAddressable(target)) {
          return checkAddress(target, target.getAddress());
        } else if (target && typeof target.then === "function") {
          return checkAddress(target, target);
        }
        (0, index_js_1.assertArgument)(false, "unsupported addressable value", "target", target);
      }
      exports.resolveAddress = resolveAddress;
    },
    5668: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getCreate2Address = exports.getCreateAddress = void 0;
      const index_js_1 = __webpack_require__(9420);
      const index_js_2 = __webpack_require__(9830);
      const address_js_1 = __webpack_require__(2579);
      function getCreateAddress(tx) {
        const from = (0, address_js_1.getAddress)(tx.from);
        const nonce = (0, index_js_2.getBigInt)(tx.nonce, "tx.nonce");
        let nonceHex = nonce.toString(16);
        if (nonceHex === "0") {
          nonceHex = "0x";
        } else if (nonceHex.length % 2) {
          nonceHex = "0x0" + nonceHex;
        } else {
          nonceHex = "0x" + nonceHex;
        }
        return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.encodeRlp)([from, nonceHex])), 12));
      }
      exports.getCreateAddress = getCreateAddress;
      function getCreate2Address(_from, _salt, _initCodeHash) {
        const from = (0, address_js_1.getAddress)(_from);
        const salt = (0, index_js_2.getBytes)(_salt, "salt");
        const initCodeHash = (0, index_js_2.getBytes)(_initCodeHash, "initCodeHash");
        (0, index_js_2.assertArgument)(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
        (0, index_js_2.assertArgument)(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
        return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)(["0xff", from, salt, initCodeHash])), 12));
      }
      exports.getCreate2Address = getCreate2Address;
    },
    2134: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = void 0;
      null;
      var address_js_1 = __webpack_require__(2579);
      Object.defineProperty(exports, "getAddress", {
        enumerable: true,
        get: function () {
          return address_js_1.getAddress;
        }
      });
      Object.defineProperty(exports, "getIcapAddress", {
        enumerable: true,
        get: function () {
          return address_js_1.getIcapAddress;
        }
      });
      var contract_address_js_1 = __webpack_require__(5668);
      Object.defineProperty(exports, "getCreateAddress", {
        enumerable: true,
        get: function () {
          return contract_address_js_1.getCreateAddress;
        }
      });
      Object.defineProperty(exports, "getCreate2Address", {
        enumerable: true,
        get: function () {
          return contract_address_js_1.getCreate2Address;
        }
      });
      var checks_js_1 = __webpack_require__(5013);
      Object.defineProperty(exports, "isAddressable", {
        enumerable: true,
        get: function () {
          return checks_js_1.isAddressable;
        }
      });
      Object.defineProperty(exports, "isAddress", {
        enumerable: true,
        get: function () {
          return checks_js_1.isAddress;
        }
      });
      Object.defineProperty(exports, "resolveAddress", {
        enumerable: true,
        get: function () {
          return checks_js_1.resolveAddress;
        }
      });
    },
    506: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ZeroAddress = void 0;
      exports.ZeroAddress = "0x0000000000000000000000000000000000000000";
    },
    5414: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ZeroHash = void 0;
      exports.ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
    },
    4160: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MessagePrefix = exports.EtherSymbol = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = exports.ZeroHash = exports.ZeroAddress = void 0;
      var addresses_js_1 = __webpack_require__(506);
      Object.defineProperty(exports, "ZeroAddress", {
        enumerable: true,
        get: function () {
          return addresses_js_1.ZeroAddress;
        }
      });
      var hashes_js_1 = __webpack_require__(5414);
      Object.defineProperty(exports, "ZeroHash", {
        enumerable: true,
        get: function () {
          return hashes_js_1.ZeroHash;
        }
      });
      var numbers_js_1 = __webpack_require__(6033);
      Object.defineProperty(exports, "N", {
        enumerable: true,
        get: function () {
          return numbers_js_1.N;
        }
      });
      Object.defineProperty(exports, "WeiPerEther", {
        enumerable: true,
        get: function () {
          return numbers_js_1.WeiPerEther;
        }
      });
      Object.defineProperty(exports, "MaxUint256", {
        enumerable: true,
        get: function () {
          return numbers_js_1.MaxUint256;
        }
      });
      Object.defineProperty(exports, "MinInt256", {
        enumerable: true,
        get: function () {
          return numbers_js_1.MinInt256;
        }
      });
      Object.defineProperty(exports, "MaxInt256", {
        enumerable: true,
        get: function () {
          return numbers_js_1.MaxInt256;
        }
      });
      var strings_js_1 = __webpack_require__(1842);
      Object.defineProperty(exports, "EtherSymbol", {
        enumerable: true,
        get: function () {
          return strings_js_1.EtherSymbol;
        }
      });
      Object.defineProperty(exports, "MessagePrefix", {
        enumerable: true,
        get: function () {
          return strings_js_1.MessagePrefix;
        }
      });
    },
    6033: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = void 0;
      exports.N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      exports.WeiPerEther = BigInt("1000000000000000000");
      exports.MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      exports.MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
      exports.MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    },
    1842: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MessagePrefix = exports.EtherSymbol = void 0;
      exports.EtherSymbol = "\u039e";
      exports.MessagePrefix = "\x19Ethereum Signed Message:\n";
    },
    4789: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;
      const index_js_1 = __webpack_require__(5262);
      const index_js_2 = __webpack_require__(2134);
      const provider_js_1 = __webpack_require__(1607);
      const index_js_3 = __webpack_require__(9830);
      const wrappers_js_1 = __webpack_require__(3972);
      const BN_0 = BigInt(0);
      function canCall(value) {
        return value && typeof value.call === "function";
      }
      function canEstimate(value) {
        return value && typeof value.estimateGas === "function";
      }
      function canResolve(value) {
        return value && typeof value.resolveName === "function";
      }
      function canSend(value) {
        return value && typeof value.sendTransaction === "function";
      }
      class PreparedTopicFilter {
        #filter;
        fragment;
        constructor(contract, fragment, args) {
          (0, index_js_3.defineProperties)(this, {
            fragment
          });
          if (fragment.inputs.length < args.length) {
            throw new Error("too many arguments");
          }
          const runner = getRunner(contract.runner, "resolveName");
          const resolver = canResolve(runner) ? runner : null;
          this.#filter = async function () {
            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
              const arg = args[index];
              if (arg == null) {
                return null;
              }
              return param.walkAsync(args[index], (type, value) => {
                if (type === "address") {
                  if (Array.isArray(value)) {
                    return Promise.all(value.map(v => (0, index_js_2.resolveAddress)(v, resolver)));
                  }
                  return (0, index_js_2.resolveAddress)(value, resolver);
                }
                return value;
              });
            }));
            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
          }();
        }
        getTopicFilter() {
          return this.#filter;
        }
      }
      function getRunner(value, feature) {
        if (value == null) {
          return null;
        }
        if (typeof value[feature] === "function") {
          return value;
        }
        if (value.provider && typeof value.provider[feature] === "function") {
          return value.provider;
        }
        return null;
      }
      function getProvider(value) {
        if (value == null) {
          return null;
        }
        return value.provider || null;
      }
      async function copyOverrides(arg, allowed) {
        const _overrides = index_js_1.Typed.dereference(arg, "overrides");
        (0, index_js_3.assertArgument)(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
        const overrides = (0, provider_js_1.copyRequest)(_overrides);
        (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
        (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
        if (overrides.from) {
          overrides.from = await (0, index_js_2.resolveAddress)(overrides.from);
        }
        return overrides;
      }
      exports.copyOverrides = copyOverrides;
      async function resolveArgs(_runner, inputs, args) {
        const runner = getRunner(_runner, "resolveName");
        const resolver = canResolve(runner) ? runner : null;
        return await Promise.all(inputs.map((param, index) => {
          return param.walkAsync(args[index], (type, value) => {
            value = index_js_1.Typed.dereference(value, type);
            if (type === "address") {
              return (0, index_js_2.resolveAddress)(value, resolver);
            }
            return value;
          });
        }));
      }
      exports.resolveArgs = resolveArgs;
      function buildWrappedFallback(contract) {
        const populateTransaction = async function (overrides) {
          const tx = await copyOverrides(overrides, ["data"]);
          tx.to = await contract.getAddress();
          const iface = contract.interface;
          const noValue = (0, index_js_3.getBigInt)(tx.value || BN_0, "overrides.value") === BN_0;
          const noData = (tx.data || "0x") === "0x";
          if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
            (0, index_js_3.assertArgument)(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
          }
          (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
          const payable = iface.receive || iface.fallback && iface.fallback.payable;
          (0, index_js_3.assertArgument)(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
          (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
          return tx;
        };
        const staticCall = async function (overrides) {
          const runner = getRunner(contract.runner, "call");
          (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
            operation: "call"
          });
          const tx = await populateTransaction(overrides);
          try {
            return await runner.call(tx);
          } catch (error) {
            if ((0, index_js_3.isCallException)(error) && error.data) {
              throw contract.interface.makeError(error.data, tx);
            }
            throw error;
          }
        };
        const send = async function (overrides) {
          const runner = contract.runner;
          (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
            operation: "sendTransaction"
          });
          const tx = await runner.sendTransaction(await populateTransaction(overrides));
          const provider = getProvider(contract.runner);
          return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);
        };
        const estimateGas = async function (overrides) {
          const runner = getRunner(contract.runner, "estimateGas");
          (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
            operation: "estimateGas"
          });
          return await runner.estimateGas(await populateTransaction(overrides));
        };
        const method = async overrides => {
          return await send(overrides);
        };
        (0, index_js_3.defineProperties)(method, {
          _contract: contract,
          estimateGas,
          populateTransaction,
          send,
          staticCall
        });
        return method;
      }
      function buildWrappedMethod(contract, key) {
        const getFragment = function (...args) {
          const fragment = contract.interface.getFunction(key, args);
          (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: {
              key,
              args
            }
          });
          return fragment;
        };
        const populateTransaction = async function (...args) {
          const fragment = getFragment(...args);
          let overrides = {};
          if (fragment.inputs.length + 1 === args.length) {
            overrides = await copyOverrides(args.pop());
          }
          if (fragment.inputs.length !== args.length) {
            throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
          }
          const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
          return Object.assign({}, overrides, await (0, index_js_3.resolveProperties)({
            to: contract.getAddress(),
            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
          }));
        };
        const staticCall = async function (...args) {
          const result = await staticCallResult(...args);
          if (result.length === 1) {
            return result[0];
          }
          return result;
        };
        const send = async function (...args) {
          const runner = contract.runner;
          (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
            operation: "sendTransaction"
          });
          const tx = await runner.sendTransaction(await populateTransaction(...args));
          const provider = getProvider(contract.runner);
          return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);
        };
        const estimateGas = async function (...args) {
          const runner = getRunner(contract.runner, "estimateGas");
          (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
            operation: "estimateGas"
          });
          return await runner.estimateGas(await populateTransaction(...args));
        };
        const staticCallResult = async function (...args) {
          const runner = getRunner(contract.runner, "call");
          (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
            operation: "call"
          });
          const tx = await populateTransaction(...args);
          let result = "0x";
          try {
            result = await runner.call(tx);
          } catch (error) {
            if ((0, index_js_3.isCallException)(error) && error.data) {
              throw contract.interface.makeError(error.data, tx);
            }
            throw error;
          }
          const fragment = getFragment(...args);
          return contract.interface.decodeFunctionResult(fragment, result);
        };
        const method = async (...args) => {
          const fragment = getFragment(...args);
          if (fragment.constant) {
            return await staticCall(...args);
          }
          return await send(...args);
        };
        (0, index_js_3.defineProperties)(method, {
          name: contract.interface.getFunctionName(key),
          _contract: contract,
          _key: key,
          getFragment,
          estimateGas,
          populateTransaction,
          send,
          staticCall,
          staticCallResult
        });
        Object.defineProperty(method, "fragment", {
          configurable: false,
          enumerable: true,
          get: () => {
            const fragment = contract.interface.getFunction(key);
            (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
              operation: "fragment",
              info: {
                key
              }
            });
            return fragment;
          }
        });
        return method;
      }
      function buildWrappedEvent(contract, key) {
        const getFragment = function (...args) {
          const fragment = contract.interface.getEvent(key, args);
          (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: {
              key,
              args
            }
          });
          return fragment;
        };
        const method = function (...args) {
          return new PreparedTopicFilter(contract, getFragment(...args), args);
        };
        (0, index_js_3.defineProperties)(method, {
          name: contract.interface.getEventName(key),
          _contract: contract,
          _key: key,
          getFragment
        });
        Object.defineProperty(method, "fragment", {
          configurable: false,
          enumerable: true,
          get: () => {
            const fragment = contract.interface.getEvent(key);
            (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
              operation: "fragment",
              info: {
                key
              }
            });
            return fragment;
          }
        });
        return method;
      }
      const internal = Symbol.for("_ethersInternal_contract");
      const internalValues = new WeakMap();
      function setInternal(contract, values) {
        internalValues.set(contract[internal], values);
      }
      function getInternal(contract) {
        return internalValues.get(contract[internal]);
      }
      function isDeferred(value) {
        return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
      }
      async function getSubInfo(contract, event) {
        let topics;
        let fragment = null;
        if (Array.isArray(event)) {
          const topicHashify = function (name) {
            if ((0, index_js_3.isHexString)(name, 32)) {
              return name;
            }
            const fragment = contract.interface.getEvent(name);
            (0, index_js_3.assertArgument)(fragment, "unknown fragment", "name", name);
            return fragment.topicHash;
          };
          topics = event.map(e => {
            if (e == null) {
              return null;
            }
            if (Array.isArray(e)) {
              return e.map(topicHashify);
            }
            return topicHashify(e);
          });
        } else if (event === "*") {
          topics = [null];
        } else if (typeof event === "string") {
          if ((0, index_js_3.isHexString)(event, 32)) {
            topics = [event];
          } else {
            fragment = contract.interface.getEvent(event);
            (0, index_js_3.assertArgument)(fragment, "unknown fragment", "event", event);
            topics = [fragment.topicHash];
          }
        } else if (isDeferred(event)) {
          topics = await event.getTopicFilter();
        } else if ("fragment" in event) {
          fragment = event.fragment;
          topics = [fragment.topicHash];
        } else {
          (0, index_js_3.assertArgument)(false, "unknown event name", "event", event);
        }
        topics = topics.map(t => {
          if (t == null) {
            return null;
          }
          if (Array.isArray(t)) {
            const items = Array.from(new Set(t.map(t => t.toLowerCase())).values());
            if (items.length === 1) {
              return items[0];
            }
            items.sort();
            return items;
          }
          return t.toLowerCase();
        });
        const tag = topics.map(t => {
          if (t == null) {
            return "null";
          }
          if (Array.isArray(t)) {
            return t.join("|");
          }
          return t;
        }).join("&");
        return {
          fragment,
          tag,
          topics
        };
      }
      async function hasSub(contract, event) {
        const {
          subs
        } = getInternal(contract);
        return subs.get((await getSubInfo(contract, event)).tag) || null;
      }
      async function getSub(contract, operation, event) {
        const provider = getProvider(contract.runner);
        (0, index_js_3.assert)(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
          operation
        });
        const {
          fragment,
          tag,
          topics
        } = await getSubInfo(contract, event);
        const {
          addr,
          subs
        } = getInternal(contract);
        let sub = subs.get(tag);
        if (!sub) {
          const address = addr ? addr : contract;
          const filter = {
            address,
            topics
          };
          const listener = log => {
            let foundFragment = fragment;
            if (foundFragment == null) {
              try {
                foundFragment = contract.interface.getEvent(log.topics[0]);
              } catch (error) {}
            }
            if (foundFragment) {
              const _foundFragment = foundFragment;
              const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
              emit(contract, event, args, listener => {
                return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);
              });
            } else {
              emit(contract, event, [], listener => {
                return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);
              });
            }
          };
          let starting = [];
          const start = () => {
            if (starting.length) {
              return;
            }
            starting.push(provider.on(filter, listener));
          };
          const stop = async () => {
            if (starting.length == 0) {
              return;
            }
            let started = starting;
            starting = [];
            await Promise.all(started);
            provider.off(filter, listener);
          };
          sub = {
            tag,
            listeners: [],
            start,
            stop
          };
          subs.set(tag, sub);
        }
        return sub;
      }
      let lastEmit = Promise.resolve();
      async function _emit(contract, event, args, payloadFunc) {
        await lastEmit;
        const sub = await hasSub(contract, event);
        if (!sub) {
          return false;
        }
        const count = sub.listeners.length;
        sub.listeners = sub.listeners.filter(({
          listener,
          once
        }) => {
          const passArgs = Array.from(args);
          if (payloadFunc) {
            passArgs.push(payloadFunc(once ? null : listener));
          }
          try {
            listener.call(contract, ...passArgs);
          } catch (error) {}
          return !once;
        });
        if (sub.listeners.length === 0) {
          sub.stop();
          getInternal(contract).subs.delete(sub.tag);
        }
        return count > 0;
      }
      async function emit(contract, event, args, payloadFunc) {
        try {
          await lastEmit;
        } catch (error) {}
        const resultPromise = _emit(contract, event, args, payloadFunc);
        lastEmit = resultPromise;
        return await resultPromise;
      }
      const passProperties = ["then"];
      class BaseContract {
        target;
        interface;
        runner;
        filters;
        [internal];
        fallback;
        constructor(target, abi, runner, _deployTx) {
          (0, index_js_3.assertArgument)(typeof target === "string" || (0, index_js_2.isAddressable)(target), "invalid value for Contract target", "target", target);
          if (runner == null) {
            runner = null;
          }
          const iface = index_js_1.Interface.from(abi);
          (0, index_js_3.defineProperties)(this, {
            target,
            runner,
            interface: iface
          });
          Object.defineProperty(this, internal, {
            value: {}
          });
          let addrPromise;
          let addr = null;
          let deployTx = null;
          if (_deployTx) {
            const provider = getProvider(runner);
            deployTx = new wrappers_js_1.ContractTransactionResponse(this.interface, provider, _deployTx);
          }
          let subs = new Map();
          if (typeof target === "string") {
            if ((0, index_js_3.isHexString)(target)) {
              addr = target;
              addrPromise = Promise.resolve(target);
            } else {
              const resolver = getRunner(runner, "resolveName");
              if (!canResolve(resolver)) {
                throw (0, index_js_3.makeError)("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                  operation: "resolveName"
                });
              }
              addrPromise = resolver.resolveName(target).then(addr => {
                if (addr == null) {
                  throw (0, index_js_3.makeError)("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                    value: target
                  });
                }
                getInternal(this).addr = addr;
                return addr;
              });
            }
          } else {
            addrPromise = target.getAddress().then(addr => {
              if (addr == null) {
                throw new Error("TODO");
              }
              getInternal(this).addr = addr;
              return addr;
            });
          }
          setInternal(this, {
            addrPromise,
            addr,
            deployTx,
            subs
          });
          const filters = new Proxy({}, {
            get: (target, prop, receiver) => {
              if (typeof prop === "symbol" || passProperties.indexOf(prop) >= 0) {
                return Reflect.get(target, prop, receiver);
              }
              try {
                return this.getEvent(prop);
              } catch (error) {
                if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                  throw error;
                }
              }
              return undefined;
            },
            has: (target, prop) => {
              if (passProperties.indexOf(prop) >= 0) {
                return Reflect.has(target, prop);
              }
              return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));
            }
          });
          (0, index_js_3.defineProperties)(this, {
            filters
          });
          (0, index_js_3.defineProperties)(this, {
            fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
          });
          return new Proxy(this, {
            get: (target, prop, receiver) => {
              if (typeof prop === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
                return Reflect.get(target, prop, receiver);
              }
              try {
                return target.getFunction(prop);
              } catch (error) {
                if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                  throw error;
                }
              }
              return undefined;
            },
            has: (target, prop) => {
              if (typeof prop === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
                return Reflect.has(target, prop);
              }
              return target.interface.hasFunction(prop);
            }
          });
        }
        connect(runner) {
          return new BaseContract(this.target, this.interface, runner);
        }
        attach(target) {
          return new BaseContract(target, this.interface, this.runner);
        }
        async getAddress() {
          return await getInternal(this).addrPromise;
        }
        async getDeployedCode() {
          const provider = getProvider(this.runner);
          (0, index_js_3.assert)(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "getDeployedCode"
          });
          const code = await provider.getCode(await this.getAddress());
          if (code === "0x") {
            return null;
          }
          return code;
        }
        async waitForDeployment() {
          const deployTx = this.deploymentTransaction();
          if (deployTx) {
            await deployTx.wait();
            return this;
          }
          const code = await this.getDeployedCode();
          if (code != null) {
            return this;
          }
          const provider = getProvider(this.runner);
          (0, index_js_3.assert)(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "waitForDeployment"
          });
          return new Promise((resolve, reject) => {
            const checkCode = async () => {
              try {
                const code = await this.getDeployedCode();
                if (code != null) {
                  return resolve(this);
                }
                provider.once("block", checkCode);
              } catch (error) {
                reject(error);
              }
            };
            checkCode();
          });
        }
        deploymentTransaction() {
          return getInternal(this).deployTx;
        }
        getFunction(key) {
          if (typeof key !== "string") {
            key = key.format();
          }
          const func = buildWrappedMethod(this, key);
          return func;
        }
        getEvent(key) {
          if (typeof key !== "string") {
            key = key.format();
          }
          return buildWrappedEvent(this, key);
        }
        async queryTransaction(hash) {
          throw new Error("@TODO");
        }
        async queryFilter(event, fromBlock, toBlock) {
          if (fromBlock == null) {
            fromBlock = 0;
          }
          if (toBlock == null) {
            toBlock = "latest";
          }
          const {
            addr,
            addrPromise
          } = getInternal(this);
          const address = addr ? addr : await addrPromise;
          const {
            fragment,
            topics
          } = await getSubInfo(this, event);
          const filter = {
            address,
            topics,
            fromBlock,
            toBlock
          };
          const provider = getProvider(this.runner);
          (0, index_js_3.assert)(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
            operation: "queryFilter"
          });
          return (await provider.getLogs(filter)).map(log => {
            let foundFragment = fragment;
            if (foundFragment == null) {
              try {
                foundFragment = this.interface.getEvent(log.topics[0]);
              } catch (error) {}
            }
            if (foundFragment) {
              try {
                return new wrappers_js_1.EventLog(log, this.interface, foundFragment);
              } catch (error) {
                return new wrappers_js_1.UndecodedEventLog(log, error);
              }
            }
            return new provider_js_1.Log(log, provider);
          });
        }
        async on(event, listener) {
          const sub = await getSub(this, "on", event);
          sub.listeners.push({
            listener,
            once: false
          });
          sub.start();
          return this;
        }
        async once(event, listener) {
          const sub = await getSub(this, "once", event);
          sub.listeners.push({
            listener,
            once: true
          });
          sub.start();
          return this;
        }
        async emit(event, ...args) {
          return await emit(this, event, args, null);
        }
        async listenerCount(event) {
          if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
              return 0;
            }
            return sub.listeners.length;
          }
          const {
            subs
          } = getInternal(this);
          let total = 0;
          for (const {
            listeners
          } of subs.values()) {
            total += listeners.length;
          }
          return total;
        }
        async listeners(event) {
          if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
              return [];
            }
            return sub.listeners.map(({
              listener
            }) => listener);
          }
          const {
            subs
          } = getInternal(this);
          let result = [];
          for (const {
            listeners
          } of subs.values()) {
            result = result.concat(listeners.map(({
              listener
            }) => listener));
          }
          return result;
        }
        async off(event, listener) {
          const sub = await hasSub(this, event);
          if (!sub) {
            return this;
          }
          if (listener) {
            const index = sub.listeners.map(({
              listener
            }) => listener).indexOf(listener);
            if (index >= 0) {
              sub.listeners.splice(index, 1);
            }
          }
          if (listener == null || sub.listeners.length === 0) {
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
          }
          return this;
        }
        async removeAllListeners(event) {
          if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
              return this;
            }
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
          } else {
            const {
              subs
            } = getInternal(this);
            for (const {
              tag,
              stop
            } of subs.values()) {
              stop();
              subs.delete(tag);
            }
          }
          return this;
        }
        async addListener(event, listener) {
          return await this.on(event, listener);
        }
        async removeListener(event, listener) {
          return await this.off(event, listener);
        }
        static buildClass(abi) {
          class CustomContract extends BaseContract {
            constructor(address, runner = null) {
              super(address, abi, runner);
            }
          }
          return CustomContract;
        }
        static from(target, abi, runner) {
          if (runner == null) {
            runner = null;
          }
          const contract = new this(target, abi, runner);
          return contract;
        }
      }
      exports.BaseContract = BaseContract;
      function _ContractBase() {
        return BaseContract;
      }
      class Contract extends _ContractBase() {}
      exports.Contract = Contract;
    },
    3959: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ContractFactory = void 0;
      const index_js_1 = __webpack_require__(5262);
      const index_js_2 = __webpack_require__(2134);
      const index_js_3 = __webpack_require__(9830);
      const contract_js_1 = __webpack_require__(4789);
      class ContractFactory {
        interface;
        bytecode;
        runner;
        constructor(abi, bytecode, runner) {
          const iface = index_js_1.Interface.from(abi);
          if (bytecode instanceof Uint8Array) {
            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
          } else {
            if (typeof bytecode === "object") {
              bytecode = bytecode.object;
            }
            if (!bytecode.startsWith("0x")) {
              bytecode = "0x" + bytecode;
            }
            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
          }
          (0, index_js_3.defineProperties)(this, {
            bytecode,
            interface: iface,
            runner: runner || null
          });
        }
        attach(target) {
          return new contract_js_1.BaseContract(target, this.interface, this.runner);
        }
        async getDeployTransaction(...args) {
          let overrides = {};
          const fragment = this.interface.deploy;
          if (fragment.inputs.length + 1 === args.length) {
            overrides = await (0, contract_js_1.copyOverrides)(args.pop());
          }
          if (fragment.inputs.length !== args.length) {
            throw new Error("incorrect number of arguments to constructor");
          }
          const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);
          const data = (0, index_js_3.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
          return Object.assign({}, overrides, {
            data
          });
        }
        async deploy(...args) {
          const tx = await this.getDeployTransaction(...args);
          (0, index_js_3.assert)(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
            operation: "sendTransaction"
          });
          const sentTx = await this.runner.sendTransaction(tx);
          const address = (0, index_js_2.getCreateAddress)(sentTx);
          return new contract_js_1.BaseContract(address, this.interface, this.runner, sentTx);
        }
        connect(runner) {
          return new ContractFactory(this.interface, this.bytecode, runner);
        }
        static fromSolidity(output, runner) {
          (0, index_js_3.assertArgument)(output != null, "bad compiler output", "output", output);
          if (typeof output === "string") {
            output = JSON.parse(output);
          }
          const abi = output.abi;
          let bytecode = "";
          if (output.bytecode) {
            bytecode = output.bytecode;
          } else if (output.evm && output.evm.bytecode) {
            bytecode = output.evm.bytecode;
          }
          return new this(abi, bytecode, runner);
        }
      }
      exports.ContractFactory = ContractFactory;
    },
    4464: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UndecodedEventLog = exports.EventLog = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractUnknownEventPayload = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = void 0;
      var contract_js_1 = __webpack_require__(4789);
      Object.defineProperty(exports, "BaseContract", {
        enumerable: true,
        get: function () {
          return contract_js_1.BaseContract;
        }
      });
      Object.defineProperty(exports, "Contract", {
        enumerable: true,
        get: function () {
          return contract_js_1.Contract;
        }
      });
      var factory_js_1 = __webpack_require__(3959);
      Object.defineProperty(exports, "ContractFactory", {
        enumerable: true,
        get: function () {
          return factory_js_1.ContractFactory;
        }
      });
      var wrappers_js_1 = __webpack_require__(3972);
      Object.defineProperty(exports, "ContractEventPayload", {
        enumerable: true,
        get: function () {
          return wrappers_js_1.ContractEventPayload;
        }
      });
      Object.defineProperty(exports, "ContractUnknownEventPayload", {
        enumerable: true,
        get: function () {
          return wrappers_js_1.ContractUnknownEventPayload;
        }
      });
      Object.defineProperty(exports, "ContractTransactionReceipt", {
        enumerable: true,
        get: function () {
          return wrappers_js_1.ContractTransactionReceipt;
        }
      });
      Object.defineProperty(exports, "ContractTransactionResponse", {
        enumerable: true,
        get: function () {
          return wrappers_js_1.ContractTransactionResponse;
        }
      });
      Object.defineProperty(exports, "EventLog", {
        enumerable: true,
        get: function () {
          return wrappers_js_1.EventLog;
        }
      });
      Object.defineProperty(exports, "UndecodedEventLog", {
        enumerable: true,
        get: function () {
          return wrappers_js_1.UndecodedEventLog;
        }
      });
    },
    3972: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ContractEventPayload = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.UndecodedEventLog = exports.EventLog = void 0;
      const provider_js_1 = __webpack_require__(1607);
      const index_js_1 = __webpack_require__(9830);
      class EventLog extends provider_js_1.Log {
        interface;
        fragment;
        args;
        constructor(log, iface, fragment) {
          super(log, log.provider);
          const args = iface.decodeEventLog(fragment, log.data, log.topics);
          (0, index_js_1.defineProperties)(this, {
            args,
            fragment,
            interface: iface
          });
        }
        get eventName() {
          return this.fragment.name;
        }
        get eventSignature() {
          return this.fragment.format();
        }
      }
      exports.EventLog = EventLog;
      class UndecodedEventLog extends provider_js_1.Log {
        error;
        constructor(log, error) {
          super(log, log.provider);
          (0, index_js_1.defineProperties)(this, {
            error
          });
        }
      }
      exports.UndecodedEventLog = UndecodedEventLog;
      class ContractTransactionReceipt extends provider_js_1.TransactionReceipt {
        #iface;
        constructor(iface, provider, tx) {
          super(tx, provider);
          this.#iface = iface;
        }
        get logs() {
          return super.logs.map(log => {
            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
            if (fragment) {
              try {
                return new EventLog(log, this.#iface, fragment);
              } catch (error) {
                return new UndecodedEventLog(log, error);
              }
            }
            return log;
          });
        }
      }
      exports.ContractTransactionReceipt = ContractTransactionReceipt;
      class ContractTransactionResponse extends provider_js_1.TransactionResponse {
        #iface;
        constructor(iface, provider, tx) {
          super(tx, provider);
          this.#iface = iface;
        }
        async wait(confirms) {
          const receipt = await super.wait(confirms);
          if (receipt == null) {
            return null;
          }
          return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
        }
      }
      exports.ContractTransactionResponse = ContractTransactionResponse;
      class ContractUnknownEventPayload extends index_js_1.EventPayload {
        log;
        constructor(contract, listener, filter, log) {
          super(contract, listener, filter);
          (0, index_js_1.defineProperties)(this, {
            log
          });
        }
        async getBlock() {
          return await this.log.getBlock();
        }
        async getTransaction() {
          return await this.log.getTransaction();
        }
        async getTransactionReceipt() {
          return await this.log.getTransactionReceipt();
        }
      }
      exports.ContractUnknownEventPayload = ContractUnknownEventPayload;
      class ContractEventPayload extends ContractUnknownEventPayload {
        constructor(contract, listener, filter, fragment, _log) {
          super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
          const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
          (0, index_js_1.defineProperties)(this, {
            args,
            fragment
          });
        }
        get eventName() {
          return this.fragment.name;
        }
        get eventSignature() {
          return this.fragment.format();
        }
      }
      exports.ContractEventPayload = ContractEventPayload;
    },
    161: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.randomBytes = exports.pbkdf2Sync = exports.createHmac = exports.createHash = void 0;
      const hmac_1 = __webpack_require__(7227);
      const pbkdf2_1 = __webpack_require__(430);
      const sha256_1 = __webpack_require__(5468);
      const sha512_1 = __webpack_require__(6123);
      const index_js_1 = __webpack_require__(9830);
      function getGlobal() {
        if (typeof self !== 'undefined') {
          return self;
        }
        if (typeof window !== 'undefined') {
          return window;
        }
        if (typeof __webpack_require__.g !== 'undefined') {
          return __webpack_require__.g;
        }
        throw new Error('unable to locate global object');
      }
      ;
      const anyGlobal = getGlobal();
      const crypto = anyGlobal.crypto || anyGlobal.msCrypto;
      function createHash(algo) {
        switch (algo) {
          case "sha256":
            return sha256_1.sha256.create();
          case "sha512":
            return sha512_1.sha512.create();
        }
        (0, index_js_1.assertArgument)(false, "invalid hashing algorithm name", "algorithm", algo);
      }
      exports.createHash = createHash;
      function createHmac(_algo, key) {
        const algo = {
          sha256: sha256_1.sha256,
          sha512: sha512_1.sha512
        }[_algo];
        (0, index_js_1.assertArgument)(algo != null, "invalid hmac algorithm", "algorithm", _algo);
        return hmac_1.hmac.create(algo, key);
      }
      exports.createHmac = createHmac;
      function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
        const algo = {
          sha256: sha256_1.sha256,
          sha512: sha512_1.sha512
        }[_algo];
        (0, index_js_1.assertArgument)(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
        return (0, pbkdf2_1.pbkdf2)(algo, password, salt, {
          c: iterations,
          dkLen: keylen
        });
      }
      exports.pbkdf2Sync = pbkdf2Sync;
      function randomBytes(length) {
        (0, index_js_1.assert)(crypto != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
          operation: "randomBytes"
        });
        (0, index_js_1.assertArgument)(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
        const result = new Uint8Array(length);
        crypto.getRandomValues(result);
        return result;
      }
      exports.randomBytes = randomBytes;
    },
    8237: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.computeHmac = void 0;
      const crypto_js_1 = __webpack_require__(161);
      const index_js_1 = __webpack_require__(9830);
      let locked = false;
      const _computeHmac = function (algorithm, key, data) {
        return (0, crypto_js_1.createHmac)(algorithm, key).update(data).digest();
      };
      let __computeHmac = _computeHmac;
      function computeHmac(algorithm, _key, _data) {
        const key = (0, index_js_1.getBytes)(_key, "key");
        const data = (0, index_js_1.getBytes)(_data, "data");
        return (0, index_js_1.hexlify)(__computeHmac(algorithm, key, data));
      }
      exports.computeHmac = computeHmac;
      computeHmac._ = _computeHmac;
      computeHmac.lock = function () {
        locked = true;
      };
      computeHmac.register = function (func) {
        if (locked) {
          throw new Error("computeHmac is locked");
        }
        __computeHmac = func;
      };
      Object.freeze(computeHmac);
    },
    9420: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lock = exports.Signature = exports.SigningKey = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = void 0;
      null;
      const hmac_js_1 = __webpack_require__(8237);
      Object.defineProperty(exports, "computeHmac", {
        enumerable: true,
        get: function () {
          return hmac_js_1.computeHmac;
        }
      });
      const keccak_js_1 = __webpack_require__(5269);
      Object.defineProperty(exports, "keccak256", {
        enumerable: true,
        get: function () {
          return keccak_js_1.keccak256;
        }
      });
      const ripemd160_js_1 = __webpack_require__(3075);
      Object.defineProperty(exports, "ripemd160", {
        enumerable: true,
        get: function () {
          return ripemd160_js_1.ripemd160;
        }
      });
      const pbkdf2_js_1 = __webpack_require__(507);
      Object.defineProperty(exports, "pbkdf2", {
        enumerable: true,
        get: function () {
          return pbkdf2_js_1.pbkdf2;
        }
      });
      const random_js_1 = __webpack_require__(3468);
      Object.defineProperty(exports, "randomBytes", {
        enumerable: true,
        get: function () {
          return random_js_1.randomBytes;
        }
      });
      const scrypt_js_1 = __webpack_require__(1847);
      Object.defineProperty(exports, "scrypt", {
        enumerable: true,
        get: function () {
          return scrypt_js_1.scrypt;
        }
      });
      Object.defineProperty(exports, "scryptSync", {
        enumerable: true,
        get: function () {
          return scrypt_js_1.scryptSync;
        }
      });
      const sha2_js_1 = __webpack_require__(2927);
      Object.defineProperty(exports, "sha256", {
        enumerable: true,
        get: function () {
          return sha2_js_1.sha256;
        }
      });
      Object.defineProperty(exports, "sha512", {
        enumerable: true,
        get: function () {
          return sha2_js_1.sha512;
        }
      });
      var signing_key_js_1 = __webpack_require__(794);
      Object.defineProperty(exports, "SigningKey", {
        enumerable: true,
        get: function () {
          return signing_key_js_1.SigningKey;
        }
      });
      var signature_js_1 = __webpack_require__(9102);
      Object.defineProperty(exports, "Signature", {
        enumerable: true,
        get: function () {
          return signature_js_1.Signature;
        }
      });
      function lock() {
        hmac_js_1.computeHmac.lock();
        keccak_js_1.keccak256.lock();
        pbkdf2_js_1.pbkdf2.lock();
        random_js_1.randomBytes.lock();
        ripemd160_js_1.ripemd160.lock();
        scrypt_js_1.scrypt.lock();
        scrypt_js_1.scryptSync.lock();
        sha2_js_1.sha256.lock();
        sha2_js_1.sha512.lock();
        random_js_1.randomBytes.lock();
      }
      exports.lock = lock;
    },
    5269: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keccak256 = void 0;
      const sha3_1 = __webpack_require__(33);
      const index_js_1 = __webpack_require__(9830);
      let locked = false;
      const _keccak256 = function (data) {
        return (0, sha3_1.keccak_256)(data);
      };
      let __keccak256 = _keccak256;
      function keccak256(_data) {
        const data = (0, index_js_1.getBytes)(_data, "data");
        return (0, index_js_1.hexlify)(__keccak256(data));
      }
      exports.keccak256 = keccak256;
      keccak256._ = _keccak256;
      keccak256.lock = function () {
        locked = true;
      };
      keccak256.register = function (func) {
        if (locked) {
          throw new TypeError("keccak256 is locked");
        }
        __keccak256 = func;
      };
      Object.freeze(keccak256);
    },
    507: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pbkdf2 = void 0;
      const crypto_js_1 = __webpack_require__(161);
      const index_js_1 = __webpack_require__(9830);
      let locked = false;
      const _pbkdf2 = function (password, salt, iterations, keylen, algo) {
        return (0, crypto_js_1.pbkdf2Sync)(password, salt, iterations, keylen, algo);
      };
      let __pbkdf2 = _pbkdf2;
      function pbkdf2(_password, _salt, iterations, keylen, algo) {
        const password = (0, index_js_1.getBytes)(_password, "password");
        const salt = (0, index_js_1.getBytes)(_salt, "salt");
        return (0, index_js_1.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));
      }
      exports.pbkdf2 = pbkdf2;
      pbkdf2._ = _pbkdf2;
      pbkdf2.lock = function () {
        locked = true;
      };
      pbkdf2.register = function (func) {
        if (locked) {
          throw new Error("pbkdf2 is locked");
        }
        __pbkdf2 = func;
      };
      Object.freeze(pbkdf2);
    },
    3468: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.randomBytes = void 0;
      const crypto_js_1 = __webpack_require__(161);
      let locked = false;
      const _randomBytes = function (length) {
        return new Uint8Array((0, crypto_js_1.randomBytes)(length));
      };
      let __randomBytes = _randomBytes;
      function randomBytes(length) {
        return __randomBytes(length);
      }
      exports.randomBytes = randomBytes;
      randomBytes._ = _randomBytes;
      randomBytes.lock = function () {
        locked = true;
      };
      randomBytes.register = function (func) {
        if (locked) {
          throw new Error("randomBytes is locked");
        }
        __randomBytes = func;
      };
      Object.freeze(randomBytes);
    },
    3075: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ripemd160 = void 0;
      const ripemd160_1 = __webpack_require__(3163);
      const index_js_1 = __webpack_require__(9830);
      let locked = false;
      const _ripemd160 = function (data) {
        return (0, ripemd160_1.ripemd160)(data);
      };
      let __ripemd160 = _ripemd160;
      function ripemd160(_data) {
        const data = (0, index_js_1.getBytes)(_data, "data");
        return (0, index_js_1.hexlify)(__ripemd160(data));
      }
      exports.ripemd160 = ripemd160;
      ripemd160._ = _ripemd160;
      ripemd160.lock = function () {
        locked = true;
      };
      ripemd160.register = function (func) {
        if (locked) {
          throw new TypeError("ripemd160 is locked");
        }
        __ripemd160 = func;
      };
      Object.freeze(ripemd160);
    },
    1847: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.scryptSync = exports.scrypt = void 0;
      const scrypt_1 = __webpack_require__(5639);
      const index_js_1 = __webpack_require__(9830);
      let lockedSync = false,
        lockedAsync = false;
      const _scryptAsync = async function (passwd, salt, N, r, p, dkLen, onProgress) {
        return await (0, scrypt_1.scryptAsync)(passwd, salt, {
          N,
          r,
          p,
          dkLen,
          onProgress
        });
      };
      const _scryptSync = function (passwd, salt, N, r, p, dkLen) {
        return (0, scrypt_1.scrypt)(passwd, salt, {
          N,
          r,
          p,
          dkLen
        });
      };
      let __scryptAsync = _scryptAsync;
      let __scryptSync = _scryptSync;
      async function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {
        const passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
        const salt = (0, index_js_1.getBytes)(_salt, "salt");
        return (0, index_js_1.hexlify)(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));
      }
      exports.scrypt = scrypt;
      scrypt._ = _scryptAsync;
      scrypt.lock = function () {
        lockedAsync = true;
      };
      scrypt.register = function (func) {
        if (lockedAsync) {
          throw new Error("scrypt is locked");
        }
        __scryptAsync = func;
      };
      Object.freeze(scrypt);
      function scryptSync(_passwd, _salt, N, r, p, dkLen) {
        const passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
        const salt = (0, index_js_1.getBytes)(_salt, "salt");
        return (0, index_js_1.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));
      }
      exports.scryptSync = scryptSync;
      scryptSync._ = _scryptSync;
      scryptSync.lock = function () {
        lockedSync = true;
      };
      scryptSync.register = function (func) {
        if (lockedSync) {
          throw new Error("scryptSync is locked");
        }
        __scryptSync = func;
      };
      Object.freeze(scryptSync);
    },
    2927: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sha512 = exports.sha256 = void 0;
      const crypto_js_1 = __webpack_require__(161);
      const index_js_1 = __webpack_require__(9830);
      const _sha256 = function (data) {
        return (0, crypto_js_1.createHash)("sha256").update(data).digest();
      };
      const _sha512 = function (data) {
        return (0, crypto_js_1.createHash)("sha512").update(data).digest();
      };
      let __sha256 = _sha256;
      let __sha512 = _sha512;
      let locked256 = false,
        locked512 = false;
      function sha256(_data) {
        const data = (0, index_js_1.getBytes)(_data, "data");
        return (0, index_js_1.hexlify)(__sha256(data));
      }
      exports.sha256 = sha256;
      sha256._ = _sha256;
      sha256.lock = function () {
        locked256 = true;
      };
      sha256.register = function (func) {
        if (locked256) {
          throw new Error("sha256 is locked");
        }
        __sha256 = func;
      };
      Object.freeze(sha256);
      function sha512(_data) {
        const data = (0, index_js_1.getBytes)(_data, "data");
        return (0, index_js_1.hexlify)(__sha512(data));
      }
      exports.sha512 = sha512;
      sha512._ = _sha512;
      sha512.lock = function () {
        locked512 = true;
      };
      sha512.register = function (func) {
        if (locked512) {
          throw new Error("sha512 is locked");
        }
        __sha512 = func;
      };
      Object.freeze(sha256);
    },
    9102: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Signature = void 0;
      const index_js_1 = __webpack_require__(4160);
      const index_js_2 = __webpack_require__(9830);
      const BN_0 = BigInt(0);
      const BN_1 = BigInt(1);
      const BN_2 = BigInt(2);
      const BN_27 = BigInt(27);
      const BN_28 = BigInt(28);
      const BN_35 = BigInt(35);
      const _guard = {};
      function toUint256(value) {
        return (0, index_js_2.zeroPadValue)((0, index_js_2.toBeArray)(value), 32);
      }
      class Signature {
        #r;
        #s;
        #v;
        #networkV;
        get r() {
          return this.#r;
        }
        set r(value) {
          (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(value) === 32, "invalid r", "value", value);
          this.#r = (0, index_js_2.hexlify)(value);
        }
        get s() {
          return this.#s;
        }
        set s(_value) {
          (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(_value) === 32, "invalid s", "value", _value);
          const value = (0, index_js_2.hexlify)(_value);
          (0, index_js_2.assertArgument)(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
          this.#s = value;
        }
        get v() {
          return this.#v;
        }
        set v(value) {
          const v = (0, index_js_2.getNumber)(value, "value");
          (0, index_js_2.assertArgument)(v === 27 || v === 28, "invalid v", "v", value);
          this.#v = v;
        }
        get networkV() {
          return this.#networkV;
        }
        get legacyChainId() {
          const v = this.networkV;
          if (v == null) {
            return null;
          }
          return Signature.getChainId(v);
        }
        get yParity() {
          return this.v === 27 ? 0 : 1;
        }
        get yParityAndS() {
          const yParityAndS = (0, index_js_2.getBytes)(this.s);
          if (this.yParity) {
            yParityAndS[0] |= 0x80;
          }
          return (0, index_js_2.hexlify)(yParityAndS);
        }
        get compactSerialized() {
          return (0, index_js_2.concat)([this.r, this.yParityAndS]);
        }
        get serialized() {
          return (0, index_js_2.concat)([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
        }
        constructor(guard, r, s, v) {
          (0, index_js_2.assertPrivate)(guard, _guard, "Signature");
          this.#r = r;
          this.#s = s;
          this.#v = v;
          this.#networkV = null;
        }
        [Symbol.for('nodejs.util.inspect.custom')]() {
          return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
        }
        clone() {
          const clone = new Signature(_guard, this.r, this.s, this.v);
          if (this.networkV) {
            clone.#networkV = this.networkV;
          }
          return clone;
        }
        toJSON() {
          const networkV = this.networkV;
          return {
            _type: "signature",
            networkV: networkV != null ? networkV.toString() : null,
            r: this.r,
            s: this.s,
            v: this.v
          };
        }
        static getChainId(v) {
          const bv = (0, index_js_2.getBigInt)(v, "v");
          if (bv == BN_27 || bv == BN_28) {
            return BN_0;
          }
          (0, index_js_2.assertArgument)(bv >= BN_35, "invalid EIP-155 v", "v", v);
          return (bv - BN_35) / BN_2;
        }
        static getChainIdV(chainId, v) {
          return (0, index_js_2.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);
        }
        static getNormalizedV(v) {
          const bv = (0, index_js_2.getBigInt)(v);
          if (bv === BN_0 || bv === BN_27) {
            return 27;
          }
          if (bv === BN_1 || bv === BN_28) {
            return 28;
          }
          (0, index_js_2.assertArgument)(bv >= BN_35, "invalid v", "v", v);
          return bv & BN_1 ? 27 : 28;
        }
        static from(sig) {
          function assertError(check, message) {
            (0, index_js_2.assertArgument)(check, message, "signature", sig);
          }
          ;
          if (sig == null) {
            return new Signature(_guard, index_js_1.ZeroHash, index_js_1.ZeroHash, 27);
          }
          if (typeof sig === "string") {
            const bytes = (0, index_js_2.getBytes)(sig, "signature");
            if (bytes.length === 64) {
              const r = (0, index_js_2.hexlify)(bytes.slice(0, 32));
              const s = bytes.slice(32, 64);
              const v = s[0] & 0x80 ? 28 : 27;
              s[0] &= 0x7f;
              return new Signature(_guard, r, (0, index_js_2.hexlify)(s), v);
            }
            if (bytes.length === 65) {
              const r = (0, index_js_2.hexlify)(bytes.slice(0, 32));
              const s = bytes.slice(32, 64);
              assertError((s[0] & 0x80) === 0, "non-canonical s");
              const v = Signature.getNormalizedV(bytes[64]);
              return new Signature(_guard, r, (0, index_js_2.hexlify)(s), v);
            }
            assertError(false, "invalid raw signature length");
          }
          if (sig instanceof Signature) {
            return sig.clone();
          }
          const _r = sig.r;
          assertError(_r != null, "missing r");
          const r = toUint256(_r);
          const s = function (s, yParityAndS) {
            if (s != null) {
              return toUint256(s);
            }
            if (yParityAndS != null) {
              assertError((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
              const bytes = (0, index_js_2.getBytes)(yParityAndS);
              bytes[0] &= 0x7f;
              return (0, index_js_2.hexlify)(bytes);
            }
            assertError(false, "missing s");
          }(sig.s, sig.yParityAndS);
          assertError(((0, index_js_2.getBytes)(s)[0] & 0x80) == 0, "non-canonical s");
          const {
            networkV,
            v
          } = function (_v, yParityAndS, yParity) {
            if (_v != null) {
              const v = (0, index_js_2.getBigInt)(_v);
              return {
                networkV: v >= BN_35 ? v : undefined,
                v: Signature.getNormalizedV(v)
              };
            }
            if (yParityAndS != null) {
              assertError((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
              return {
                v: (0, index_js_2.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27
              };
            }
            if (yParity != null) {
              switch ((0, index_js_2.getNumber)(yParity, "sig.yParity")) {
                case 0:
                  return {
                    v: 27
                  };
                case 1:
                  return {
                    v: 28
                  };
              }
              assertError(false, "invalid yParity");
            }
            assertError(false, "missing v");
          }(sig.v, sig.yParityAndS, sig.yParity);
          const result = new Signature(_guard, r, s, v);
          if (networkV) {
            result.#networkV = networkV;
          }
          assertError(sig.yParity == null || (0, index_js_2.getNumber)(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
          assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
          return result;
        }
      }
      exports.Signature = Signature;
    },
    794: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SigningKey = void 0;
      const tslib_1 = __webpack_require__(2003);
      const secp256k1 = tslib_1.__importStar(__webpack_require__(6698));
      const index_js_1 = __webpack_require__(9830);
      const hmac_js_1 = __webpack_require__(8237);
      const signature_js_1 = __webpack_require__(9102);
      secp256k1.utils.hmacSha256Sync = function (key, ...messages) {
        return (0, index_js_1.getBytes)((0, hmac_js_1.computeHmac)("sha256", key, (0, index_js_1.concat)(messages)));
      };
      class SigningKey {
        #privateKey;
        constructor(privateKey) {
          (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
          this.#privateKey = (0, index_js_1.hexlify)(privateKey);
        }
        get privateKey() {
          return this.#privateKey;
        }
        get publicKey() {
          return SigningKey.computePublicKey(this.#privateKey);
        }
        get compressedPublicKey() {
          return SigningKey.computePublicKey(this.#privateKey, true);
        }
        sign(digest) {
          (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
          const [sigDer, recid] = secp256k1.signSync((0, index_js_1.getBytesCopy)(digest), (0, index_js_1.getBytesCopy)(this.#privateKey), {
            recovered: true,
            canonical: true
          });
          const sig = secp256k1.Signature.fromHex(sigDer);
          return signature_js_1.Signature.from({
            r: (0, index_js_1.toBeHex)("0x" + sig.r.toString(16), 32),
            s: (0, index_js_1.toBeHex)("0x" + sig.s.toString(16), 32),
            v: recid ? 0x1c : 0x1b
          });
        }
        computeSharedSecret(other) {
          const pubKey = SigningKey.computePublicKey(other);
          return (0, index_js_1.hexlify)(secp256k1.getSharedSecret((0, index_js_1.getBytesCopy)(this.#privateKey), (0, index_js_1.getBytes)(pubKey)));
        }
        static computePublicKey(key, compressed) {
          let bytes = (0, index_js_1.getBytes)(key, "key");
          if (bytes.length === 32) {
            const pubKey = secp256k1.getPublicKey(bytes, !!compressed);
            return (0, index_js_1.hexlify)(pubKey);
          }
          if (bytes.length === 64) {
            const pub = new Uint8Array(65);
            pub[0] = 0x04;
            pub.set(bytes, 1);
            bytes = pub;
          }
          const point = secp256k1.Point.fromHex(bytes);
          return (0, index_js_1.hexlify)(point.toRawBytes(compressed));
        }
        static recoverPublicKey(digest, signature) {
          (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
          const sig = signature_js_1.Signature.from(signature);
          const der = secp256k1.Signature.fromCompact((0, index_js_1.getBytesCopy)((0, index_js_1.concat)([sig.r, sig.s]))).toDERRawBytes();
          const pubKey = secp256k1.recoverPublicKey((0, index_js_1.getBytesCopy)(digest), der, sig.yParity);
          (0, index_js_1.assertArgument)(pubKey != null, "invalid signature for digest", "signature", signature);
          return (0, index_js_1.hexlify)(pubKey);
        }
        static addPoints(p0, p1, compressed) {
          const pub0 = secp256k1.Point.fromHex(SigningKey.computePublicKey(p0).substring(2));
          const pub1 = secp256k1.Point.fromHex(SigningKey.computePublicKey(p1).substring(2));
          return "0x" + pub0.add(pub1).toHex(!!compressed);
        }
      }
      exports.SigningKey = SigningKey;
    },
    2261: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = exports.UndecodedEventLog = exports.EventLog = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.MessagePrefix = exports.EtherSymbol = exports.ZeroHash = exports.N = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.ZeroAddress = exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = exports.Typed = exports.TransactionDescription = exports.Result = exports.LogDescription = exports.Interface = exports.Indexed = exports.ErrorDescription = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.FallbackFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.AbiCoder = exports.encodeBytes32String = exports.decodeBytes32String = exports.version = void 0;
      exports.EtherscanPlugin = exports.EnsPlugin = exports.Network = exports.EnsResolver = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.AbstractProvider = exports.VoidSigner = exports.NonceManager = exports.AbstractSigner = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.getDefaultProvider = exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = exports.SigningKey = exports.Signature = exports.lock = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = void 0;
      exports.toBeArray = exports.getUint = exports.getNumber = exports.getBigInt = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.isError = exports.isCallException = exports.makeError = exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.resolveProperties = exports.defineProperties = exports.zeroPadValue = exports.zeroPadBytes = exports.stripZerosLeft = exports.isBytesLike = exports.isHexString = exports.hexlify = exports.getBytesCopy = exports.getBytes = exports.dataSlice = exports.dataLength = exports.concat = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = exports.showThrottleMessage = exports.copyRequest = exports.UnmanagedSubscriber = exports.SocketSubscriber = exports.SocketPendingSubscriber = exports.SocketEventSubscriber = exports.SocketBlockSubscriber = exports.MulticoinProviderPlugin = exports.NetworkPlugin = exports.GasCostPlugin = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = void 0;
      exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.decryptCrowdsaleJson = exports.isKeystoreJson = exports.isCrowdsaleJson = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.Wallet = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.BaseWallet = exports.Mnemonic = exports.uuidV4 = exports.encodeRlp = exports.decodeRlp = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.mask = exports.toTwos = exports.fromTwos = exports.toQuantity = exports.toNumber = exports.toBeHex = exports.toBigInt = void 0;
      var _version_js_1 = __webpack_require__(9737);
      Object.defineProperty(exports, "version", {
        enumerable: true,
        get: function () {
          return _version_js_1.version;
        }
      });
      var index_js_1 = __webpack_require__(5262);
      Object.defineProperty(exports, "decodeBytes32String", {
        enumerable: true,
        get: function () {
          return index_js_1.decodeBytes32String;
        }
      });
      Object.defineProperty(exports, "encodeBytes32String", {
        enumerable: true,
        get: function () {
          return index_js_1.encodeBytes32String;
        }
      });
      Object.defineProperty(exports, "AbiCoder", {
        enumerable: true,
        get: function () {
          return index_js_1.AbiCoder;
        }
      });
      Object.defineProperty(exports, "ConstructorFragment", {
        enumerable: true,
        get: function () {
          return index_js_1.ConstructorFragment;
        }
      });
      Object.defineProperty(exports, "ErrorFragment", {
        enumerable: true,
        get: function () {
          return index_js_1.ErrorFragment;
        }
      });
      Object.defineProperty(exports, "EventFragment", {
        enumerable: true,
        get: function () {
          return index_js_1.EventFragment;
        }
      });
      Object.defineProperty(exports, "Fragment", {
        enumerable: true,
        get: function () {
          return index_js_1.Fragment;
        }
      });
      Object.defineProperty(exports, "FallbackFragment", {
        enumerable: true,
        get: function () {
          return index_js_1.FallbackFragment;
        }
      });
      Object.defineProperty(exports, "FunctionFragment", {
        enumerable: true,
        get: function () {
          return index_js_1.FunctionFragment;
        }
      });
      Object.defineProperty(exports, "NamedFragment", {
        enumerable: true,
        get: function () {
          return index_js_1.NamedFragment;
        }
      });
      Object.defineProperty(exports, "ParamType", {
        enumerable: true,
        get: function () {
          return index_js_1.ParamType;
        }
      });
      Object.defineProperty(exports, "StructFragment", {
        enumerable: true,
        get: function () {
          return index_js_1.StructFragment;
        }
      });
      Object.defineProperty(exports, "checkResultErrors", {
        enumerable: true,
        get: function () {
          return index_js_1.checkResultErrors;
        }
      });
      Object.defineProperty(exports, "ErrorDescription", {
        enumerable: true,
        get: function () {
          return index_js_1.ErrorDescription;
        }
      });
      Object.defineProperty(exports, "Indexed", {
        enumerable: true,
        get: function () {
          return index_js_1.Indexed;
        }
      });
      Object.defineProperty(exports, "Interface", {
        enumerable: true,
        get: function () {
          return index_js_1.Interface;
        }
      });
      Object.defineProperty(exports, "LogDescription", {
        enumerable: true,
        get: function () {
          return index_js_1.LogDescription;
        }
      });
      Object.defineProperty(exports, "Result", {
        enumerable: true,
        get: function () {
          return index_js_1.Result;
        }
      });
      Object.defineProperty(exports, "TransactionDescription", {
        enumerable: true,
        get: function () {
          return index_js_1.TransactionDescription;
        }
      });
      Object.defineProperty(exports, "Typed", {
        enumerable: true,
        get: function () {
          return index_js_1.Typed;
        }
      });
      var index_js_2 = __webpack_require__(2134);
      Object.defineProperty(exports, "getAddress", {
        enumerable: true,
        get: function () {
          return index_js_2.getAddress;
        }
      });
      Object.defineProperty(exports, "getIcapAddress", {
        enumerable: true,
        get: function () {
          return index_js_2.getIcapAddress;
        }
      });
      Object.defineProperty(exports, "getCreateAddress", {
        enumerable: true,
        get: function () {
          return index_js_2.getCreateAddress;
        }
      });
      Object.defineProperty(exports, "getCreate2Address", {
        enumerable: true,
        get: function () {
          return index_js_2.getCreate2Address;
        }
      });
      Object.defineProperty(exports, "isAddressable", {
        enumerable: true,
        get: function () {
          return index_js_2.isAddressable;
        }
      });
      Object.defineProperty(exports, "isAddress", {
        enumerable: true,
        get: function () {
          return index_js_2.isAddress;
        }
      });
      Object.defineProperty(exports, "resolveAddress", {
        enumerable: true,
        get: function () {
          return index_js_2.resolveAddress;
        }
      });
      var index_js_3 = __webpack_require__(4160);
      Object.defineProperty(exports, "ZeroAddress", {
        enumerable: true,
        get: function () {
          return index_js_3.ZeroAddress;
        }
      });
      Object.defineProperty(exports, "WeiPerEther", {
        enumerable: true,
        get: function () {
          return index_js_3.WeiPerEther;
        }
      });
      Object.defineProperty(exports, "MaxUint256", {
        enumerable: true,
        get: function () {
          return index_js_3.MaxUint256;
        }
      });
      Object.defineProperty(exports, "MinInt256", {
        enumerable: true,
        get: function () {
          return index_js_3.MinInt256;
        }
      });
      Object.defineProperty(exports, "MaxInt256", {
        enumerable: true,
        get: function () {
          return index_js_3.MaxInt256;
        }
      });
      Object.defineProperty(exports, "N", {
        enumerable: true,
        get: function () {
          return index_js_3.N;
        }
      });
      Object.defineProperty(exports, "ZeroHash", {
        enumerable: true,
        get: function () {
          return index_js_3.ZeroHash;
        }
      });
      Object.defineProperty(exports, "EtherSymbol", {
        enumerable: true,
        get: function () {
          return index_js_3.EtherSymbol;
        }
      });
      Object.defineProperty(exports, "MessagePrefix", {
        enumerable: true,
        get: function () {
          return index_js_3.MessagePrefix;
        }
      });
      var index_js_4 = __webpack_require__(4464);
      Object.defineProperty(exports, "BaseContract", {
        enumerable: true,
        get: function () {
          return index_js_4.BaseContract;
        }
      });
      Object.defineProperty(exports, "Contract", {
        enumerable: true,
        get: function () {
          return index_js_4.Contract;
        }
      });
      Object.defineProperty(exports, "ContractFactory", {
        enumerable: true,
        get: function () {
          return index_js_4.ContractFactory;
        }
      });
      Object.defineProperty(exports, "ContractEventPayload", {
        enumerable: true,
        get: function () {
          return index_js_4.ContractEventPayload;
        }
      });
      Object.defineProperty(exports, "ContractTransactionReceipt", {
        enumerable: true,
        get: function () {
          return index_js_4.ContractTransactionReceipt;
        }
      });
      Object.defineProperty(exports, "ContractTransactionResponse", {
        enumerable: true,
        get: function () {
          return index_js_4.ContractTransactionResponse;
        }
      });
      Object.defineProperty(exports, "ContractUnknownEventPayload", {
        enumerable: true,
        get: function () {
          return index_js_4.ContractUnknownEventPayload;
        }
      });
      Object.defineProperty(exports, "EventLog", {
        enumerable: true,
        get: function () {
          return index_js_4.EventLog;
        }
      });
      Object.defineProperty(exports, "UndecodedEventLog", {
        enumerable: true,
        get: function () {
          return index_js_4.UndecodedEventLog;
        }
      });
      var index_js_5 = __webpack_require__(9420);
      Object.defineProperty(exports, "computeHmac", {
        enumerable: true,
        get: function () {
          return index_js_5.computeHmac;
        }
      });
      Object.defineProperty(exports, "randomBytes", {
        enumerable: true,
        get: function () {
          return index_js_5.randomBytes;
        }
      });
      Object.defineProperty(exports, "keccak256", {
        enumerable: true,
        get: function () {
          return index_js_5.keccak256;
        }
      });
      Object.defineProperty(exports, "ripemd160", {
        enumerable: true,
        get: function () {
          return index_js_5.ripemd160;
        }
      });
      Object.defineProperty(exports, "sha256", {
        enumerable: true,
        get: function () {
          return index_js_5.sha256;
        }
      });
      Object.defineProperty(exports, "sha512", {
        enumerable: true,
        get: function () {
          return index_js_5.sha512;
        }
      });
      Object.defineProperty(exports, "pbkdf2", {
        enumerable: true,
        get: function () {
          return index_js_5.pbkdf2;
        }
      });
      Object.defineProperty(exports, "scrypt", {
        enumerable: true,
        get: function () {
          return index_js_5.scrypt;
        }
      });
      Object.defineProperty(exports, "scryptSync", {
        enumerable: true,
        get: function () {
          return index_js_5.scryptSync;
        }
      });
      Object.defineProperty(exports, "lock", {
        enumerable: true,
        get: function () {
          return index_js_5.lock;
        }
      });
      Object.defineProperty(exports, "Signature", {
        enumerable: true,
        get: function () {
          return index_js_5.Signature;
        }
      });
      Object.defineProperty(exports, "SigningKey", {
        enumerable: true,
        get: function () {
          return index_js_5.SigningKey;
        }
      });
      var index_js_6 = __webpack_require__(5714);
      Object.defineProperty(exports, "id", {
        enumerable: true,
        get: function () {
          return index_js_6.id;
        }
      });
      Object.defineProperty(exports, "ensNormalize", {
        enumerable: true,
        get: function () {
          return index_js_6.ensNormalize;
        }
      });
      Object.defineProperty(exports, "isValidName", {
        enumerable: true,
        get: function () {
          return index_js_6.isValidName;
        }
      });
      Object.defineProperty(exports, "namehash", {
        enumerable: true,
        get: function () {
          return index_js_6.namehash;
        }
      });
      Object.defineProperty(exports, "dnsEncode", {
        enumerable: true,
        get: function () {
          return index_js_6.dnsEncode;
        }
      });
      Object.defineProperty(exports, "hashMessage", {
        enumerable: true,
        get: function () {
          return index_js_6.hashMessage;
        }
      });
      Object.defineProperty(exports, "verifyMessage", {
        enumerable: true,
        get: function () {
          return index_js_6.verifyMessage;
        }
      });
      Object.defineProperty(exports, "solidityPacked", {
        enumerable: true,
        get: function () {
          return index_js_6.solidityPacked;
        }
      });
      Object.defineProperty(exports, "solidityPackedKeccak256", {
        enumerable: true,
        get: function () {
          return index_js_6.solidityPackedKeccak256;
        }
      });
      Object.defineProperty(exports, "solidityPackedSha256", {
        enumerable: true,
        get: function () {
          return index_js_6.solidityPackedSha256;
        }
      });
      Object.defineProperty(exports, "TypedDataEncoder", {
        enumerable: true,
        get: function () {
          return index_js_6.TypedDataEncoder;
        }
      });
      Object.defineProperty(exports, "verifyTypedData", {
        enumerable: true,
        get: function () {
          return index_js_6.verifyTypedData;
        }
      });
      var index_js_7 = __webpack_require__(3898);
      Object.defineProperty(exports, "getDefaultProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.getDefaultProvider;
        }
      });
      Object.defineProperty(exports, "Block", {
        enumerable: true,
        get: function () {
          return index_js_7.Block;
        }
      });
      Object.defineProperty(exports, "FeeData", {
        enumerable: true,
        get: function () {
          return index_js_7.FeeData;
        }
      });
      Object.defineProperty(exports, "Log", {
        enumerable: true,
        get: function () {
          return index_js_7.Log;
        }
      });
      Object.defineProperty(exports, "TransactionReceipt", {
        enumerable: true,
        get: function () {
          return index_js_7.TransactionReceipt;
        }
      });
      Object.defineProperty(exports, "TransactionResponse", {
        enumerable: true,
        get: function () {
          return index_js_7.TransactionResponse;
        }
      });
      Object.defineProperty(exports, "AbstractSigner", {
        enumerable: true,
        get: function () {
          return index_js_7.AbstractSigner;
        }
      });
      Object.defineProperty(exports, "NonceManager", {
        enumerable: true,
        get: function () {
          return index_js_7.NonceManager;
        }
      });
      Object.defineProperty(exports, "VoidSigner", {
        enumerable: true,
        get: function () {
          return index_js_7.VoidSigner;
        }
      });
      Object.defineProperty(exports, "AbstractProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.AbstractProvider;
        }
      });
      Object.defineProperty(exports, "FallbackProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.FallbackProvider;
        }
      });
      Object.defineProperty(exports, "JsonRpcApiProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.JsonRpcApiProvider;
        }
      });
      Object.defineProperty(exports, "JsonRpcProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.JsonRpcProvider;
        }
      });
      Object.defineProperty(exports, "JsonRpcSigner", {
        enumerable: true,
        get: function () {
          return index_js_7.JsonRpcSigner;
        }
      });
      Object.defineProperty(exports, "BrowserProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.BrowserProvider;
        }
      });
      Object.defineProperty(exports, "AlchemyProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.AlchemyProvider;
        }
      });
      Object.defineProperty(exports, "AnkrProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.AnkrProvider;
        }
      });
      Object.defineProperty(exports, "CloudflareProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.CloudflareProvider;
        }
      });
      Object.defineProperty(exports, "EtherscanProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.EtherscanProvider;
        }
      });
      Object.defineProperty(exports, "InfuraProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.InfuraProvider;
        }
      });
      Object.defineProperty(exports, "InfuraWebSocketProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.InfuraWebSocketProvider;
        }
      });
      Object.defineProperty(exports, "PocketProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.PocketProvider;
        }
      });
      Object.defineProperty(exports, "QuickNodeProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.QuickNodeProvider;
        }
      });
      Object.defineProperty(exports, "IpcSocketProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.IpcSocketProvider;
        }
      });
      Object.defineProperty(exports, "SocketProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.SocketProvider;
        }
      });
      Object.defineProperty(exports, "WebSocketProvider", {
        enumerable: true,
        get: function () {
          return index_js_7.WebSocketProvider;
        }
      });
      Object.defineProperty(exports, "EnsResolver", {
        enumerable: true,
        get: function () {
          return index_js_7.EnsResolver;
        }
      });
      Object.defineProperty(exports, "Network", {
        enumerable: true,
        get: function () {
          return index_js_7.Network;
        }
      });
      Object.defineProperty(exports, "EnsPlugin", {
        enumerable: true,
        get: function () {
          return index_js_7.EnsPlugin;
        }
      });
      Object.defineProperty(exports, "EtherscanPlugin", {
        enumerable: true,
        get: function () {
          return index_js_7.EtherscanPlugin;
        }
      });
      Object.defineProperty(exports, "FeeDataNetworkPlugin", {
        enumerable: true,
        get: function () {
          return index_js_7.FeeDataNetworkPlugin;
        }
      });
      Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", {
        enumerable: true,
        get: function () {
          return index_js_7.FetchUrlFeeDataNetworkPlugin;
        }
      });
      Object.defineProperty(exports, "GasCostPlugin", {
        enumerable: true,
        get: function () {
          return index_js_7.GasCostPlugin;
        }
      });
      Object.defineProperty(exports, "NetworkPlugin", {
        enumerable: true,
        get: function () {
          return index_js_7.NetworkPlugin;
        }
      });
      Object.defineProperty(exports, "MulticoinProviderPlugin", {
        enumerable: true,
        get: function () {
          return index_js_7.MulticoinProviderPlugin;
        }
      });
      Object.defineProperty(exports, "SocketBlockSubscriber", {
        enumerable: true,
        get: function () {
          return index_js_7.SocketBlockSubscriber;
        }
      });
      Object.defineProperty(exports, "SocketEventSubscriber", {
        enumerable: true,
        get: function () {
          return index_js_7.SocketEventSubscriber;
        }
      });
      Object.defineProperty(exports, "SocketPendingSubscriber", {
        enumerable: true,
        get: function () {
          return index_js_7.SocketPendingSubscriber;
        }
      });
      Object.defineProperty(exports, "SocketSubscriber", {
        enumerable: true,
        get: function () {
          return index_js_7.SocketSubscriber;
        }
      });
      Object.defineProperty(exports, "UnmanagedSubscriber", {
        enumerable: true,
        get: function () {
          return index_js_7.UnmanagedSubscriber;
        }
      });
      Object.defineProperty(exports, "copyRequest", {
        enumerable: true,
        get: function () {
          return index_js_7.copyRequest;
        }
      });
      Object.defineProperty(exports, "showThrottleMessage", {
        enumerable: true,
        get: function () {
          return index_js_7.showThrottleMessage;
        }
      });
      var index_js_8 = __webpack_require__(2877);
      Object.defineProperty(exports, "accessListify", {
        enumerable: true,
        get: function () {
          return index_js_8.accessListify;
        }
      });
      Object.defineProperty(exports, "computeAddress", {
        enumerable: true,
        get: function () {
          return index_js_8.computeAddress;
        }
      });
      Object.defineProperty(exports, "recoverAddress", {
        enumerable: true,
        get: function () {
          return index_js_8.recoverAddress;
        }
      });
      Object.defineProperty(exports, "Transaction", {
        enumerable: true,
        get: function () {
          return index_js_8.Transaction;
        }
      });
      var index_js_9 = __webpack_require__(9830);
      Object.defineProperty(exports, "decodeBase58", {
        enumerable: true,
        get: function () {
          return index_js_9.decodeBase58;
        }
      });
      Object.defineProperty(exports, "encodeBase58", {
        enumerable: true,
        get: function () {
          return index_js_9.encodeBase58;
        }
      });
      Object.defineProperty(exports, "decodeBase64", {
        enumerable: true,
        get: function () {
          return index_js_9.decodeBase64;
        }
      });
      Object.defineProperty(exports, "encodeBase64", {
        enumerable: true,
        get: function () {
          return index_js_9.encodeBase64;
        }
      });
      Object.defineProperty(exports, "concat", {
        enumerable: true,
        get: function () {
          return index_js_9.concat;
        }
      });
      Object.defineProperty(exports, "dataLength", {
        enumerable: true,
        get: function () {
          return index_js_9.dataLength;
        }
      });
      Object.defineProperty(exports, "dataSlice", {
        enumerable: true,
        get: function () {
          return index_js_9.dataSlice;
        }
      });
      Object.defineProperty(exports, "getBytes", {
        enumerable: true,
        get: function () {
          return index_js_9.getBytes;
        }
      });
      Object.defineProperty(exports, "getBytesCopy", {
        enumerable: true,
        get: function () {
          return index_js_9.getBytesCopy;
        }
      });
      Object.defineProperty(exports, "hexlify", {
        enumerable: true,
        get: function () {
          return index_js_9.hexlify;
        }
      });
      Object.defineProperty(exports, "isHexString", {
        enumerable: true,
        get: function () {
          return index_js_9.isHexString;
        }
      });
      Object.defineProperty(exports, "isBytesLike", {
        enumerable: true,
        get: function () {
          return index_js_9.isBytesLike;
        }
      });
      Object.defineProperty(exports, "stripZerosLeft", {
        enumerable: true,
        get: function () {
          return index_js_9.stripZerosLeft;
        }
      });
      Object.defineProperty(exports, "zeroPadBytes", {
        enumerable: true,
        get: function () {
          return index_js_9.zeroPadBytes;
        }
      });
      Object.defineProperty(exports, "zeroPadValue", {
        enumerable: true,
        get: function () {
          return index_js_9.zeroPadValue;
        }
      });
      Object.defineProperty(exports, "defineProperties", {
        enumerable: true,
        get: function () {
          return index_js_9.defineProperties;
        }
      });
      Object.defineProperty(exports, "resolveProperties", {
        enumerable: true,
        get: function () {
          return index_js_9.resolveProperties;
        }
      });
      Object.defineProperty(exports, "assert", {
        enumerable: true,
        get: function () {
          return index_js_9.assert;
        }
      });
      Object.defineProperty(exports, "assertArgument", {
        enumerable: true,
        get: function () {
          return index_js_9.assertArgument;
        }
      });
      Object.defineProperty(exports, "assertArgumentCount", {
        enumerable: true,
        get: function () {
          return index_js_9.assertArgumentCount;
        }
      });
      Object.defineProperty(exports, "assertNormalize", {
        enumerable: true,
        get: function () {
          return index_js_9.assertNormalize;
        }
      });
      Object.defineProperty(exports, "assertPrivate", {
        enumerable: true,
        get: function () {
          return index_js_9.assertPrivate;
        }
      });
      Object.defineProperty(exports, "makeError", {
        enumerable: true,
        get: function () {
          return index_js_9.makeError;
        }
      });
      Object.defineProperty(exports, "isCallException", {
        enumerable: true,
        get: function () {
          return index_js_9.isCallException;
        }
      });
      Object.defineProperty(exports, "isError", {
        enumerable: true,
        get: function () {
          return index_js_9.isError;
        }
      });
      Object.defineProperty(exports, "EventPayload", {
        enumerable: true,
        get: function () {
          return index_js_9.EventPayload;
        }
      });
      Object.defineProperty(exports, "FetchRequest", {
        enumerable: true,
        get: function () {
          return index_js_9.FetchRequest;
        }
      });
      Object.defineProperty(exports, "FetchResponse", {
        enumerable: true,
        get: function () {
          return index_js_9.FetchResponse;
        }
      });
      Object.defineProperty(exports, "FetchCancelSignal", {
        enumerable: true,
        get: function () {
          return index_js_9.FetchCancelSignal;
        }
      });
      Object.defineProperty(exports, "FixedNumber", {
        enumerable: true,
        get: function () {
          return index_js_9.FixedNumber;
        }
      });
      Object.defineProperty(exports, "getBigInt", {
        enumerable: true,
        get: function () {
          return index_js_9.getBigInt;
        }
      });
      Object.defineProperty(exports, "getNumber", {
        enumerable: true,
        get: function () {
          return index_js_9.getNumber;
        }
      });
      Object.defineProperty(exports, "getUint", {
        enumerable: true,
        get: function () {
          return index_js_9.getUint;
        }
      });
      Object.defineProperty(exports, "toBeArray", {
        enumerable: true,
        get: function () {
          return index_js_9.toBeArray;
        }
      });
      Object.defineProperty(exports, "toBigInt", {
        enumerable: true,
        get: function () {
          return index_js_9.toBigInt;
        }
      });
      Object.defineProperty(exports, "toBeHex", {
        enumerable: true,
        get: function () {
          return index_js_9.toBeHex;
        }
      });
      Object.defineProperty(exports, "toNumber", {
        enumerable: true,
        get: function () {
          return index_js_9.toNumber;
        }
      });
      Object.defineProperty(exports, "toQuantity", {
        enumerable: true,
        get: function () {
          return index_js_9.toQuantity;
        }
      });
      Object.defineProperty(exports, "fromTwos", {
        enumerable: true,
        get: function () {
          return index_js_9.fromTwos;
        }
      });
      Object.defineProperty(exports, "toTwos", {
        enumerable: true,
        get: function () {
          return index_js_9.toTwos;
        }
      });
      Object.defineProperty(exports, "mask", {
        enumerable: true,
        get: function () {
          return index_js_9.mask;
        }
      });
      Object.defineProperty(exports, "formatEther", {
        enumerable: true,
        get: function () {
          return index_js_9.formatEther;
        }
      });
      Object.defineProperty(exports, "parseEther", {
        enumerable: true,
        get: function () {
          return index_js_9.parseEther;
        }
      });
      Object.defineProperty(exports, "formatUnits", {
        enumerable: true,
        get: function () {
          return index_js_9.formatUnits;
        }
      });
      Object.defineProperty(exports, "parseUnits", {
        enumerable: true,
        get: function () {
          return index_js_9.parseUnits;
        }
      });
      Object.defineProperty(exports, "toUtf8Bytes", {
        enumerable: true,
        get: function () {
          return index_js_9.toUtf8Bytes;
        }
      });
      Object.defineProperty(exports, "toUtf8CodePoints", {
        enumerable: true,
        get: function () {
          return index_js_9.toUtf8CodePoints;
        }
      });
      Object.defineProperty(exports, "toUtf8String", {
        enumerable: true,
        get: function () {
          return index_js_9.toUtf8String;
        }
      });
      Object.defineProperty(exports, "Utf8ErrorFuncs", {
        enumerable: true,
        get: function () {
          return index_js_9.Utf8ErrorFuncs;
        }
      });
      Object.defineProperty(exports, "decodeRlp", {
        enumerable: true,
        get: function () {
          return index_js_9.decodeRlp;
        }
      });
      Object.defineProperty(exports, "encodeRlp", {
        enumerable: true,
        get: function () {
          return index_js_9.encodeRlp;
        }
      });
      Object.defineProperty(exports, "uuidV4", {
        enumerable: true,
        get: function () {
          return index_js_9.uuidV4;
        }
      });
      var index_js_10 = __webpack_require__(4794);
      Object.defineProperty(exports, "Mnemonic", {
        enumerable: true,
        get: function () {
          return index_js_10.Mnemonic;
        }
      });
      Object.defineProperty(exports, "BaseWallet", {
        enumerable: true,
        get: function () {
          return index_js_10.BaseWallet;
        }
      });
      Object.defineProperty(exports, "HDNodeWallet", {
        enumerable: true,
        get: function () {
          return index_js_10.HDNodeWallet;
        }
      });
      Object.defineProperty(exports, "HDNodeVoidWallet", {
        enumerable: true,
        get: function () {
          return index_js_10.HDNodeVoidWallet;
        }
      });
      Object.defineProperty(exports, "Wallet", {
        enumerable: true,
        get: function () {
          return index_js_10.Wallet;
        }
      });
      Object.defineProperty(exports, "defaultPath", {
        enumerable: true,
        get: function () {
          return index_js_10.defaultPath;
        }
      });
      Object.defineProperty(exports, "getAccountPath", {
        enumerable: true,
        get: function () {
          return index_js_10.getAccountPath;
        }
      });
      Object.defineProperty(exports, "getIndexedAccountPath", {
        enumerable: true,
        get: function () {
          return index_js_10.getIndexedAccountPath;
        }
      });
      Object.defineProperty(exports, "isCrowdsaleJson", {
        enumerable: true,
        get: function () {
          return index_js_10.isCrowdsaleJson;
        }
      });
      Object.defineProperty(exports, "isKeystoreJson", {
        enumerable: true,
        get: function () {
          return index_js_10.isKeystoreJson;
        }
      });
      Object.defineProperty(exports, "decryptCrowdsaleJson", {
        enumerable: true,
        get: function () {
          return index_js_10.decryptCrowdsaleJson;
        }
      });
      Object.defineProperty(exports, "decryptKeystoreJsonSync", {
        enumerable: true,
        get: function () {
          return index_js_10.decryptKeystoreJsonSync;
        }
      });
      Object.defineProperty(exports, "decryptKeystoreJson", {
        enumerable: true,
        get: function () {
          return index_js_10.decryptKeystoreJson;
        }
      });
      Object.defineProperty(exports, "encryptKeystoreJson", {
        enumerable: true,
        get: function () {
          return index_js_10.encryptKeystoreJson;
        }
      });
      Object.defineProperty(exports, "encryptKeystoreJsonSync", {
        enumerable: true,
        get: function () {
          return index_js_10.encryptKeystoreJsonSync;
        }
      });
      var index_js_11 = __webpack_require__(4574);
      Object.defineProperty(exports, "Wordlist", {
        enumerable: true,
        get: function () {
          return index_js_11.Wordlist;
        }
      });
      Object.defineProperty(exports, "LangEn", {
        enumerable: true,
        get: function () {
          return index_js_11.LangEn;
        }
      });
      Object.defineProperty(exports, "WordlistOwl", {
        enumerable: true,
        get: function () {
          return index_js_11.WordlistOwl;
        }
      });
      Object.defineProperty(exports, "WordlistOwlA", {
        enumerable: true,
        get: function () {
          return index_js_11.WordlistOwlA;
        }
      });
      Object.defineProperty(exports, "wordlists", {
        enumerable: true,
        get: function () {
          return index_js_11.wordlists;
        }
      });
    },
    6548: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.id = void 0;
      const index_js_1 = __webpack_require__(9420);
      const index_js_2 = __webpack_require__(9830);
      function id(value) {
        return (0, index_js_1.keccak256)((0, index_js_2.toUtf8Bytes)(value));
      }
      exports.id = id;
    },
    5714: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = void 0;
      var id_js_1 = __webpack_require__(6548);
      Object.defineProperty(exports, "id", {
        enumerable: true,
        get: function () {
          return id_js_1.id;
        }
      });
      var namehash_js_1 = __webpack_require__(7942);
      Object.defineProperty(exports, "ensNormalize", {
        enumerable: true,
        get: function () {
          return namehash_js_1.ensNormalize;
        }
      });
      Object.defineProperty(exports, "isValidName", {
        enumerable: true,
        get: function () {
          return namehash_js_1.isValidName;
        }
      });
      Object.defineProperty(exports, "namehash", {
        enumerable: true,
        get: function () {
          return namehash_js_1.namehash;
        }
      });
      Object.defineProperty(exports, "dnsEncode", {
        enumerable: true,
        get: function () {
          return namehash_js_1.dnsEncode;
        }
      });
      var message_js_1 = __webpack_require__(6452);
      Object.defineProperty(exports, "hashMessage", {
        enumerable: true,
        get: function () {
          return message_js_1.hashMessage;
        }
      });
      Object.defineProperty(exports, "verifyMessage", {
        enumerable: true,
        get: function () {
          return message_js_1.verifyMessage;
        }
      });
      var solidity_js_1 = __webpack_require__(4810);
      Object.defineProperty(exports, "solidityPacked", {
        enumerable: true,
        get: function () {
          return solidity_js_1.solidityPacked;
        }
      });
      Object.defineProperty(exports, "solidityPackedKeccak256", {
        enumerable: true,
        get: function () {
          return solidity_js_1.solidityPackedKeccak256;
        }
      });
      Object.defineProperty(exports, "solidityPackedSha256", {
        enumerable: true,
        get: function () {
          return solidity_js_1.solidityPackedSha256;
        }
      });
      var typed_data_js_1 = __webpack_require__(1818);
      Object.defineProperty(exports, "TypedDataEncoder", {
        enumerable: true,
        get: function () {
          return typed_data_js_1.TypedDataEncoder;
        }
      });
      Object.defineProperty(exports, "verifyTypedData", {
        enumerable: true,
        get: function () {
          return typed_data_js_1.verifyTypedData;
        }
      });
    },
    6452: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.verifyMessage = exports.hashMessage = void 0;
      const index_js_1 = __webpack_require__(9420);
      const index_js_2 = __webpack_require__(4160);
      const index_js_3 = __webpack_require__(2877);
      const index_js_4 = __webpack_require__(9830);
      function hashMessage(message) {
        if (typeof message === "string") {
          message = (0, index_js_4.toUtf8Bytes)(message);
        }
        return (0, index_js_1.keccak256)((0, index_js_4.concat)([(0, index_js_4.toUtf8Bytes)(index_js_2.MessagePrefix), (0, index_js_4.toUtf8Bytes)(String(message.length)), message]));
      }
      exports.hashMessage = hashMessage;
      function verifyMessage(message, sig) {
        const digest = hashMessage(message);
        return (0, index_js_3.recoverAddress)(digest, sig);
      }
      exports.verifyMessage = verifyMessage;
    },
    7942: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;
      const index_js_1 = __webpack_require__(9420);
      const index_js_2 = __webpack_require__(9830);
      const ens_normalize_1 = __webpack_require__(6608);
      const Zeros = new Uint8Array(32);
      Zeros.fill(0);
      function checkComponent(comp) {
        (0, index_js_2.assertArgument)(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
        return comp;
      }
      function ensNameSplit(name) {
        const bytes = (0, index_js_2.toUtf8Bytes)(ensNormalize(name));
        const comps = [];
        if (name.length === 0) {
          return comps;
        }
        let last = 0;
        for (let i = 0; i < bytes.length; i++) {
          const d = bytes[i];
          if (d === 0x2e) {
            comps.push(checkComponent(bytes.slice(last, i)));
            last = i + 1;
          }
        }
        (0, index_js_2.assertArgument)(last < bytes.length, "invalid ENS name; empty component", "name", name);
        comps.push(checkComponent(bytes.slice(last)));
        return comps;
      }
      function ensNormalize(name) {
        try {
          return (0, ens_normalize_1.ens_normalize)(name);
        } catch (error) {
          (0, index_js_2.assertArgument)(false, `invalid ENS name (${error.message})`, "name", name);
        }
      }
      exports.ensNormalize = ensNormalize;
      function isValidName(name) {
        try {
          return ensNameSplit(name).length !== 0;
        } catch (error) {}
        return false;
      }
      exports.isValidName = isValidName;
      function namehash(name) {
        (0, index_js_2.assertArgument)(typeof name === "string", "invalid ENS name; not a string", "name", name);
        let result = Zeros;
        const comps = ensNameSplit(name);
        while (comps.length) {
          result = (0, index_js_1.keccak256)((0, index_js_2.concat)([result, (0, index_js_1.keccak256)(comps.pop())]));
        }
        return (0, index_js_2.hexlify)(result);
      }
      exports.namehash = namehash;
      function dnsEncode(name) {
        return (0, index_js_2.hexlify)((0, index_js_2.concat)(ensNameSplit(name).map(comp => {
          if (comp.length > 63) {
            throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
          }
          const bytes = new Uint8Array(comp.length + 1);
          bytes.set(comp, 1);
          bytes[0] = bytes.length - 1;
          return bytes;
        }))) + "00";
      }
      exports.dnsEncode = dnsEncode;
    },
    4810: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(9420);
      const index_js_3 = __webpack_require__(9830);
      const regexBytes = new RegExp("^bytes([0-9]+)$");
      const regexNumber = new RegExp("^(u?int)([0-9]*)$");
      const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
      function _pack(type, value, isArray) {
        switch (type) {
          case "address":
            if (isArray) {
              return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
            }
            return (0, index_js_3.getBytes)((0, index_js_1.getAddress)(value));
          case "string":
            return (0, index_js_3.toUtf8Bytes)(value);
          case "bytes":
            return (0, index_js_3.getBytes)(value);
          case "bool":
            value = !!value ? "0x01" : "0x00";
            if (isArray) {
              return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
            }
            return (0, index_js_3.getBytes)(value);
        }
        let match = type.match(regexNumber);
        if (match) {
          let signed = match[1] === "int";
          let size = parseInt(match[2] || "256");
          (0, index_js_3.assertArgument)((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
          if (isArray) {
            size = 256;
          }
          if (signed) {
            value = (0, index_js_3.toTwos)(value, size);
          }
          return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)((0, index_js_3.toBeArray)(value), size / 8));
        }
        match = type.match(regexBytes);
        if (match) {
          const size = parseInt(match[1]);
          (0, index_js_3.assertArgument)(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type);
          (0, index_js_3.assertArgument)((0, index_js_3.dataLength)(value) === size, `invalid value for ${type}`, "value", value);
          if (isArray) {
            return (0, index_js_3.getBytes)((0, index_js_3.zeroPadBytes)(value, 32));
          }
          return value;
        }
        match = type.match(regexArray);
        if (match && Array.isArray(value)) {
          const baseType = match[1];
          const count = parseInt(match[2] || String(value.length));
          (0, index_js_3.assertArgument)(count === value.length, `invalid array length for ${type}`, "value", value);
          const result = [];
          value.forEach(function (value) {
            result.push(_pack(baseType, value, true));
          });
          return (0, index_js_3.getBytes)((0, index_js_3.concat)(result));
        }
        (0, index_js_3.assertArgument)(false, "invalid type", "type", type);
      }
      function solidityPacked(types, values) {
        (0, index_js_3.assertArgument)(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
        const tight = [];
        types.forEach(function (type, index) {
          tight.push(_pack(type, values[index]));
        });
        return (0, index_js_3.hexlify)((0, index_js_3.concat)(tight));
      }
      exports.solidityPacked = solidityPacked;
      function solidityPackedKeccak256(types, values) {
        return (0, index_js_2.keccak256)(solidityPacked(types, values));
      }
      exports.solidityPackedKeccak256 = solidityPackedKeccak256;
      function solidityPackedSha256(types, values) {
        return (0, index_js_2.sha256)(solidityPacked(types, values));
      }
      exports.solidityPackedSha256 = solidityPackedSha256;
    },
    1818: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.verifyTypedData = exports.TypedDataEncoder = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(9420);
      const index_js_3 = __webpack_require__(2877);
      const index_js_4 = __webpack_require__(9830);
      const id_js_1 = __webpack_require__(6548);
      const padding = new Uint8Array(32);
      padding.fill(0);
      const BN__1 = BigInt(-1);
      const BN_0 = BigInt(0);
      const BN_1 = BigInt(1);
      const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      ;
      ;
      function hexPadRight(value) {
        const bytes = (0, index_js_4.getBytes)(value);
        const padOffset = bytes.length % 32;
        if (padOffset) {
          return (0, index_js_4.concat)([bytes, padding.slice(padOffset)]);
        }
        return (0, index_js_4.hexlify)(bytes);
      }
      const hexTrue = (0, index_js_4.toBeHex)(BN_1, 32);
      const hexFalse = (0, index_js_4.toBeHex)(BN_0, 32);
      const domainFieldTypes = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
      };
      const domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];
      function checkString(key) {
        return function (value) {
          (0, index_js_4.assertArgument)(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
          return value;
        };
      }
      const domainChecks = {
        name: checkString("name"),
        version: checkString("version"),
        chainId: function (_value) {
          const value = (0, index_js_4.getBigInt)(_value, "domain.chainId");
          (0, index_js_4.assertArgument)(value >= 0, "invalid chain ID", "domain.chainId", _value);
          if (Number.isSafeInteger(value)) {
            return Number(value);
          }
          return (0, index_js_4.toQuantity)(value);
        },
        verifyingContract: function (value) {
          try {
            return (0, index_js_1.getAddress)(value).toLowerCase();
          } catch (error) {}
          (0, index_js_4.assertArgument)(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
        },
        salt: function (value) {
          const bytes = (0, index_js_4.getBytes)(value, "domain.salt");
          (0, index_js_4.assertArgument)(bytes.length === 32, `invalid domain value "salt"`, "domain.salt", value);
          return (0, index_js_4.hexlify)(bytes);
        }
      };
      function getBaseEncoder(type) {
        {
          const match = type.match(/^(u?)int(\d*)$/);
          if (match) {
            const signed = match[1] === "";
            const width = parseInt(match[2] || "256");
            (0, index_js_4.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), "invalid numeric width", "type", type);
            const boundsUpper = (0, index_js_4.mask)(BN_MAX_UINT256, signed ? width - 1 : width);
            const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;
            return function (_value) {
              const value = (0, index_js_4.getBigInt)(_value, "value");
              (0, index_js_4.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
              return (0, index_js_4.toBeHex)(signed ? (0, index_js_4.toTwos)(value, 256) : value, 32);
            };
          }
        }
        {
          const match = type.match(/^bytes(\d+)$/);
          if (match) {
            const width = parseInt(match[1]);
            (0, index_js_4.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
            return function (value) {
              const bytes = (0, index_js_4.getBytes)(value);
              (0, index_js_4.assertArgument)(bytes.length === width, `invalid length for ${type}`, "value", value);
              return hexPadRight(value);
            };
          }
        }
        switch (type) {
          case "address":
            return function (value) {
              return (0, index_js_4.zeroPadValue)((0, index_js_1.getAddress)(value), 32);
            };
          case "bool":
            return function (value) {
              return !value ? hexFalse : hexTrue;
            };
          case "bytes":
            return function (value) {
              return (0, index_js_2.keccak256)(value);
            };
          case "string":
            return function (value) {
              return (0, id_js_1.id)(value);
            };
        }
        return null;
      }
      function encodeType(name, fields) {
        return `${name}(${fields.map(({
          name,
          type
        }) => type + " " + name).join(",")})`;
      }
      class TypedDataEncoder {
        primaryType;
        #types;
        get types() {
          return JSON.parse(this.#types);
        }
        #fullTypes;
        #encoderCache;
        constructor(types) {
          this.#types = JSON.stringify(types);
          this.#fullTypes = new Map();
          this.#encoderCache = new Map();
          const links = new Map();
          const parents = new Map();
          const subtypes = new Map();
          Object.keys(types).forEach(type => {
            links.set(type, new Set());
            parents.set(type, []);
            subtypes.set(type, new Set());
          });
          for (const name in types) {
            const uniqueNames = new Set();
            for (const field of types[name]) {
              (0, index_js_4.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
              uniqueNames.add(field.name);
              const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
              (0, index_js_4.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", types);
              const encoder = getBaseEncoder(baseType);
              if (encoder) {
                continue;
              }
              (0, index_js_4.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", types);
              parents.get(baseType).push(name);
              links.get(name).add(baseType);
            }
          }
          const primaryTypes = Array.from(parents.keys()).filter(n => parents.get(n).length === 0);
          (0, index_js_4.assertArgument)(primaryTypes.length !== 0, "missing primary type", "types", types);
          (0, index_js_4.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(", ")}`, "types", types);
          (0, index_js_4.defineProperties)(this, {
            primaryType: primaryTypes[0]
          });
          function checkCircular(type, found) {
            (0, index_js_4.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", types);
            found.add(type);
            for (const child of links.get(type)) {
              if (!parents.has(child)) {
                continue;
              }
              checkCircular(child, found);
              for (const subtype of found) {
                subtypes.get(subtype).add(child);
              }
            }
            found.delete(type);
          }
          checkCircular(this.primaryType, new Set());
          for (const [name, set] of subtypes) {
            const st = Array.from(set);
            st.sort();
            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(""));
          }
        }
        getEncoder(type) {
          let encoder = this.#encoderCache.get(type);
          if (!encoder) {
            encoder = this.#getEncoder(type);
            this.#encoderCache.set(type, encoder);
          }
          return encoder;
        }
        #getEncoder(type) {
          {
            const encoder = getBaseEncoder(type);
            if (encoder) {
              return encoder;
            }
          }
          const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
          if (match) {
            const subtype = match[1];
            const subEncoder = this.getEncoder(subtype);
            return value => {
              (0, index_js_4.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, "value", value);
              let result = value.map(subEncoder);
              if (this.#fullTypes.has(subtype)) {
                result = result.map(index_js_2.keccak256);
              }
              return (0, index_js_2.keccak256)((0, index_js_4.concat)(result));
            };
          }
          const fields = this.types[type];
          if (fields) {
            const encodedType = (0, id_js_1.id)(this.#fullTypes.get(type));
            return value => {
              const values = fields.map(({
                name,
                type
              }) => {
                const result = this.getEncoder(type)(value[name]);
                if (this.#fullTypes.has(type)) {
                  return (0, index_js_2.keccak256)(result);
                }
                return result;
              });
              values.unshift(encodedType);
              return (0, index_js_4.concat)(values);
            };
          }
          (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, "type", type);
        }
        encodeType(name) {
          const result = this.#fullTypes.get(name);
          (0, index_js_4.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
          return result;
        }
        encodeData(type, value) {
          return this.getEncoder(type)(value);
        }
        hashStruct(name, value) {
          return (0, index_js_2.keccak256)(this.encodeData(name, value));
        }
        encode(value) {
          return this.encodeData(this.primaryType, value);
        }
        hash(value) {
          return this.hashStruct(this.primaryType, value);
        }
        _visit(type, value, callback) {
          {
            const encoder = getBaseEncoder(type);
            if (encoder) {
              return callback(type, value);
            }
          }
          const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
          if (match) {
            (0, index_js_4.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, "value", value);
            return value.map(v => this._visit(match[1], v, callback));
          }
          const fields = this.types[type];
          if (fields) {
            return fields.reduce((accum, {
              name,
              type
            }) => {
              accum[name] = this._visit(type, value[name], callback);
              return accum;
            }, {});
          }
          (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, "type", type);
        }
        visit(value, callback) {
          return this._visit(this.primaryType, value, callback);
        }
        static from(types) {
          return new TypedDataEncoder(types);
        }
        static getPrimaryType(types) {
          return TypedDataEncoder.from(types).primaryType;
        }
        static hashStruct(name, types, value) {
          return TypedDataEncoder.from(types).hashStruct(name, value);
        }
        static hashDomain(domain) {
          const domainFields = [];
          for (const name in domain) {
            if (domain[name] == null) {
              continue;
            }
            const type = domainFieldTypes[name];
            (0, index_js_4.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            domainFields.push({
              name,
              type
            });
          }
          domainFields.sort((a, b) => {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
          });
          return TypedDataEncoder.hashStruct("EIP712Domain", {
            EIP712Domain: domainFields
          }, domain);
        }
        static encode(domain, types, value) {
          return (0, index_js_4.concat)(["0x1901", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
        }
        static hash(domain, types, value) {
          return (0, index_js_2.keccak256)(TypedDataEncoder.encode(domain, types, value));
        }
        static async resolveNames(domain, types, value, resolveName) {
          domain = Object.assign({}, domain);
          for (const key in domain) {
            if (domain[key] == null) {
              delete domain[key];
            }
          }
          const ensCache = {};
          if (domain.verifyingContract && !(0, index_js_4.isHexString)(domain.verifyingContract, 20)) {
            ensCache[domain.verifyingContract] = "0x";
          }
          const encoder = TypedDataEncoder.from(types);
          encoder.visit(value, (type, value) => {
            if (type === "address" && !(0, index_js_4.isHexString)(value, 20)) {
              ensCache[value] = "0x";
            }
            return value;
          });
          for (const name in ensCache) {
            ensCache[name] = await resolveName(name);
          }
          if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
            domain.verifyingContract = ensCache[domain.verifyingContract];
          }
          value = encoder.visit(value, (type, value) => {
            if (type === "address" && ensCache[value]) {
              return ensCache[value];
            }
            return value;
          });
          return {
            domain,
            value
          };
        }
        static getPayload(domain, types, value) {
          TypedDataEncoder.hashDomain(domain);
          const domainValues = {};
          const domainTypes = [];
          domainFieldNames.forEach(name => {
            const value = domain[name];
            if (value == null) {
              return;
            }
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({
              name,
              type: domainFieldTypes[name]
            });
          });
          const encoder = TypedDataEncoder.from(types);
          const typesWithDomain = Object.assign({}, types);
          (0, index_js_4.assertArgument)(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
          typesWithDomain.EIP712Domain = domainTypes;
          encoder.encode(value);
          return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value) => {
              if (type.match(/^bytes(\d*)/)) {
                return (0, index_js_4.hexlify)((0, index_js_4.getBytes)(value));
              }
              if (type.match(/^u?int/)) {
                return (0, index_js_4.getBigInt)(value).toString();
              }
              switch (type) {
                case "address":
                  return value.toLowerCase();
                case "bool":
                  return !!value;
                case "string":
                  (0, index_js_4.assertArgument)(typeof value === "string", "invalid string", "value", value);
                  return value;
              }
              (0, index_js_4.assertArgument)(false, "unsupported type", "type", type);
            })
          };
        }
      }
      exports.TypedDataEncoder = TypedDataEncoder;
      function verifyTypedData(domain, types, value, signature) {
        return (0, index_js_3.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);
      }
      exports.verifyTypedData = verifyTypedData;
    },
    3589: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ethers = void 0;
      const tslib_1 = __webpack_require__(2003);
      const ethers = tslib_1.__importStar(__webpack_require__(2261));
      exports.ethers = ethers;
      tslib_1.__exportStar(__webpack_require__(2261), exports);
    },
    2629: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AbstractProvider = exports.UnmanagedSubscriber = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(4160);
      const index_js_3 = __webpack_require__(4464);
      const index_js_4 = __webpack_require__(5714);
      const index_js_5 = __webpack_require__(2877);
      const index_js_6 = __webpack_require__(9830);
      const ens_resolver_js_1 = __webpack_require__(2518);
      const format_js_1 = __webpack_require__(8585);
      const network_js_1 = __webpack_require__(7104);
      const provider_js_1 = __webpack_require__(1607);
      const subscriber_polling_js_1 = __webpack_require__(4975);
      const BN_2 = BigInt(2);
      const MAX_CCIP_REDIRECTS = 10;
      function isPromise(value) {
        return value && typeof value.then === "function";
      }
      function getTag(prefix, value) {
        return prefix + ":" + JSON.stringify(value, (k, v) => {
          if (v == null) {
            return "null";
          }
          if (typeof v === "bigint") {
            return `bigint:${v.toString()}`;
          }
          if (typeof v === "string") {
            return v.toLowerCase();
          }
          if (typeof v === "object" && !Array.isArray(v)) {
            const keys = Object.keys(v);
            keys.sort();
            return keys.reduce((accum, key) => {
              accum[key] = v[key];
              return accum;
            }, {});
          }
          return v;
        });
      }
      class UnmanagedSubscriber {
        name;
        constructor(name) {
          (0, index_js_6.defineProperties)(this, {
            name
          });
        }
        start() {}
        stop() {}
        pause(dropWhilePaused) {}
        resume() {}
      }
      exports.UnmanagedSubscriber = UnmanagedSubscriber;
      function copy(value) {
        return JSON.parse(JSON.stringify(value));
      }
      function concisify(items) {
        items = Array.from(new Set(items).values());
        items.sort();
        return items;
      }
      async function getSubscription(_event, provider) {
        if (_event == null) {
          throw new Error("invalid event");
        }
        if (Array.isArray(_event)) {
          _event = {
            topics: _event
          };
        }
        if (typeof _event === "string") {
          switch (_event) {
            case "block":
            case "pending":
            case "debug":
            case "error":
            case "network":
              {
                return {
                  type: _event,
                  tag: _event
                };
              }
          }
        }
        if ((0, index_js_6.isHexString)(_event, 32)) {
          const hash = _event.toLowerCase();
          return {
            type: "transaction",
            tag: getTag("tx", {
              hash
            }),
            hash
          };
        }
        if (_event.orphan) {
          const event = _event;
          return {
            type: "orphan",
            tag: getTag("orphan", event),
            filter: copy(event)
          };
        }
        if (_event.address || _event.topics) {
          const event = _event;
          const filter = {
            topics: (event.topics || []).map(t => {
              if (t == null) {
                return null;
              }
              if (Array.isArray(t)) {
                return concisify(t.map(t => t.toLowerCase()));
              }
              return t.toLowerCase();
            })
          };
          if (event.address) {
            const addresses = [];
            const promises = [];
            const addAddress = addr => {
              if ((0, index_js_6.isHexString)(addr)) {
                addresses.push(addr);
              } else {
                promises.push((async () => {
                  addresses.push(await (0, index_js_1.resolveAddress)(addr, provider));
                })());
              }
            };
            if (Array.isArray(event.address)) {
              event.address.forEach(addAddress);
            } else {
              addAddress(event.address);
            }
            if (promises.length) {
              await Promise.all(promises);
            }
            filter.address = concisify(addresses.map(a => a.toLowerCase()));
          }
          return {
            filter,
            tag: getTag("event", filter),
            type: "event"
          };
        }
        (0, index_js_6.assertArgument)(false, "unknown ProviderEvent", "event", _event);
      }
      function getTime() {
        return new Date().getTime();
      }
      const defaultOptions = {
        cacheTimeout: 250,
        pollingInterval: 4000
      };
      class AbstractProvider {
        #subs;
        #plugins;
        #pausedState;
        #destroyed;
        #networkPromise;
        #anyNetwork;
        #performCache;
        #lastBlockNumber;
        #nextTimer;
        #timers;
        #disableCcipRead;
        #options;
        constructor(_network, options) {
          this.#options = Object.assign({}, defaultOptions, options || {});
          if (_network === "any") {
            this.#anyNetwork = true;
            this.#networkPromise = null;
          } else if (_network) {
            const network = network_js_1.Network.from(_network);
            this.#anyNetwork = false;
            this.#networkPromise = Promise.resolve(network);
            setTimeout(() => {
              this.emit("network", network, null);
            }, 0);
          } else {
            this.#anyNetwork = false;
            this.#networkPromise = null;
          }
          this.#lastBlockNumber = -1;
          this.#performCache = new Map();
          this.#subs = new Map();
          this.#plugins = new Map();
          this.#pausedState = null;
          this.#destroyed = false;
          this.#nextTimer = 1;
          this.#timers = new Map();
          this.#disableCcipRead = false;
        }
        get pollingInterval() {
          return this.#options.pollingInterval;
        }
        get provider() {
          return this;
        }
        get plugins() {
          return Array.from(this.#plugins.values());
        }
        attachPlugin(plugin) {
          if (this.#plugins.get(plugin.name)) {
            throw new Error(`cannot replace existing plugin: ${plugin.name} `);
          }
          this.#plugins.set(plugin.name, plugin.connect(this));
          return this;
        }
        getPlugin(name) {
          return this.#plugins.get(name) || null;
        }
        get disableCcipRead() {
          return this.#disableCcipRead;
        }
        set disableCcipRead(value) {
          this.#disableCcipRead = !!value;
        }
        async #perform(req) {
          const timeout = this.#options.cacheTimeout;
          if (timeout < 0) {
            return await this._perform(req);
          }
          const tag = getTag(req.method, req);
          let perform = this.#performCache.get(tag);
          if (!perform) {
            perform = this._perform(req);
            this.#performCache.set(tag, perform);
            setTimeout(() => {
              if (this.#performCache.get(tag) === perform) {
                this.#performCache.delete(tag);
              }
            }, timeout);
          }
          return await perform;
        }
        async ccipReadFetch(tx, calldata, urls) {
          if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
            return null;
          }
          const sender = tx.to.toLowerCase();
          const data = calldata.toLowerCase();
          const errorMessages = [];
          for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            const href = url.replace("{sender}", sender).replace("{data}", data);
            const request = new index_js_6.FetchRequest(href);
            if (url.indexOf("{data}") === -1) {
              request.body = {
                data,
                sender
              };
            }
            this.emit("debug", {
              action: "sendCcipReadFetchRequest",
              request,
              index: i,
              urls
            });
            let errorMessage = "unknown error";
            const resp = await request.send();
            try {
              const result = resp.bodyJson;
              if (result.data) {
                this.emit("debug", {
                  action: "receiveCcipReadFetchResult",
                  request,
                  result
                });
                return result.data;
              }
              if (result.message) {
                errorMessage = result.message;
              }
              this.emit("debug", {
                action: "receiveCcipReadFetchError",
                request,
                result
              });
            } catch (error) {}
            (0, index_js_6.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", {
              reason: "404_MISSING_RESOURCE",
              transaction: tx,
              info: {
                url,
                errorMessage
              }
            });
            errorMessages.push(errorMessage);
          }
          (0, index_js_6.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map(m => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
            reason: "500_SERVER_ERROR",
            transaction: tx,
            info: {
              urls,
              errorMessages
            }
          });
        }
        _wrapBlock(value, network) {
          return new provider_js_1.Block((0, format_js_1.formatBlock)(value), this);
        }
        _wrapLog(value, network) {
          return new provider_js_1.Log((0, format_js_1.formatLog)(value), this);
        }
        _wrapTransactionReceipt(value, network) {
          return new provider_js_1.TransactionReceipt((0, format_js_1.formatTransactionReceipt)(value), this);
        }
        _wrapTransactionResponse(tx, network) {
          return new provider_js_1.TransactionResponse((0, format_js_1.formatTransactionResponse)(tx), this);
        }
        _detectNetwork() {
          (0, index_js_6.assert)(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
            operation: "_detectNetwork"
          });
        }
        async _perform(req) {
          (0, index_js_6.assert)(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
            operation: req.method,
            info: req
          });
        }
        async getBlockNumber() {
          const blockNumber = (0, index_js_6.getNumber)(await this.#perform({
            method: "getBlockNumber"
          }), "%response");
          if (this.#lastBlockNumber >= 0) {
            this.#lastBlockNumber = blockNumber;
          }
          return blockNumber;
        }
        _getAddress(address) {
          return (0, index_js_1.resolveAddress)(address, this);
        }
        _getBlockTag(blockTag) {
          if (blockTag == null) {
            return "latest";
          }
          switch (blockTag) {
            case "earliest":
              return "0x0";
            case "latest":
            case "pending":
            case "safe":
            case "finalized":
              return blockTag;
          }
          if ((0, index_js_6.isHexString)(blockTag)) {
            if ((0, index_js_6.isHexString)(blockTag, 32)) {
              return blockTag;
            }
            return (0, index_js_6.toQuantity)(blockTag);
          }
          if (typeof blockTag === "bigint") {
            blockTag = (0, index_js_6.getNumber)(blockTag, "blockTag");
          }
          if (typeof blockTag === "number") {
            if (blockTag >= 0) {
              return (0, index_js_6.toQuantity)(blockTag);
            }
            if (this.#lastBlockNumber >= 0) {
              return (0, index_js_6.toQuantity)(this.#lastBlockNumber + blockTag);
            }
            return this.getBlockNumber().then(b => (0, index_js_6.toQuantity)(b + blockTag));
          }
          (0, index_js_6.assertArgument)(false, "invalid blockTag", "blockTag", blockTag);
        }
        _getFilter(filter) {
          const topics = (filter.topics || []).map(t => {
            if (t == null) {
              return null;
            }
            if (Array.isArray(t)) {
              return concisify(t.map(t => t.toLowerCase()));
            }
            return t.toLowerCase();
          });
          const blockHash = "blockHash" in filter ? filter.blockHash : undefined;
          const resolve = (_address, fromBlock, toBlock) => {
            let address = undefined;
            switch (_address.length) {
              case 0:
                break;
              case 1:
                address = _address[0];
                break;
              default:
                _address.sort();
                address = _address;
            }
            if (blockHash) {
              if (fromBlock != null || toBlock != null) {
                throw new Error("invalid filter");
              }
            }
            const filter = {};
            if (address) {
              filter.address = address;
            }
            if (topics.length) {
              filter.topics = topics;
            }
            if (fromBlock) {
              filter.fromBlock = fromBlock;
            }
            if (toBlock) {
              filter.toBlock = toBlock;
            }
            if (blockHash) {
              filter.blockHash = blockHash;
            }
            return filter;
          };
          let address = [];
          if (filter.address) {
            if (Array.isArray(filter.address)) {
              for (const addr of filter.address) {
                address.push(this._getAddress(addr));
              }
            } else {
              address.push(this._getAddress(filter.address));
            }
          }
          let fromBlock = undefined;
          if ("fromBlock" in filter) {
            fromBlock = this._getBlockTag(filter.fromBlock);
          }
          let toBlock = undefined;
          if ("toBlock" in filter) {
            toBlock = this._getBlockTag(filter.toBlock);
          }
          if (address.filter(a => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
            return Promise.all([Promise.all(address), fromBlock, toBlock]).then(result => {
              return resolve(result[0], result[1], result[2]);
            });
          }
          return resolve(address, fromBlock, toBlock);
        }
        _getTransactionRequest(_request) {
          const request = (0, provider_js_1.copyRequest)(_request);
          const promises = [];
          ["to", "from"].forEach(key => {
            if (request[key] == null) {
              return;
            }
            const addr = (0, index_js_1.resolveAddress)(request[key]);
            if (isPromise(addr)) {
              promises.push(async function () {
                request[key] = await addr;
              }());
            } else {
              request[key] = addr;
            }
          });
          if (request.blockTag != null) {
            const blockTag = this._getBlockTag(request.blockTag);
            if (isPromise(blockTag)) {
              promises.push(async function () {
                request.blockTag = await blockTag;
              }());
            } else {
              request.blockTag = blockTag;
            }
          }
          if (promises.length) {
            return async function () {
              await Promise.all(promises);
              return request;
            }();
          }
          return request;
        }
        async getNetwork() {
          if (this.#networkPromise == null) {
            const detectNetwork = this._detectNetwork().then(network => {
              this.emit("network", network, null);
              return network;
            }, error => {
              if (this.#networkPromise === detectNetwork) {
                this.#networkPromise = null;
              }
              throw error;
            });
            this.#networkPromise = detectNetwork;
            return (await detectNetwork).clone();
          }
          const networkPromise = this.#networkPromise;
          const [expected, actual] = await Promise.all([networkPromise, this._detectNetwork()]);
          if (expected.chainId !== actual.chainId) {
            if (this.#anyNetwork) {
              this.emit("network", actual, expected);
              if (this.#networkPromise === networkPromise) {
                this.#networkPromise = Promise.resolve(actual);
              }
            } else {
              (0, index_js_6.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
                event: "changed"
              });
            }
          }
          return expected.clone();
        }
        async getFeeData() {
          const network = await this.getNetwork();
          const getFeeDataFunc = async () => {
            const {
              _block,
              gasPrice
            } = await (0, index_js_6.resolveProperties)({
              _block: this.#getBlock("latest", false),
              gasPrice: (async () => {
                try {
                  const gasPrice = await this.#perform({
                    method: "getGasPrice"
                  });
                  return (0, index_js_6.getBigInt)(gasPrice, "%response");
                } catch (error) {}
                return null;
              })()
            });
            let maxFeePerGas = null;
            let maxPriorityFeePerGas = null;
            const block = this._wrapBlock(_block, network);
            if (block && block.baseFeePerGas) {
              maxPriorityFeePerGas = BigInt("1000000000");
              maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
            }
            return new provider_js_1.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
          };
          const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
          if (plugin) {
            const req = new index_js_6.FetchRequest(plugin.url);
            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
            return new provider_js_1.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
          }
          return await getFeeDataFunc();
        }
        async estimateGas(_tx) {
          let tx = this._getTransactionRequest(_tx);
          if (isPromise(tx)) {
            tx = await tx;
          }
          return (0, index_js_6.getBigInt)(await this.#perform({
            method: "estimateGas",
            transaction: tx
          }), "%response");
        }
        async #call(tx, blockTag, attempt) {
          (0, index_js_6.assert)(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
            reason: "TOO_MANY_REDIRECTS",
            transaction: Object.assign({}, tx, {
              blockTag,
              enableCcipRead: true
            })
          });
          const transaction = (0, provider_js_1.copyRequest)(tx);
          try {
            return (0, index_js_6.hexlify)(await this._perform({
              method: "call",
              transaction,
              blockTag
            }));
          } catch (error) {
            if (!this.disableCcipRead && (0, index_js_6.isCallException)(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && (0, index_js_6.dataSlice)(error.data, 0, 4) === "0x556f1830") {
              const data = error.data;
              const txSender = await (0, index_js_1.resolveAddress)(transaction.to, this);
              let ccipArgs;
              try {
                ccipArgs = parseOffchainLookup((0, index_js_6.dataSlice)(error.data, 4));
              } catch (error) {
                (0, index_js_6.assert)(false, error.message, "OFFCHAIN_FAULT", {
                  reason: "BAD_DATA",
                  transaction,
                  info: {
                    data
                  }
                });
              }
              (0, index_js_6.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
                action: "call",
                data,
                reason: "OffchainLookup",
                transaction: transaction,
                invocation: null,
                revert: {
                  signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  name: "OffchainLookup",
                  args: ccipArgs.errorArgs
                }
              });
              const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
              (0, index_js_6.assert)(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
                reason: "FETCH_FAILED",
                transaction,
                info: {
                  data: error.data,
                  errorArgs: ccipArgs.errorArgs
                }
              });
              const tx = {
                to: txSender,
                data: (0, index_js_6.concat)([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
              };
              this.emit("debug", {
                action: "sendCcipReadCall",
                transaction: tx
              });
              try {
                const result = await this.#call(tx, blockTag, attempt + 1);
                this.emit("debug", {
                  action: "receiveCcipReadCallResult",
                  transaction: Object.assign({}, tx),
                  result
                });
                return result;
              } catch (error) {
                this.emit("debug", {
                  action: "receiveCcipReadCallError",
                  transaction: Object.assign({}, tx),
                  error
                });
                throw error;
              }
            }
            throw error;
          }
        }
        async #checkNetwork(promise) {
          const {
            value
          } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            value: promise
          });
          return value;
        }
        async call(_tx) {
          const {
            tx,
            blockTag
          } = await (0, index_js_6.resolveProperties)({
            tx: this._getTransactionRequest(_tx),
            blockTag: this._getBlockTag(_tx.blockTag)
          });
          return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
        }
        async #getAccountValue(request, _address, _blockTag) {
          let address = this._getAddress(_address);
          let blockTag = this._getBlockTag(_blockTag);
          if (typeof address !== "string" || typeof blockTag !== "string") {
            [address, blockTag] = await Promise.all([address, blockTag]);
          }
          return await this.#checkNetwork(this.#perform(Object.assign(request, {
            address,
            blockTag
          })));
        }
        async getBalance(address, blockTag) {
          return (0, index_js_6.getBigInt)(await this.#getAccountValue({
            method: "getBalance"
          }, address, blockTag), "%response");
        }
        async getTransactionCount(address, blockTag) {
          return (0, index_js_6.getNumber)(await this.#getAccountValue({
            method: "getTransactionCount"
          }, address, blockTag), "%response");
        }
        async getCode(address, blockTag) {
          return (0, index_js_6.hexlify)(await this.#getAccountValue({
            method: "getCode"
          }, address, blockTag));
        }
        async getStorage(address, _position, blockTag) {
          const position = (0, index_js_6.getBigInt)(_position, "position");
          return (0, index_js_6.hexlify)(await this.#getAccountValue({
            method: "getStorage",
            position
          }, address, blockTag));
        }
        async broadcastTransaction(signedTx) {
          const {
            blockNumber,
            hash,
            network
          } = await (0, index_js_6.resolveProperties)({
            blockNumber: this.getBlockNumber(),
            hash: this._perform({
              method: "broadcastTransaction",
              signedTransaction: signedTx
            }),
            network: this.getNetwork()
          });
          const tx = index_js_5.Transaction.from(signedTx);
          if (tx.hash !== hash) {
            throw new Error("@TODO: the returned hash did not match");
          }
          return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
        }
        async #getBlock(block, includeTransactions) {
          if ((0, index_js_6.isHexString)(block, 32)) {
            return await this.#perform({
              method: "getBlock",
              blockHash: block,
              includeTransactions
            });
          }
          let blockTag = this._getBlockTag(block);
          if (typeof blockTag !== "string") {
            blockTag = await blockTag;
          }
          return await this.#perform({
            method: "getBlock",
            blockTag,
            includeTransactions
          });
        }
        async getBlock(block, prefetchTxs) {
          const {
            network,
            params
          } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            params: this.#getBlock(block, !!prefetchTxs)
          });
          if (params == null) {
            return null;
          }
          return this._wrapBlock(params, network);
        }
        async getTransaction(hash) {
          const {
            network,
            params
          } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            params: this.#perform({
              method: "getTransaction",
              hash
            })
          });
          if (params == null) {
            return null;
          }
          return this._wrapTransactionResponse(params, network);
        }
        async getTransactionReceipt(hash) {
          const {
            network,
            params
          } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            params: this.#perform({
              method: "getTransactionReceipt",
              hash
            })
          });
          if (params == null) {
            return null;
          }
          if (params.gasPrice == null && params.effectiveGasPrice == null) {
            const tx = await this.#perform({
              method: "getTransaction",
              hash
            });
            if (tx == null) {
              throw new Error("report this; could not find tx or effectiveGasPrice");
            }
            params.effectiveGasPrice = tx.gasPrice;
          }
          return this._wrapTransactionReceipt(params, network);
        }
        async getTransactionResult(hash) {
          const {
            result
          } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            result: this.#perform({
              method: "getTransactionResult",
              hash
            })
          });
          if (result == null) {
            return null;
          }
          return (0, index_js_6.hexlify)(result);
        }
        async getLogs(_filter) {
          let filter = this._getFilter(_filter);
          if (isPromise(filter)) {
            filter = await filter;
          }
          const {
            network,
            params
          } = await (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            params: this.#perform({
              method: "getLogs",
              filter
            })
          });
          return params.map(p => this._wrapLog(p, network));
        }
        _getProvider(chainId) {
          (0, index_js_6.assert)(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
            operation: "_getProvider()"
          });
        }
        async getResolver(name) {
          return await ens_resolver_js_1.EnsResolver.fromName(this, name);
        }
        async getAvatar(name) {
          const resolver = await this.getResolver(name);
          if (resolver) {
            return await resolver.getAvatar();
          }
          return null;
        }
        async resolveName(name) {
          const resolver = await this.getResolver(name);
          if (resolver) {
            return await resolver.getAddress();
          }
          return null;
        }
        async lookupAddress(address) {
          address = (0, index_js_1.getAddress)(address);
          const node = (0, index_js_4.namehash)(address.substring(2).toLowerCase() + ".addr.reverse");
          try {
            const ensAddr = await ens_resolver_js_1.EnsResolver.getEnsAddress(this);
            const ensContract = new index_js_3.Contract(ensAddr, ["function resolver(bytes32) view returns (address)"], this);
            const resolver = await ensContract.resolver(node);
            if (resolver == null || resolver === index_js_2.ZeroAddress) {
              return null;
            }
            const resolverContract = new index_js_3.Contract(resolver, ["function name(bytes32) view returns (string)"], this);
            const name = await resolverContract.name(node);
            const check = await this.resolveName(name);
            if (check !== address) {
              return null;
            }
            return name;
          } catch (error) {
            if ((0, index_js_6.isError)(error, "BAD_DATA") && error.value === "0x") {
              return null;
            }
            if ((0, index_js_6.isError)(error, "CALL_EXCEPTION")) {
              return null;
            }
            throw error;
          }
          return null;
        }
        async waitForTransaction(hash, _confirms, timeout) {
          const confirms = _confirms != null ? _confirms : 1;
          if (confirms === 0) {
            return this.getTransactionReceipt(hash);
          }
          return new Promise(async (resolve, reject) => {
            let timer = null;
            const listener = async blockNumber => {
              try {
                const receipt = await this.getTransactionReceipt(hash);
                if (receipt != null) {
                  if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                    resolve(receipt);
                    if (timer) {
                      clearTimeout(timer);
                      timer = null;
                    }
                    return;
                  }
                }
              } catch (error) {
                console.log("EEE", error);
              }
              this.once("block", listener);
            };
            if (timeout != null) {
              timer = setTimeout(() => {
                if (timer == null) {
                  return;
                }
                timer = null;
                this.off("block", listener);
                reject((0, index_js_6.makeError)("timeout", "TIMEOUT", {
                  reason: "timeout"
                }));
              }, timeout);
            }
            listener(await this.getBlockNumber());
          });
        }
        async waitForBlock(blockTag) {
          (0, index_js_6.assert)(false, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock"
          });
        }
        _clearTimeout(timerId) {
          const timer = this.#timers.get(timerId);
          if (!timer) {
            return;
          }
          if (timer.timer) {
            clearTimeout(timer.timer);
          }
          this.#timers.delete(timerId);
        }
        _setTimeout(_func, timeout) {
          if (timeout == null) {
            timeout = 0;
          }
          const timerId = this.#nextTimer++;
          const func = () => {
            this.#timers.delete(timerId);
            _func();
          };
          if (this.paused) {
            this.#timers.set(timerId, {
              timer: null,
              func,
              time: timeout
            });
          } else {
            const timer = setTimeout(func, timeout);
            this.#timers.set(timerId, {
              timer,
              func,
              time: getTime()
            });
          }
          return timerId;
        }
        _forEachSubscriber(func) {
          for (const sub of this.#subs.values()) {
            func(sub.subscriber);
          }
        }
        _getSubscriber(sub) {
          switch (sub.type) {
            case "debug":
            case "error":
            case "network":
              return new UnmanagedSubscriber(sub.type);
            case "block":
              {
                const subscriber = new subscriber_polling_js_1.PollingBlockSubscriber(this);
                subscriber.pollingInterval = this.pollingInterval;
                return subscriber;
              }
            case "event":
              return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
            case "transaction":
              return new subscriber_polling_js_1.PollingTransactionSubscriber(this, sub.hash);
            case "orphan":
              return new subscriber_polling_js_1.PollingOrphanSubscriber(this, sub.filter);
          }
          throw new Error(`unsupported event: ${sub.type}`);
        }
        _recoverSubscriber(oldSub, newSub) {
          for (const sub of this.#subs.values()) {
            if (sub.subscriber === oldSub) {
              if (sub.started) {
                sub.subscriber.stop();
              }
              sub.subscriber = newSub;
              if (sub.started) {
                newSub.start();
              }
              if (this.#pausedState != null) {
                newSub.pause(this.#pausedState);
              }
              break;
            }
          }
        }
        async #hasSub(event, emitArgs) {
          let sub = await getSubscription(event, this);
          if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
            sub = await getSubscription({
              orphan: "drop-log",
              log: emitArgs[0]
            }, this);
          }
          return this.#subs.get(sub.tag) || null;
        }
        async #getSub(event) {
          const subscription = await getSubscription(event, this);
          const tag = subscription.tag;
          let sub = this.#subs.get(tag);
          if (!sub) {
            const subscriber = this._getSubscriber(subscription);
            const addressableMap = new WeakMap();
            const nameMap = new Map();
            sub = {
              subscriber,
              tag,
              addressableMap,
              nameMap,
              started: false,
              listeners: []
            };
            this.#subs.set(tag, sub);
          }
          return sub;
        }
        async on(event, listener) {
          const sub = await this.#getSub(event);
          sub.listeners.push({
            listener,
            once: false
          });
          if (!sub.started) {
            sub.subscriber.start();
            sub.started = true;
            if (this.#pausedState != null) {
              sub.subscriber.pause(this.#pausedState);
            }
          }
          return this;
        }
        async once(event, listener) {
          const sub = await this.#getSub(event);
          sub.listeners.push({
            listener,
            once: true
          });
          if (!sub.started) {
            sub.subscriber.start();
            sub.started = true;
            if (this.#pausedState != null) {
              sub.subscriber.pause(this.#pausedState);
            }
          }
          return this;
        }
        async emit(event, ...args) {
          const sub = await this.#hasSub(event, args);
          if (!sub || sub.listeners.length === 0) {
            return false;
          }
          ;
          const count = sub.listeners.length;
          sub.listeners = sub.listeners.filter(({
            listener,
            once
          }) => {
            const payload = new index_js_6.EventPayload(this, once ? null : listener, event);
            try {
              listener.call(this, ...args, payload);
            } catch (error) {}
            return !once;
          });
          if (sub.listeners.length === 0) {
            if (sub.started) {
              sub.subscriber.stop();
            }
            this.#subs.delete(sub.tag);
          }
          return count > 0;
        }
        async listenerCount(event) {
          if (event) {
            const sub = await this.#hasSub(event);
            if (!sub) {
              return 0;
            }
            return sub.listeners.length;
          }
          let total = 0;
          for (const {
            listeners
          } of this.#subs.values()) {
            total += listeners.length;
          }
          return total;
        }
        async listeners(event) {
          if (event) {
            const sub = await this.#hasSub(event);
            if (!sub) {
              return [];
            }
            return sub.listeners.map(({
              listener
            }) => listener);
          }
          let result = [];
          for (const {
            listeners
          } of this.#subs.values()) {
            result = result.concat(listeners.map(({
              listener
            }) => listener));
          }
          return result;
        }
        async off(event, listener) {
          const sub = await this.#hasSub(event);
          if (!sub) {
            return this;
          }
          if (listener) {
            const index = sub.listeners.map(({
              listener
            }) => listener).indexOf(listener);
            if (index >= 0) {
              sub.listeners.splice(index, 1);
            }
          }
          if (!listener || sub.listeners.length === 0) {
            if (sub.started) {
              sub.subscriber.stop();
            }
            this.#subs.delete(sub.tag);
          }
          return this;
        }
        async removeAllListeners(event) {
          if (event) {
            const {
              tag,
              started,
              subscriber
            } = await this.#getSub(event);
            if (started) {
              subscriber.stop();
            }
            this.#subs.delete(tag);
          } else {
            for (const [tag, {
              started,
              subscriber
            }] of this.#subs) {
              if (started) {
                subscriber.stop();
              }
              this.#subs.delete(tag);
            }
          }
          return this;
        }
        async addListener(event, listener) {
          return await this.on(event, listener);
        }
        async removeListener(event, listener) {
          return this.off(event, listener);
        }
        get destroyed() {
          return this.#destroyed;
        }
        destroy() {
          this.removeAllListeners();
          for (const timerId of this.#timers.keys()) {
            this._clearTimeout(timerId);
          }
          this.#destroyed = true;
        }
        get paused() {
          return this.#pausedState != null;
        }
        set paused(pause) {
          if (!!pause === this.paused) {
            return;
          }
          if (this.paused) {
            this.resume();
          } else {
            this.pause(false);
          }
        }
        pause(dropWhilePaused) {
          this.#lastBlockNumber = -1;
          if (this.#pausedState != null) {
            if (this.#pausedState == !!dropWhilePaused) {
              return;
            }
            (0, index_js_6.assert)(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
              operation: "pause"
            });
          }
          this._forEachSubscriber(s => s.pause(dropWhilePaused));
          this.#pausedState = !!dropWhilePaused;
          for (const timer of this.#timers.values()) {
            if (timer.timer) {
              clearTimeout(timer.timer);
            }
            timer.time = getTime() - timer.time;
          }
        }
        resume() {
          if (this.#pausedState == null) {
            return;
          }
          this._forEachSubscriber(s => s.resume());
          this.#pausedState = null;
          for (const timer of this.#timers.values()) {
            let timeout = timer.time;
            if (timeout < 0) {
              timeout = 0;
            }
            timer.time = getTime();
            setTimeout(timer.func, timeout);
          }
        }
      }
      exports.AbstractProvider = AbstractProvider;
      function _parseString(result, start) {
        try {
          const bytes = _parseBytes(result, start);
          if (bytes) {
            return (0, index_js_6.toUtf8String)(bytes);
          }
        } catch (error) {}
        return null;
      }
      function _parseBytes(result, start) {
        if (result === "0x") {
          return null;
        }
        try {
          const offset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, start, start + 32));
          const length = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, offset, offset + 32));
          return (0, index_js_6.dataSlice)(result, offset + 32, offset + 32 + length);
        } catch (error) {}
        return null;
      }
      function numPad(value) {
        const result = (0, index_js_6.toBeArray)(value);
        if (result.length > 32) {
          throw new Error("internal; should not happen");
        }
        const padded = new Uint8Array(32);
        padded.set(result, 32 - result.length);
        return padded;
      }
      function bytesPad(value) {
        if (value.length % 32 === 0) {
          return value;
        }
        const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
        result.set(value);
        return result;
      }
      const empty = new Uint8Array([]);
      function encodeBytes(datas) {
        const result = [];
        let byteCount = 0;
        for (let i = 0; i < datas.length; i++) {
          result.push(empty);
          byteCount += 32;
        }
        for (let i = 0; i < datas.length; i++) {
          const data = (0, index_js_6.getBytes)(datas[i]);
          result[i] = numPad(byteCount);
          result.push(numPad(data.length));
          result.push(bytesPad(data));
          byteCount += 32 + Math.ceil(data.length / 32) * 32;
        }
        return (0, index_js_6.concat)(result);
      }
      const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
      function parseOffchainLookup(data) {
        const result = {
          sender: "",
          urls: [],
          calldata: "",
          selector: "",
          extraData: "",
          errorArgs: []
        };
        (0, index_js_6.assert)((0, index_js_6.dataLength)(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
          reason: "insufficient OffchainLookup data"
        });
        const sender = (0, index_js_6.dataSlice)(data, 0, 32);
        (0, index_js_6.assert)((0, index_js_6.dataSlice)(sender, 0, 12) === (0, index_js_6.dataSlice)(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
          reason: "corrupt OffchainLookup sender"
        });
        result.sender = (0, index_js_6.dataSlice)(sender, 12);
        try {
          const urls = [];
          const urlsOffset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, 32, 64));
          const urlsLength = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, urlsOffset, urlsOffset + 32));
          const urlsData = (0, index_js_6.dataSlice)(data, urlsOffset + 32);
          for (let u = 0; u < urlsLength; u++) {
            const url = _parseString(urlsData, u * 32);
            if (url == null) {
              throw new Error("abort");
            }
            urls.push(url);
          }
          result.urls = urls;
        } catch (error) {
          (0, index_js_6.assert)(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup urls"
          });
        }
        try {
          const calldata = _parseBytes(data, 64);
          if (calldata == null) {
            throw new Error("abort");
          }
          result.calldata = calldata;
        } catch (error) {
          (0, index_js_6.assert)(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup calldata"
          });
        }
        (0, index_js_6.assert)((0, index_js_6.dataSlice)(data, 100, 128) === (0, index_js_6.dataSlice)(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
          reason: "corrupt OffchainLookup callbaackSelector"
        });
        result.selector = (0, index_js_6.dataSlice)(data, 96, 100);
        try {
          const extraData = _parseBytes(data, 128);
          if (extraData == null) {
            throw new Error("abort");
          }
          result.extraData = extraData;
        } catch (error) {
          (0, index_js_6.assert)(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup extraData"
          });
        }
        result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(k => result[k]);
        return result;
      }
    },
    8401: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VoidSigner = exports.AbstractSigner = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(2877);
      const index_js_3 = __webpack_require__(9830);
      const provider_js_1 = __webpack_require__(1607);
      function checkProvider(signer, operation) {
        if (signer.provider) {
          return signer.provider;
        }
        (0, index_js_3.assert)(false, "missing provider", "UNSUPPORTED_OPERATION", {
          operation
        });
      }
      async function populate(signer, tx) {
        let pop = (0, provider_js_1.copyRequest)(tx);
        if (pop.to != null) {
          pop.to = (0, index_js_1.resolveAddress)(pop.to, signer);
        }
        if (pop.from != null) {
          const from = pop.from;
          pop.from = Promise.all([signer.getAddress(), (0, index_js_1.resolveAddress)(from, signer)]).then(([address, from]) => {
            (0, index_js_3.assertArgument)(address.toLowerCase() === from.toLowerCase(), "transaction from mismatch", "tx.from", from);
            return address;
          });
        } else {
          pop.from = signer.getAddress();
        }
        return await (0, index_js_3.resolveProperties)(pop);
      }
      class AbstractSigner {
        provider;
        constructor(provider) {
          (0, index_js_3.defineProperties)(this, {
            provider: provider || null
          });
        }
        async getNonce(blockTag) {
          return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
        }
        async populateCall(tx) {
          const pop = await populate(this, tx);
          return pop;
        }
        async populateTransaction(tx) {
          const provider = checkProvider(this, "populateTransaction");
          const pop = await populate(this, tx);
          if (pop.nonce == null) {
            pop.nonce = await this.getNonce("pending");
          }
          if (pop.gasLimit == null) {
            pop.gasLimit = await this.estimateGas(pop);
          }
          const network = await this.provider.getNetwork();
          if (pop.chainId != null) {
            const chainId = (0, index_js_3.getBigInt)(pop.chainId);
            (0, index_js_3.assertArgument)(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
          } else {
            pop.chainId = network.chainId;
          }
          const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
          if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
            (0, index_js_3.assertArgument)(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
          } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
            (0, index_js_3.assertArgument)(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
          }
          if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {
            pop.type = 2;
          } else if (pop.type === 0 || pop.type === 1) {
            const feeData = await provider.getFeeData();
            (0, index_js_3.assert)(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
              operation: "getGasPrice"
            });
            if (pop.gasPrice == null) {
              pop.gasPrice = feeData.gasPrice;
            }
          } else {
            const feeData = await provider.getFeeData();
            if (pop.type == null) {
              if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                pop.type = 2;
                if (pop.gasPrice != null) {
                  const gasPrice = pop.gasPrice;
                  delete pop.gasPrice;
                  pop.maxFeePerGas = gasPrice;
                  pop.maxPriorityFeePerGas = gasPrice;
                } else {
                  if (pop.maxFeePerGas == null) {
                    pop.maxFeePerGas = feeData.maxFeePerGas;
                  }
                  if (pop.maxPriorityFeePerGas == null) {
                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                  }
                }
              } else if (feeData.gasPrice != null) {
                (0, index_js_3.assert)(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                  operation: "populateTransaction"
                });
                if (pop.gasPrice == null) {
                  pop.gasPrice = feeData.gasPrice;
                }
                pop.type = 0;
              } else {
                (0, index_js_3.assert)(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                  operation: "signer.getFeeData"
                });
              }
            } else if (pop.type === 2) {
              if (pop.maxFeePerGas == null) {
                pop.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (pop.maxPriorityFeePerGas == null) {
                pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          }
          return await (0, index_js_3.resolveProperties)(pop);
        }
        async estimateGas(tx) {
          return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
        }
        async call(tx) {
          return checkProvider(this, "call").call(await this.populateCall(tx));
        }
        async resolveName(name) {
          const provider = checkProvider(this, "resolveName");
          return await provider.resolveName(name);
        }
        async sendTransaction(tx) {
          const provider = checkProvider(this, "sendTransaction");
          const pop = await this.populateTransaction(tx);
          delete pop.from;
          const txObj = index_js_2.Transaction.from(pop);
          return await provider.broadcastTransaction(await this.signTransaction(txObj));
        }
      }
      exports.AbstractSigner = AbstractSigner;
      class VoidSigner extends AbstractSigner {
        address;
        constructor(address, provider) {
          super(provider);
          (0, index_js_3.defineProperties)(this, {
            address
          });
        }
        async getAddress() {
          return this.address;
        }
        connect(provider) {
          return new VoidSigner(this.address, provider);
        }
        #throwUnsupported(suffix, operation) {
          (0, index_js_3.assert)(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", {
            operation
          });
        }
        async signTransaction(tx) {
          this.#throwUnsupported("transactions", "signTransaction");
        }
        async signMessage(message) {
          this.#throwUnsupported("messages", "signMessage");
        }
        async signTypedData(domain, types, value) {
          this.#throwUnsupported("typed-data", "signTypedData");
        }
      }
      exports.VoidSigner = VoidSigner;
    },
    1791: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.showThrottleMessage = void 0;
      const shown = new Set();
      function showThrottleMessage(service) {
        if (shown.has(service)) {
          return;
        }
        shown.add(service);
        console.log("========= NOTICE =========");
        console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
        console.log("");
        console.log("The default API keys for each service are provided as a highly-throttled,");
        console.log("community resource for low-traffic projects and early prototyping.");
        console.log("");
        console.log("While your application will continue to function, we highly recommended");
        console.log("signing up for your own API keys to improve performance, increase your");
        console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
        console.log("");
        console.log("For more details: https:/\/docs.ethers.org/api-keys/");
        console.log("==========================");
      }
      exports.showThrottleMessage = showThrottleMessage;
    },
    7241: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getDefaultProvider = void 0;
      const index_js_1 = __webpack_require__(9830);
      const provider_ankr_js_1 = __webpack_require__(7710);
      const provider_alchemy_js_1 = __webpack_require__(8782);
      const provider_cloudflare_js_1 = __webpack_require__(3844);
      const provider_etherscan_js_1 = __webpack_require__(5890);
      const provider_infura_js_1 = __webpack_require__(4390);
      const provider_quicknode_js_1 = __webpack_require__(6120);
      const provider_fallback_js_1 = __webpack_require__(9474);
      const provider_jsonrpc_js_1 = __webpack_require__(2314);
      const network_js_1 = __webpack_require__(7104);
      const provider_websocket_js_1 = __webpack_require__(8303);
      function isWebSocketLike(value) {
        return value && typeof value.send === "function" && typeof value.close === "function";
      }
      const Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
      function getDefaultProvider(network, options) {
        if (options == null) {
          options = {};
        }
        const allowService = name => {
          if (options[name] === "-") {
            return false;
          }
          if (typeof options.exclusive === "string") {
            return name === options.exclusive;
          }
          if (Array.isArray(options.exclusive)) {
            return options.exclusive.indexOf(name) !== -1;
          }
          return true;
        };
        if (typeof network === "string" && network.match(/^https?:/)) {
          return new provider_jsonrpc_js_1.JsonRpcProvider(network);
        }
        if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
          return new provider_websocket_js_1.WebSocketProvider(network);
        }
        let staticNetwork = null;
        try {
          staticNetwork = network_js_1.Network.from(network);
        } catch (error) {}
        const providers = [];
        if (allowService("publicPolygon") && staticNetwork) {
          if (staticNetwork.name === "matic") {
            providers.push(new provider_jsonrpc_js_1.JsonRpcProvider("https:/\/polygon-rpc.com/", staticNetwork, {
              staticNetwork
            }));
          }
        }
        if (allowService("alchemy")) {
          try {
            providers.push(new provider_alchemy_js_1.AlchemyProvider(network, options.alchemy));
          } catch (error) {}
        }
        if (allowService("ankr") && options.ankr != null) {
          try {
            providers.push(new provider_ankr_js_1.AnkrProvider(network, options.ankr));
          } catch (error) {}
        }
        if (allowService("cloudflare")) {
          try {
            providers.push(new provider_cloudflare_js_1.CloudflareProvider(network));
          } catch (error) {}
        }
        if (allowService("etherscan")) {
          try {
            providers.push(new provider_etherscan_js_1.EtherscanProvider(network, options.etherscan));
          } catch (error) {}
        }
        if (allowService("infura")) {
          try {
            let projectId = options.infura;
            let projectSecret = undefined;
            if (typeof projectId === "object") {
              projectSecret = projectId.projectSecret;
              projectId = projectId.projectId;
            }
            providers.push(new provider_infura_js_1.InfuraProvider(network, projectId, projectSecret));
          } catch (error) {}
        }
        if (allowService("quicknode")) {
          try {
            let token = options.quicknode;
            providers.push(new provider_quicknode_js_1.QuickNodeProvider(network, token));
          } catch (error) {}
        }
        (0, index_js_1.assert)(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
          operation: "getDefaultProvider"
        });
        if (providers.length === 1) {
          return providers[0];
        }
        let quorum = Math.floor(providers.length / 2);
        if (quorum > 2) {
          quorum = 2;
        }
        if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
          quorum = 1;
        }
        if (options && options.quorum) {
          quorum = options.quorum;
        }
        return new provider_fallback_js_1.FallbackProvider(providers, undefined, {
          quorum
        });
      }
      exports.getDefaultProvider = getDefaultProvider;
    },
    2518: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.EnsResolver = exports.BasicMulticoinProviderPlugin = exports.MulticoinProviderPlugin = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(4160);
      const index_js_3 = __webpack_require__(4464);
      const index_js_4 = __webpack_require__(5714);
      const index_js_5 = __webpack_require__(9830);
      function getIpfsLink(link) {
        if (link.match(/^ipfs:\/\/ipfs\//i)) {
          link = link.substring(12);
        } else if (link.match(/^ipfs:\/\//i)) {
          link = link.substring(7);
        } else {
          (0, index_js_5.assertArgument)(false, "unsupported IPFS format", "link", link);
        }
        return `https:/\/gateway.ipfs.io/ipfs/${link}`;
      }
      ;
      ;
      class MulticoinProviderPlugin {
        name;
        constructor(name) {
          (0, index_js_5.defineProperties)(this, {
            name
          });
        }
        connect(proivder) {
          return this;
        }
        supportsCoinType(coinType) {
          return false;
        }
        async encodeAddress(coinType, address) {
          throw new Error("unsupported coin");
        }
        async decodeAddress(coinType, data) {
          throw new Error("unsupported coin");
        }
      }
      exports.MulticoinProviderPlugin = MulticoinProviderPlugin;
      const BasicMulticoinPluginId = "org.ethers.plugins.provider.BasicMulticoin";
      class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {
        constructor() {
          super(BasicMulticoinPluginId);
        }
      }
      exports.BasicMulticoinProviderPlugin = BasicMulticoinProviderPlugin;
      const matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
      const matchers = [new RegExp("^(https):/\/(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), matcherIpfs, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];
      class EnsResolver {
        provider;
        address;
        name;
        #supports2544;
        #resolver;
        constructor(provider, address, name) {
          (0, index_js_5.defineProperties)(this, {
            provider,
            address,
            name
          });
          this.#supports2544 = null;
          this.#resolver = new index_js_3.Contract(address, ["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (bytes)", "function text(bytes32, string) view returns (string)", "function contenthash(bytes32) view returns (bytes)"], provider);
        }
        async supportsWildcard() {
          if (this.#supports2544 == null) {
            this.#supports2544 = (async () => {
              try {
                return await this.#resolver.supportsInterface("0x9061b923");
              } catch (error) {
                if ((0, index_js_5.isError)(error, "CALL_EXCEPTION")) {
                  return false;
                }
                this.#supports2544 = null;
                throw error;
              }
            })();
          }
          return await this.#supports2544;
        }
        async #fetch(funcName, params) {
          params = (params || []).slice();
          const iface = this.#resolver.interface;
          params.unshift((0, index_js_4.namehash)(this.name));
          let fragment = null;
          if (await this.supportsWildcard()) {
            fragment = iface.getFunction(funcName);
            (0, index_js_5.assert)(fragment, "missing fragment", "UNKNOWN_ERROR", {
              info: {
                funcName
              }
            });
            params = [(0, index_js_4.dnsEncode)(this.name), iface.encodeFunctionData(fragment, params)];
            funcName = "resolve(bytes,bytes)";
          }
          params.push({
            enableCcipRead: true
          });
          try {
            const result = await this.#resolver[funcName](...params);
            if (fragment) {
              return iface.decodeFunctionResult(fragment, result)[0];
            }
            return result;
          } catch (error) {
            if (!(0, index_js_5.isError)(error, "CALL_EXCEPTION")) {
              throw error;
            }
          }
          return null;
        }
        async getAddress(coinType) {
          if (coinType == null) {
            coinType = 60;
          }
          if (coinType === 60) {
            try {
              const result = await this.#fetch("addr(bytes32)");
              if (result == null || result === index_js_2.ZeroAddress) {
                return null;
              }
              return result;
            } catch (error) {
              if ((0, index_js_5.isError)(error, "CALL_EXCEPTION")) {
                return null;
              }
              throw error;
            }
          }
          if (coinType >= 0 && coinType < 0x80000000) {
            let ethCoinType = coinType + 0x80000000;
            const data = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
            if ((0, index_js_5.isHexString)(data, 20)) {
              return (0, index_js_1.getAddress)(data);
            }
          }
          let coinPlugin = null;
          for (const plugin of this.provider.plugins) {
            if (!(plugin instanceof MulticoinProviderPlugin)) {
              continue;
            }
            if (plugin.supportsCoinType(coinType)) {
              coinPlugin = plugin;
              break;
            }
          }
          if (coinPlugin == null) {
            return null;
          }
          const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
          if (data == null || data === "0x") {
            return null;
          }
          const address = await coinPlugin.decodeAddress(coinType, data);
          if (address != null) {
            return address;
          }
          (0, index_js_5.assert)(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
            operation: `getAddress(${coinType})`,
            info: {
              coinType,
              data
            }
          });
        }
        async getText(key) {
          const data = await this.#fetch("text(bytes32,string)", [key]);
          if (data == null || data === "0x") {
            return null;
          }
          return data;
        }
        async getContentHash() {
          const data = await this.#fetch("contenthash(bytes32)");
          if (data == null || data === "0x") {
            return null;
          }
          const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
          if (ipfs) {
            const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
            const length = parseInt(ipfs[4], 16);
            if (ipfs[5].length === length * 2) {
              return `${scheme}:/\/${(0, index_js_5.encodeBase58)("0x" + ipfs[2])}`;
            }
          }
          const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
          if (swarm && swarm[1].length === 64) {
            return `bzz:/\/${swarm[1]}`;
          }
          (0, index_js_5.assert)(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
            operation: "getContentHash()",
            info: {
              data
            }
          });
        }
        async getAvatar() {
          const avatar = await this._getAvatar();
          return avatar.url;
        }
        async _getAvatar() {
          const linkage = [{
            type: "name",
            value: this.name
          }];
          try {
            const avatar = await this.getText("avatar");
            if (avatar == null) {
              linkage.push({
                type: "!avatar",
                value: ""
              });
              return {
                url: null,
                linkage
              };
            }
            linkage.push({
              type: "avatar",
              value: avatar
            });
            for (let i = 0; i < matchers.length; i++) {
              const match = avatar.match(matchers[i]);
              if (match == null) {
                continue;
              }
              const scheme = match[1].toLowerCase();
              switch (scheme) {
                case "https":
                case "data":
                  linkage.push({
                    type: "url",
                    value: avatar
                  });
                  return {
                    linkage,
                    url: avatar
                  };
                case "ipfs":
                  {
                    const url = getIpfsLink(avatar);
                    linkage.push({
                      type: "ipfs",
                      value: avatar
                    });
                    linkage.push({
                      type: "url",
                      value: url
                    });
                    return {
                      linkage,
                      url
                    };
                  }
                case "erc721":
                case "erc1155":
                  {
                    const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
                    linkage.push({
                      type: scheme,
                      value: avatar
                    });
                    const owner = await this.getAddress();
                    if (owner == null) {
                      linkage.push({
                        type: "!owner",
                        value: ""
                      });
                      return {
                        url: null,
                        linkage
                      };
                    }
                    const comps = (match[2] || "").split("/");
                    if (comps.length !== 2) {
                      linkage.push({
                        type: `!${scheme}caip`,
                        value: match[2] || ""
                      });
                      return {
                        url: null,
                        linkage
                      };
                    }
                    const tokenId = comps[1];
                    const contract = new index_js_3.Contract(comps[0], ["function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)", "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"], this.provider);
                    if (scheme === "erc721") {
                      const tokenOwner = await contract.ownerOf(tokenId);
                      if (owner !== tokenOwner) {
                        linkage.push({
                          type: "!owner",
                          value: tokenOwner
                        });
                        return {
                          url: null,
                          linkage
                        };
                      }
                      linkage.push({
                        type: "owner",
                        value: tokenOwner
                      });
                    } else if (scheme === "erc1155") {
                      const balance = await contract.balanceOf(owner, tokenId);
                      if (!balance) {
                        linkage.push({
                          type: "!balance",
                          value: "0"
                        });
                        return {
                          url: null,
                          linkage
                        };
                      }
                      linkage.push({
                        type: "balance",
                        value: balance.toString()
                      });
                    }
                    let metadataUrl = await contract[selector](tokenId);
                    if (metadataUrl == null || metadataUrl === "0x") {
                      linkage.push({
                        type: "!metadata-url",
                        value: ""
                      });
                      return {
                        url: null,
                        linkage
                      };
                    }
                    linkage.push({
                      type: "metadata-url-base",
                      value: metadataUrl
                    });
                    if (scheme === "erc1155") {
                      metadataUrl = metadataUrl.replace("{id}", (0, index_js_5.toBeHex)(tokenId, 32).substring(2));
                      linkage.push({
                        type: "metadata-url-expanded",
                        value: metadataUrl
                      });
                    }
                    if (metadataUrl.match(/^ipfs:/i)) {
                      metadataUrl = getIpfsLink(metadataUrl);
                    }
                    linkage.push({
                      type: "metadata-url",
                      value: metadataUrl
                    });
                    let metadata = {};
                    const response = await new index_js_5.FetchRequest(metadataUrl).send();
                    response.assertOk();
                    try {
                      metadata = response.bodyJson;
                    } catch (error) {
                      try {
                        linkage.push({
                          type: "!metadata",
                          value: response.bodyText
                        });
                      } catch (error) {
                        const bytes = response.body;
                        if (bytes) {
                          linkage.push({
                            type: "!metadata",
                            value: (0, index_js_5.hexlify)(bytes)
                          });
                        }
                        return {
                          url: null,
                          linkage
                        };
                      }
                      return {
                        url: null,
                        linkage
                      };
                    }
                    if (!metadata) {
                      linkage.push({
                        type: "!metadata",
                        value: ""
                      });
                      return {
                        url: null,
                        linkage
                      };
                    }
                    linkage.push({
                      type: "metadata",
                      value: JSON.stringify(metadata)
                    });
                    let imageUrl = metadata.image;
                    if (typeof imageUrl !== "string") {
                      linkage.push({
                        type: "!imageUrl",
                        value: ""
                      });
                      return {
                        url: null,
                        linkage
                      };
                    }
                    if (imageUrl.match(/^(https:\/\/|data:)/i)) {} else {
                      const ipfs = imageUrl.match(matcherIpfs);
                      if (ipfs == null) {
                        linkage.push({
                          type: "!imageUrl-ipfs",
                          value: imageUrl
                        });
                        return {
                          url: null,
                          linkage
                        };
                      }
                      linkage.push({
                        type: "imageUrl-ipfs",
                        value: imageUrl
                      });
                      imageUrl = getIpfsLink(imageUrl);
                    }
                    linkage.push({
                      type: "url",
                      value: imageUrl
                    });
                    return {
                      linkage,
                      url: imageUrl
                    };
                  }
              }
            }
          } catch (error) {}
          return {
            linkage,
            url: null
          };
        }
        static async getEnsAddress(provider) {
          const network = await provider.getNetwork();
          const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
          (0, index_js_5.assert)(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
            operation: "getEnsAddress",
            info: {
              network
            }
          });
          return ensPlugin.address;
        }
        static async #getResolver(provider, name) {
          const ensAddr = await EnsResolver.getEnsAddress(provider);
          try {
            const contract = new index_js_3.Contract(ensAddr, ["function resolver(bytes32) view returns (address)"], provider);
            const addr = await contract.resolver((0, index_js_4.namehash)(name), {
              enableCcipRead: true
            });
            if (addr === index_js_2.ZeroAddress) {
              return null;
            }
            return addr;
          } catch (error) {
            throw error;
          }
          return null;
        }
        static async fromName(provider, name) {
          let currentName = name;
          while (true) {
            if (currentName === "" || currentName === ".") {
              return null;
            }
            if (name !== "eth" && currentName === "eth") {
              return null;
            }
            const addr = await EnsResolver.#getResolver(provider, currentName);
            if (addr != null) {
              const resolver = new EnsResolver(provider, addr, name);
              if (currentName !== name && !(await resolver.supportsWildcard())) {
                return null;
              }
              return resolver;
            }
            currentName = currentName.split(".").slice(1).join(".");
          }
        }
      }
      exports.EnsResolver = EnsResolver;
    },
    8585: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.formatTransactionResponse = exports.formatTransactionReceipt = exports.formatReceiptLog = exports.formatBlock = exports.formatLog = exports.formatUint256 = exports.formatHash = exports.formatData = exports.formatBoolean = exports.object = exports.arrayOf = exports.allowNull = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(9420);
      const index_js_3 = __webpack_require__(2877);
      const index_js_4 = __webpack_require__(9830);
      const BN_0 = BigInt(0);
      function allowNull(format, nullValue) {
        return function (value) {
          if (value == null) {
            return nullValue;
          }
          return format(value);
        };
      }
      exports.allowNull = allowNull;
      function arrayOf(format) {
        return array => {
          if (!Array.isArray(array)) {
            throw new Error("not an array");
          }
          return array.map(i => format(i));
        };
      }
      exports.arrayOf = arrayOf;
      function object(format, altNames) {
        return value => {
          const result = {};
          for (const key in format) {
            let srcKey = key;
            if (altNames && key in altNames && !(srcKey in value)) {
              for (const altKey of altNames[key]) {
                if (altKey in value) {
                  srcKey = altKey;
                  break;
                }
              }
            }
            try {
              const nv = format[key](value[srcKey]);
              if (nv !== undefined) {
                result[key] = nv;
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : "not-an-error";
              (0, index_js_4.assert)(false, `invalid value for value.${key} (${message})`, "BAD_DATA", {
                value
              });
            }
          }
          return result;
        };
      }
      exports.object = object;
      function formatBoolean(value) {
        switch (value) {
          case true:
          case "true":
            return true;
          case false:
          case "false":
            return false;
        }
        (0, index_js_4.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
      }
      exports.formatBoolean = formatBoolean;
      function formatData(value) {
        (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, true), "invalid data", "value", value);
        return value;
      }
      exports.formatData = formatData;
      function formatHash(value) {
        (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, 32), "invalid hash", "value", value);
        return value;
      }
      exports.formatHash = formatHash;
      function formatUint256(value) {
        if (!(0, index_js_4.isHexString)(value)) {
          throw new Error("invalid uint256");
        }
        return (0, index_js_4.zeroPadValue)(value, 32);
      }
      exports.formatUint256 = formatUint256;
      const _formatLog = object({
        address: index_js_1.getAddress,
        blockHash: formatHash,
        blockNumber: index_js_4.getNumber,
        data: formatData,
        index: index_js_4.getNumber,
        removed: allowNull(formatBoolean, false),
        topics: arrayOf(formatHash),
        transactionHash: formatHash,
        transactionIndex: index_js_4.getNumber
      }, {
        index: ["logIndex"]
      });
      function formatLog(value) {
        return _formatLog(value);
      }
      exports.formatLog = formatLog;
      const _formatBlock = object({
        hash: allowNull(formatHash),
        parentHash: formatHash,
        number: index_js_4.getNumber,
        timestamp: index_js_4.getNumber,
        nonce: allowNull(formatData),
        difficulty: index_js_4.getBigInt,
        gasLimit: index_js_4.getBigInt,
        gasUsed: index_js_4.getBigInt,
        miner: allowNull(index_js_1.getAddress),
        extraData: formatData,
        baseFeePerGas: allowNull(index_js_4.getBigInt)
      });
      function formatBlock(value) {
        const result = _formatBlock(value);
        result.transactions = value.transactions.map(tx => {
          if (typeof tx === "string") {
            return tx;
          }
          return formatTransactionResponse(tx);
        });
        return result;
      }
      exports.formatBlock = formatBlock;
      const _formatReceiptLog = object({
        transactionIndex: index_js_4.getNumber,
        blockNumber: index_js_4.getNumber,
        transactionHash: formatHash,
        address: index_js_1.getAddress,
        topics: arrayOf(formatHash),
        data: formatData,
        index: index_js_4.getNumber,
        blockHash: formatHash
      }, {
        index: ["logIndex"]
      });
      function formatReceiptLog(value) {
        return _formatReceiptLog(value);
      }
      exports.formatReceiptLog = formatReceiptLog;
      const _formatTransactionReceipt = object({
        to: allowNull(index_js_1.getAddress, null),
        from: allowNull(index_js_1.getAddress, null),
        contractAddress: allowNull(index_js_1.getAddress, null),
        index: index_js_4.getNumber,
        root: allowNull(index_js_4.hexlify),
        gasUsed: index_js_4.getBigInt,
        logsBloom: allowNull(formatData),
        blockHash: formatHash,
        hash: formatHash,
        logs: arrayOf(formatReceiptLog),
        blockNumber: index_js_4.getNumber,
        cumulativeGasUsed: index_js_4.getBigInt,
        effectiveGasPrice: allowNull(index_js_4.getBigInt),
        status: allowNull(index_js_4.getNumber),
        type: allowNull(index_js_4.getNumber, 0)
      }, {
        effectiveGasPrice: ["gasPrice"],
        hash: ["transactionHash"],
        index: ["transactionIndex"]
      });
      function formatTransactionReceipt(value) {
        return _formatTransactionReceipt(value);
      }
      exports.formatTransactionReceipt = formatTransactionReceipt;
      function formatTransactionResponse(value) {
        if (value.to && (0, index_js_4.getBigInt)(value.to) === BN_0) {
          value.to = "0x0000000000000000000000000000000000000000";
        }
        const result = object({
          hash: formatHash,
          type: value => {
            if (value === "0x" || value == null) {
              return 0;
            }
            return (0, index_js_4.getNumber)(value);
          },
          accessList: allowNull(index_js_3.accessListify, null),
          blockHash: allowNull(formatHash, null),
          blockNumber: allowNull(index_js_4.getNumber, null),
          transactionIndex: allowNull(index_js_4.getNumber, null),
          from: index_js_1.getAddress,
          gasPrice: allowNull(index_js_4.getBigInt),
          maxPriorityFeePerGas: allowNull(index_js_4.getBigInt),
          maxFeePerGas: allowNull(index_js_4.getBigInt),
          gasLimit: index_js_4.getBigInt,
          to: allowNull(index_js_1.getAddress, null),
          value: index_js_4.getBigInt,
          nonce: index_js_4.getNumber,
          data: formatData,
          creates: allowNull(index_js_1.getAddress, null),
          chainId: allowNull(index_js_4.getBigInt, null)
        }, {
          data: ["input"],
          gasLimit: ["gas"]
        })(value);
        if (result.to == null && result.creates == null) {
          result.creates = (0, index_js_1.getCreateAddress)(result);
        }
        if ((value.type === 1 || value.type === 2) && value.accessList == null) {
          result.accessList = [];
        }
        if (value.signature) {
          result.signature = index_js_2.Signature.from(value.signature);
        } else {
          result.signature = index_js_2.Signature.from(value);
        }
        if (result.chainId == null) {
          const chainId = result.signature.legacyChainId;
          if (chainId != null) {
            result.chainId = chainId;
          }
        }
        if (result.blockHash && (0, index_js_4.getBigInt)(result.blockHash) === BN_0) {
          result.blockHash = null;
        }
        return result;
      }
      exports.formatTransactionResponse = formatTransactionResponse;
    },
    3898: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanPlugin = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.copyRequest = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = exports.NonceManager = exports.Network = exports.MulticoinProviderPlugin = exports.EnsResolver = exports.getDefaultProvider = exports.showThrottleMessage = exports.VoidSigner = exports.AbstractSigner = exports.UnmanagedSubscriber = exports.AbstractProvider = void 0;
      var abstract_provider_js_1 = __webpack_require__(2629);
      Object.defineProperty(exports, "AbstractProvider", {
        enumerable: true,
        get: function () {
          return abstract_provider_js_1.AbstractProvider;
        }
      });
      Object.defineProperty(exports, "UnmanagedSubscriber", {
        enumerable: true,
        get: function () {
          return abstract_provider_js_1.UnmanagedSubscriber;
        }
      });
      var abstract_signer_js_1 = __webpack_require__(8401);
      Object.defineProperty(exports, "AbstractSigner", {
        enumerable: true,
        get: function () {
          return abstract_signer_js_1.AbstractSigner;
        }
      });
      Object.defineProperty(exports, "VoidSigner", {
        enumerable: true,
        get: function () {
          return abstract_signer_js_1.VoidSigner;
        }
      });
      var community_js_1 = __webpack_require__(1791);
      Object.defineProperty(exports, "showThrottleMessage", {
        enumerable: true,
        get: function () {
          return community_js_1.showThrottleMessage;
        }
      });
      var default_provider_js_1 = __webpack_require__(7241);
      Object.defineProperty(exports, "getDefaultProvider", {
        enumerable: true,
        get: function () {
          return default_provider_js_1.getDefaultProvider;
        }
      });
      var ens_resolver_js_1 = __webpack_require__(2518);
      Object.defineProperty(exports, "EnsResolver", {
        enumerable: true,
        get: function () {
          return ens_resolver_js_1.EnsResolver;
        }
      });
      Object.defineProperty(exports, "MulticoinProviderPlugin", {
        enumerable: true,
        get: function () {
          return ens_resolver_js_1.MulticoinProviderPlugin;
        }
      });
      var network_js_1 = __webpack_require__(7104);
      Object.defineProperty(exports, "Network", {
        enumerable: true,
        get: function () {
          return network_js_1.Network;
        }
      });
      var signer_noncemanager_js_1 = __webpack_require__(3671);
      Object.defineProperty(exports, "NonceManager", {
        enumerable: true,
        get: function () {
          return signer_noncemanager_js_1.NonceManager;
        }
      });
      var plugins_network_js_1 = __webpack_require__(3882);
      Object.defineProperty(exports, "NetworkPlugin", {
        enumerable: true,
        get: function () {
          return plugins_network_js_1.NetworkPlugin;
        }
      });
      Object.defineProperty(exports, "GasCostPlugin", {
        enumerable: true,
        get: function () {
          return plugins_network_js_1.GasCostPlugin;
        }
      });
      Object.defineProperty(exports, "EnsPlugin", {
        enumerable: true,
        get: function () {
          return plugins_network_js_1.EnsPlugin;
        }
      });
      Object.defineProperty(exports, "FeeDataNetworkPlugin", {
        enumerable: true,
        get: function () {
          return plugins_network_js_1.FeeDataNetworkPlugin;
        }
      });
      Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", {
        enumerable: true,
        get: function () {
          return plugins_network_js_1.FetchUrlFeeDataNetworkPlugin;
        }
      });
      var provider_js_1 = __webpack_require__(1607);
      Object.defineProperty(exports, "Block", {
        enumerable: true,
        get: function () {
          return provider_js_1.Block;
        }
      });
      Object.defineProperty(exports, "FeeData", {
        enumerable: true,
        get: function () {
          return provider_js_1.FeeData;
        }
      });
      Object.defineProperty(exports, "Log", {
        enumerable: true,
        get: function () {
          return provider_js_1.Log;
        }
      });
      Object.defineProperty(exports, "TransactionReceipt", {
        enumerable: true,
        get: function () {
          return provider_js_1.TransactionReceipt;
        }
      });
      Object.defineProperty(exports, "TransactionResponse", {
        enumerable: true,
        get: function () {
          return provider_js_1.TransactionResponse;
        }
      });
      Object.defineProperty(exports, "copyRequest", {
        enumerable: true,
        get: function () {
          return provider_js_1.copyRequest;
        }
      });
      var provider_fallback_js_1 = __webpack_require__(9474);
      Object.defineProperty(exports, "FallbackProvider", {
        enumerable: true,
        get: function () {
          return provider_fallback_js_1.FallbackProvider;
        }
      });
      var provider_jsonrpc_js_1 = __webpack_require__(2314);
      Object.defineProperty(exports, "JsonRpcApiProvider", {
        enumerable: true,
        get: function () {
          return provider_jsonrpc_js_1.JsonRpcApiProvider;
        }
      });
      Object.defineProperty(exports, "JsonRpcProvider", {
        enumerable: true,
        get: function () {
          return provider_jsonrpc_js_1.JsonRpcProvider;
        }
      });
      Object.defineProperty(exports, "JsonRpcSigner", {
        enumerable: true,
        get: function () {
          return provider_jsonrpc_js_1.JsonRpcSigner;
        }
      });
      var provider_browser_js_1 = __webpack_require__(7181);
      Object.defineProperty(exports, "BrowserProvider", {
        enumerable: true,
        get: function () {
          return provider_browser_js_1.BrowserProvider;
        }
      });
      var provider_alchemy_js_1 = __webpack_require__(8782);
      Object.defineProperty(exports, "AlchemyProvider", {
        enumerable: true,
        get: function () {
          return provider_alchemy_js_1.AlchemyProvider;
        }
      });
      var provider_ankr_js_1 = __webpack_require__(7710);
      Object.defineProperty(exports, "AnkrProvider", {
        enumerable: true,
        get: function () {
          return provider_ankr_js_1.AnkrProvider;
        }
      });
      var provider_cloudflare_js_1 = __webpack_require__(3844);
      Object.defineProperty(exports, "CloudflareProvider", {
        enumerable: true,
        get: function () {
          return provider_cloudflare_js_1.CloudflareProvider;
        }
      });
      var provider_etherscan_js_1 = __webpack_require__(5890);
      Object.defineProperty(exports, "EtherscanProvider", {
        enumerable: true,
        get: function () {
          return provider_etherscan_js_1.EtherscanProvider;
        }
      });
      Object.defineProperty(exports, "EtherscanPlugin", {
        enumerable: true,
        get: function () {
          return provider_etherscan_js_1.EtherscanPlugin;
        }
      });
      var provider_infura_js_1 = __webpack_require__(4390);
      Object.defineProperty(exports, "InfuraProvider", {
        enumerable: true,
        get: function () {
          return provider_infura_js_1.InfuraProvider;
        }
      });
      Object.defineProperty(exports, "InfuraWebSocketProvider", {
        enumerable: true,
        get: function () {
          return provider_infura_js_1.InfuraWebSocketProvider;
        }
      });
      var provider_pocket_js_1 = __webpack_require__(8938);
      Object.defineProperty(exports, "PocketProvider", {
        enumerable: true,
        get: function () {
          return provider_pocket_js_1.PocketProvider;
        }
      });
      var provider_quicknode_js_1 = __webpack_require__(6120);
      Object.defineProperty(exports, "QuickNodeProvider", {
        enumerable: true,
        get: function () {
          return provider_quicknode_js_1.QuickNodeProvider;
        }
      });
      const provider_ipcsocket_js_1 = __webpack_require__(8282);
      Object.defineProperty(exports, "IpcSocketProvider", {
        enumerable: true,
        get: function () {
          return provider_ipcsocket_js_1.IpcSocketProvider;
        }
      });
      var provider_socket_js_1 = __webpack_require__(518);
      Object.defineProperty(exports, "SocketProvider", {
        enumerable: true,
        get: function () {
          return provider_socket_js_1.SocketProvider;
        }
      });
      var provider_websocket_js_1 = __webpack_require__(8303);
      Object.defineProperty(exports, "WebSocketProvider", {
        enumerable: true,
        get: function () {
          return provider_websocket_js_1.WebSocketProvider;
        }
      });
      var provider_socket_js_2 = __webpack_require__(518);
      Object.defineProperty(exports, "SocketSubscriber", {
        enumerable: true,
        get: function () {
          return provider_socket_js_2.SocketSubscriber;
        }
      });
      Object.defineProperty(exports, "SocketBlockSubscriber", {
        enumerable: true,
        get: function () {
          return provider_socket_js_2.SocketBlockSubscriber;
        }
      });
      Object.defineProperty(exports, "SocketPendingSubscriber", {
        enumerable: true,
        get: function () {
          return provider_socket_js_2.SocketPendingSubscriber;
        }
      });
      Object.defineProperty(exports, "SocketEventSubscriber", {
        enumerable: true,
        get: function () {
          return provider_socket_js_2.SocketEventSubscriber;
        }
      });
    },
    7104: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Network = void 0;
      const index_js_1 = __webpack_require__(2877);
      const index_js_2 = __webpack_require__(9830);
      const plugins_network_js_1 = __webpack_require__(3882);
      const Networks = new Map();
      class Network {
        #name;
        #chainId;
        #plugins;
        constructor(name, chainId) {
          this.#name = name;
          this.#chainId = (0, index_js_2.getBigInt)(chainId);
          this.#plugins = new Map();
        }
        toJSON() {
          return {
            name: this.name,
            chainId: String(this.chainId)
          };
        }
        get name() {
          return this.#name;
        }
        set name(value) {
          this.#name = value;
        }
        get chainId() {
          return this.#chainId;
        }
        set chainId(value) {
          this.#chainId = (0, index_js_2.getBigInt)(value, "chainId");
        }
        matches(other) {
          if (other == null) {
            return false;
          }
          if (typeof other === "string") {
            try {
              return this.chainId === (0, index_js_2.getBigInt)(other);
            } catch (error) {}
            return this.name === other;
          }
          if (typeof other === "number" || typeof other === "bigint") {
            try {
              return this.chainId === (0, index_js_2.getBigInt)(other);
            } catch (error) {}
            return false;
          }
          if (typeof other === "object") {
            if (other.chainId != null) {
              try {
                return this.chainId === (0, index_js_2.getBigInt)(other.chainId);
              } catch (error) {}
              return false;
            }
            if (other.name != null) {
              return this.name === other.name;
            }
            return false;
          }
          return false;
        }
        get plugins() {
          return Array.from(this.#plugins.values());
        }
        attachPlugin(plugin) {
          if (this.#plugins.get(plugin.name)) {
            throw new Error(`cannot replace existing plugin: ${plugin.name} `);
          }
          this.#plugins.set(plugin.name, plugin.clone());
          return this;
        }
        getPlugin(name) {
          return this.#plugins.get(name) || null;
        }
        getPlugins(basename) {
          return this.plugins.filter(p => p.name.split("#")[0] === basename);
        }
        clone() {
          const clone = new Network(this.name, this.chainId);
          this.plugins.forEach(plugin => {
            clone.attachPlugin(plugin.clone());
          });
          return clone;
        }
        computeIntrinsicGas(tx) {
          const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new plugins_network_js_1.GasCostPlugin();
          let gas = costs.txBase;
          if (tx.to == null) {
            gas += costs.txCreate;
          }
          if (tx.data) {
            for (let i = 2; i < tx.data.length; i += 2) {
              if (tx.data.substring(i, i + 2) === "00") {
                gas += costs.txDataZero;
              } else {
                gas += costs.txDataNonzero;
              }
            }
          }
          if (tx.accessList) {
            const accessList = (0, index_js_1.accessListify)(tx.accessList);
            for (const addr in accessList) {
              gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
            }
          }
          return gas;
        }
        static from(network) {
          injectCommonNetworks();
          if (network == null) {
            return Network.from("mainnet");
          }
          if (typeof network === "number") {
            network = BigInt(network);
          }
          if (typeof network === "string" || typeof network === "bigint") {
            const networkFunc = Networks.get(network);
            if (networkFunc) {
              return networkFunc();
            }
            if (typeof network === "bigint") {
              return new Network("unknown", network);
            }
            (0, index_js_2.assertArgument)(false, "unknown network", "network", network);
          }
          if (typeof network.clone === "function") {
            const clone = network.clone();
            return clone;
          }
          if (typeof network === "object") {
            (0, index_js_2.assertArgument)(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
            const custom = new Network(network.name, network.chainId);
            if (network.ensAddress || network.ensNetwork != null) {
              custom.attachPlugin(new plugins_network_js_1.EnsPlugin(network.ensAddress, network.ensNetwork));
            }
            return custom;
          }
          (0, index_js_2.assertArgument)(false, "invalid network", "network", network);
        }
        static register(nameOrChainId, networkFunc) {
          if (typeof nameOrChainId === "number") {
            nameOrChainId = BigInt(nameOrChainId);
          }
          const existing = Networks.get(nameOrChainId);
          if (existing) {
            (0, index_js_2.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
          }
          Networks.set(nameOrChainId, networkFunc);
        }
      }
      exports.Network = Network;
      function parseUnits(_value, decimals) {
        const value = String(_value);
        if (!value.match(/^[0-9.]+$/)) {
          throw new Error(`invalid gwei value: ${_value}`);
        }
        const comps = value.split(".");
        if (comps.length === 1) {
          comps.push("");
        }
        if (comps.length !== 2) {
          throw new Error(`invalid gwei value: ${_value}`);
        }
        while (comps[1].length < decimals) {
          comps[1] += "0";
        }
        if (comps[1].length > 9) {
          let frac = BigInt(comps[1].substring(0, 9));
          if (!comps[1].substring(9).match(/^0+$/)) {
            frac++;
          }
          comps[1] = frac.toString();
        }
        return BigInt(comps[0] + comps[1]);
      }
      function getGasStationPlugin(url) {
        return new plugins_network_js_1.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
          request.setHeader("User-Agent", "ethers");
          let response;
          try {
            const [_response, _feeData] = await Promise.all([request.send(), fetchFeeData()]);
            response = _response;
            const payload = response.bodyJson.standard;
            const feeData = {
              gasPrice: _feeData.gasPrice,
              maxFeePerGas: parseUnits(payload.maxFee, 9),
              maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
            };
            return feeData;
          } catch (error) {
            (0, index_js_2.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", {
              request,
              response,
              error
            });
          }
        });
      }
      function getPriorityFeePlugin(maxPriorityFeePerGas) {
        return new plugins_network_js_1.FetchUrlFeeDataNetworkPlugin("data:", async (fetchFeeData, provider, request) => {
          const feeData = await fetchFeeData();
          if (feeData.maxFeePerGas == null || feeData.maxPriorityFeePerGas == null) {
            return feeData;
          }
          const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;
          return {
            gasPrice: feeData.gasPrice,
            maxFeePerGas: baseFee + maxPriorityFeePerGas,
            maxPriorityFeePerGas
          };
        });
      }
      let injected = false;
      function injectCommonNetworks() {
        if (injected) {
          return;
        }
        injected = true;
        function registerEth(name, chainId, options) {
          const func = function () {
            const network = new Network(name, chainId);
            if (options.ensNetwork != null) {
              network.attachPlugin(new plugins_network_js_1.EnsPlugin(null, options.ensNetwork));
            }
            network.attachPlugin(new plugins_network_js_1.GasCostPlugin());
            (options.plugins || []).forEach(plugin => {
              network.attachPlugin(plugin);
            });
            return network;
          };
          Network.register(name, func);
          Network.register(chainId, func);
          if (options.altNames) {
            options.altNames.forEach(name => {
              Network.register(name, func);
            });
          }
        }
        registerEth("mainnet", 1, {
          ensNetwork: 1,
          altNames: ["homestead"]
        });
        registerEth("ropsten", 3, {
          ensNetwork: 3
        });
        registerEth("rinkeby", 4, {
          ensNetwork: 4
        });
        registerEth("goerli", 5, {
          ensNetwork: 5
        });
        registerEth("kovan", 42, {
          ensNetwork: 42
        });
        registerEth("sepolia", 11155111, {});
        registerEth("classic", 61, {});
        registerEth("classicKotti", 6, {});
        registerEth("arbitrum", 42161, {
          ensNetwork: 1
        });
        registerEth("arbitrum-goerli", 421613, {});
        registerEth("bnb", 56, {
          ensNetwork: 1
        });
        registerEth("bnbt", 97, {});
        registerEth("linea", 59144, {
          ensNetwork: 1
        });
        registerEth("linea-goerli", 59140, {});
        registerEth("matic", 137, {
          ensNetwork: 1,
          plugins: [getGasStationPlugin("https:/\/gasstation.polygon.technology/v2")]
        });
        registerEth("matic-mumbai", 80001, {
          altNames: ["maticMumbai", "maticmum"],
          plugins: [getGasStationPlugin("https:/\/gasstation-testnet.polygon.technology/v2")]
        });
        registerEth("optimism", 10, {
          ensNetwork: 1,
          plugins: [getPriorityFeePlugin(BigInt("1000000"))]
        });
        registerEth("optimism-goerli", 420, {});
        registerEth("xdai", 100, {
          ensNetwork: 1
        });
      }
    },
    3882: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = void 0;
      const properties_js_1 = __webpack_require__(9795);
      const index_js_1 = __webpack_require__(9830);
      const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
      class NetworkPlugin {
        name;
        constructor(name) {
          (0, properties_js_1.defineProperties)(this, {
            name
          });
        }
        clone() {
          return new NetworkPlugin(this.name);
        }
      }
      exports.NetworkPlugin = NetworkPlugin;
      class GasCostPlugin extends NetworkPlugin {
        effectiveBlock;
        txBase;
        txCreate;
        txDataZero;
        txDataNonzero;
        txAccessListStorageKey;
        txAccessListAddress;
        constructor(effectiveBlock, costs) {
          if (effectiveBlock == null) {
            effectiveBlock = 0;
          }
          super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
          const props = {
            effectiveBlock
          };
          function set(name, nullish) {
            let value = (costs || {})[name];
            if (value == null) {
              value = nullish;
            }
            (0, index_js_1.assertArgument)(typeof value === "number", `invalud value for ${name}`, "costs", costs);
            props[name] = value;
          }
          set("txBase", 21000);
          set("txCreate", 32000);
          set("txDataZero", 4);
          set("txDataNonzero", 16);
          set("txAccessListStorageKey", 1900);
          set("txAccessListAddress", 2400);
          (0, properties_js_1.defineProperties)(this, props);
        }
        clone() {
          return new GasCostPlugin(this.effectiveBlock, this);
        }
      }
      exports.GasCostPlugin = GasCostPlugin;
      class EnsPlugin extends NetworkPlugin {
        address;
        targetNetwork;
        constructor(address, targetNetwork) {
          super("org.ethers.plugins.network.Ens");
          (0, properties_js_1.defineProperties)(this, {
            address: address || EnsAddress,
            targetNetwork: targetNetwork == null ? 1 : targetNetwork
          });
        }
        clone() {
          return new EnsPlugin(this.address, this.targetNetwork);
        }
      }
      exports.EnsPlugin = EnsPlugin;
      class FeeDataNetworkPlugin extends NetworkPlugin {
        #feeDataFunc;
        get feeDataFunc() {
          return this.#feeDataFunc;
        }
        constructor(feeDataFunc) {
          super("org.ethers.plugins.network.FeeData");
          this.#feeDataFunc = feeDataFunc;
        }
        async getFeeData(provider) {
          return await this.#feeDataFunc(provider);
        }
        clone() {
          return new FeeDataNetworkPlugin(this.#feeDataFunc);
        }
      }
      exports.FeeDataNetworkPlugin = FeeDataNetworkPlugin;
      class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
        #url;
        #processFunc;
        get url() {
          return this.#url;
        }
        get processFunc() {
          return this.#processFunc;
        }
        constructor(url, processFunc) {
          super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
          this.#url = url;
          this.#processFunc = processFunc;
        }
        clone() {
          return this;
        }
      }
      exports.FetchUrlFeeDataNetworkPlugin = FetchUrlFeeDataNetworkPlugin;
    },
    8782: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AlchemyProvider = void 0;
      const index_js_1 = __webpack_require__(9830);
      const community_js_1 = __webpack_require__(1791);
      const network_js_1 = __webpack_require__(7104);
      const provider_jsonrpc_js_1 = __webpack_require__(2314);
      const defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
      function getHost(name) {
        switch (name) {
          case "mainnet":
            return "eth-mainnet.alchemyapi.io";
          case "goerli":
            return "eth-goerli.g.alchemy.com";
          case "sepolia":
            return "eth-sepolia.g.alchemy.com";
          case "arbitrum":
            return "arb-mainnet.g.alchemy.com";
          case "arbitrum-goerli":
            return "arb-goerli.g.alchemy.com";
          case "matic":
            return "polygon-mainnet.g.alchemy.com";
          case "matic-mumbai":
            return "polygon-mumbai.g.alchemy.com";
          case "optimism":
            return "opt-mainnet.g.alchemy.com";
          case "optimism-goerli":
            return "opt-goerli.g.alchemy.com";
        }
        (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
      }
      class AlchemyProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
        apiKey;
        constructor(_network, apiKey) {
          if (_network == null) {
            _network = "mainnet";
          }
          const network = network_js_1.Network.from(_network);
          if (apiKey == null) {
            apiKey = defaultApiKey;
          }
          const request = AlchemyProvider.getRequest(network, apiKey);
          super(request, network, {
            staticNetwork: network
          });
          (0, index_js_1.defineProperties)(this, {
            apiKey
          });
        }
        _getProvider(chainId) {
          try {
            return new AlchemyProvider(chainId, this.apiKey);
          } catch (error) {}
          return super._getProvider(chainId);
        }
        async _perform(req) {
          if (req.method === "getTransactionResult") {
            const {
              trace,
              tx
            } = await (0, index_js_1.resolveProperties)({
              trace: this.send("trace_transaction", [req.hash]),
              tx: this.getTransaction(req.hash)
            });
            if (trace == null || tx == null) {
              return null;
            }
            let data;
            let error = false;
            try {
              data = trace[0].result.output;
              error = trace[0].error === "Reverted";
            } catch (error) {}
            if (data) {
              (0, index_js_1.assert)(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
                action: "getTransactionResult",
                data,
                reason: null,
                transaction: tx,
                invocation: null,
                revert: null
              });
              return data;
            }
            (0, index_js_1.assert)(false, "could not parse trace result", "BAD_DATA", {
              value: trace
            });
          }
          return await super._perform(req);
        }
        isCommunityResource() {
          return this.apiKey === defaultApiKey;
        }
        static getRequest(network, apiKey) {
          if (apiKey == null) {
            apiKey = defaultApiKey;
          }
          const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/v2/${apiKey}`);
          request.allowGzip = true;
          if (apiKey === defaultApiKey) {
            request.retryFunc = async (request, response, attempt) => {
              (0, community_js_1.showThrottleMessage)("alchemy");
              return true;
            };
          }
          return request;
        }
      }
      exports.AlchemyProvider = AlchemyProvider;
    },
    7710: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AnkrProvider = void 0;
      const index_js_1 = __webpack_require__(9830);
      const community_js_1 = __webpack_require__(1791);
      const network_js_1 = __webpack_require__(7104);
      const provider_jsonrpc_js_1 = __webpack_require__(2314);
      const defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
      function getHost(name) {
        switch (name) {
          case "mainnet":
            return "rpc.ankr.com/eth";
          case "goerli":
            return "rpc.ankr.com/eth_goerli";
          case "matic":
            return "rpc.ankr.com/polygon";
          case "arbitrum":
            return "rpc.ankr.com/arbitrum";
        }
        (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
      }
      class AnkrProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
        apiKey;
        constructor(_network, apiKey) {
          if (_network == null) {
            _network = "mainnet";
          }
          const network = network_js_1.Network.from(_network);
          if (apiKey == null) {
            apiKey = defaultApiKey;
          }
          const options = {
            polling: true,
            staticNetwork: network
          };
          const request = AnkrProvider.getRequest(network, apiKey);
          super(request, network, options);
          (0, index_js_1.defineProperties)(this, {
            apiKey
          });
        }
        _getProvider(chainId) {
          try {
            return new AnkrProvider(chainId, this.apiKey);
          } catch (error) {}
          return super._getProvider(chainId);
        }
        static getRequest(network, apiKey) {
          if (apiKey == null) {
            apiKey = defaultApiKey;
          }
          const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/${apiKey}`);
          request.allowGzip = true;
          if (apiKey === defaultApiKey) {
            request.retryFunc = async (request, response, attempt) => {
              (0, community_js_1.showThrottleMessage)("AnkrProvider");
              return true;
            };
          }
          return request;
        }
        getRpcError(payload, error) {
          if (payload.method === "eth_sendRawTransaction") {
            if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
              error.error.message = "replacement transaction underpriced";
            }
          }
          return super.getRpcError(payload, error);
        }
        isCommunityResource() {
          return this.apiKey === defaultApiKey;
        }
      }
      exports.AnkrProvider = AnkrProvider;
    },
    7181: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BrowserProvider = void 0;
      const index_js_1 = __webpack_require__(9830);
      const provider_jsonrpc_js_1 = __webpack_require__(2314);
      ;
      class BrowserProvider extends provider_jsonrpc_js_1.JsonRpcApiPollingProvider {
        #request;
        constructor(ethereum, network) {
          super(network, {
            batchMaxCount: 1
          });
          this.#request = async (method, params) => {
            const payload = {
              method,
              params
            };
            this.emit("debug", {
              action: "sendEip1193Request",
              payload
            });
            try {
              const result = await ethereum.request(payload);
              this.emit("debug", {
                action: "receiveEip1193Result",
                result
              });
              return result;
            } catch (e) {
              const error = new Error(e.message);
              error.code = e.code;
              error.data = e.data;
              error.payload = payload;
              this.emit("debug", {
                action: "receiveEip1193Error",
                error
              });
              throw error;
            }
          };
        }
        async send(method, params) {
          await this._start();
          return await super.send(method, params);
        }
        async _send(payload) {
          (0, index_js_1.assertArgument)(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
          try {
            const result = await this.#request(payload.method, payload.params || []);
            return [{
              id: payload.id,
              result
            }];
          } catch (e) {
            return [{
              id: payload.id,
              error: {
                code: e.code,
                data: e.data,
                message: e.message
              }
            }];
          }
        }
        getRpcError(payload, error) {
          error = JSON.parse(JSON.stringify(error));
          switch (error.error.code || -1) {
            case 4001:
              error.error.message = `ethers-user-denied: ${error.error.message}`;
              break;
            case 4200:
              error.error.message = `ethers-unsupported: ${error.error.message}`;
              break;
          }
          return super.getRpcError(payload, error);
        }
        async hasSigner(address) {
          if (address == null) {
            address = 0;
          }
          const accounts = await this.send("eth_accounts", []);
          if (typeof address === "number") {
            return accounts.length > address;
          }
          address = address.toLowerCase();
          return accounts.filter(a => a.toLowerCase() === address).length !== 0;
        }
        async getSigner(address) {
          if (address == null) {
            address = 0;
          }
          if (!(await this.hasSigner(address))) {
            try {
              await this.#request("eth_requestAccounts", []);
            } catch (error) {
              const payload = error.payload;
              throw this.getRpcError(payload, {
                id: payload.id,
                error
              });
            }
          }
          return await super.getSigner(address);
        }
      }
      exports.BrowserProvider = BrowserProvider;
    },
    3844: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CloudflareProvider = void 0;
      const index_js_1 = __webpack_require__(9830);
      const network_js_1 = __webpack_require__(7104);
      const provider_jsonrpc_js_1 = __webpack_require__(2314);
      class CloudflareProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
        constructor(_network) {
          if (_network == null) {
            _network = "mainnet";
          }
          const network = network_js_1.Network.from(_network);
          (0, index_js_1.assertArgument)(network.name === "mainnet", "unsupported network", "network", _network);
          super("https:/\/cloudflare-eth.com/", network, {
            staticNetwork: network
          });
        }
      }
      exports.CloudflareProvider = CloudflareProvider;
    },
    5890: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.EtherscanProvider = exports.EtherscanPlugin = void 0;
      const index_js_1 = __webpack_require__(5262);
      const index_js_2 = __webpack_require__(4464);
      const index_js_3 = __webpack_require__(2877);
      const index_js_4 = __webpack_require__(9830);
      const abstract_provider_js_1 = __webpack_require__(2629);
      const network_js_1 = __webpack_require__(7104);
      const plugins_network_js_1 = __webpack_require__(3882);
      const community_js_1 = __webpack_require__(1791);
      const THROTTLE = 2000;
      function isPromise(value) {
        return value && typeof value.then === "function";
      }
      const EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
      class EtherscanPlugin extends plugins_network_js_1.NetworkPlugin {
        baseUrl;
        constructor(baseUrl) {
          super(EtherscanPluginId);
          (0, index_js_4.defineProperties)(this, {
            baseUrl
          });
        }
        clone() {
          return new EtherscanPlugin(this.baseUrl);
        }
      }
      exports.EtherscanPlugin = EtherscanPlugin;
      const skipKeys = ["enableCcipRead"];
      let nextId = 1;
      class EtherscanProvider extends abstract_provider_js_1.AbstractProvider {
        network;
        apiKey;
        #plugin;
        constructor(_network, _apiKey) {
          const apiKey = _apiKey != null ? _apiKey : null;
          super();
          const network = network_js_1.Network.from(_network);
          this.#plugin = network.getPlugin(EtherscanPluginId);
          (0, index_js_4.defineProperties)(this, {
            apiKey,
            network
          });
          this.getBaseUrl();
        }
        getBaseUrl() {
          if (this.#plugin) {
            return this.#plugin.baseUrl;
          }
          switch (this.network.name) {
            case "mainnet":
              return "https:/\/api.etherscan.io";
            case "goerli":
              return "https:/\/api-goerli.etherscan.io";
            case "sepolia":
              return "https:/\/api-sepolia.etherscan.io";
            case "arbitrum":
              return "https:/\/api.arbiscan.io";
            case "arbitrum-goerli":
              return "https:/\/api-goerli.arbiscan.io";
            case "matic":
              return "https:/\/api.polygonscan.com";
            case "matic-mumbai":
              return "https:/\/api-testnet.polygonscan.com";
            case "optimism":
              return "https:/\/api-optimistic.etherscan.io";
            case "optimism-goerli":
              return "https:/\/api-goerli-optimistic.etherscan.io";
            case "bnb":
              return "http:/\/api.bscscan.com";
            case "bnbt":
              return "http:/\/api-testnet.bscscan.com";
            default:
          }
          (0, index_js_4.assertArgument)(false, "unsupported network", "network", this.network);
        }
        getUrl(module, params) {
          const query = Object.keys(params).reduce((accum, key) => {
            const value = params[key];
            if (value != null) {
              accum += `&${key}=${value}`;
            }
            return accum;
          }, "");
          const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
          return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;
        }
        getPostUrl() {
          return `${this.getBaseUrl()}/api`;
        }
        getPostData(module, params) {
          params.module = module;
          params.apikey = this.apiKey;
          return params;
        }
        async detectNetwork() {
          return this.network;
        }
        async fetch(module, params, post) {
          const id = nextId++;
          const url = post ? this.getPostUrl() : this.getUrl(module, params);
          const payload = post ? this.getPostData(module, params) : null;
          this.emit("debug", {
            action: "sendRequest",
            id,
            url,
            payload: payload
          });
          const request = new index_js_4.FetchRequest(url);
          request.setThrottleParams({
            slotInterval: 1000
          });
          request.retryFunc = (req, resp, attempt) => {
            if (this.isCommunityResource()) {
              (0, community_js_1.showThrottleMessage)("Etherscan");
            }
            return Promise.resolve(true);
          };
          request.processFunc = async (request, response) => {
            const result = response.hasBody() ? JSON.parse((0, index_js_4.toUtf8String)(response.body)) : {};
            const throttle = (typeof result.result === "string" ? result.result : "").toLowerCase().indexOf("rate limit") >= 0;
            if (module === "proxy") {
              if (result && result.status == 0 && result.message == "NOTOK" && throttle) {
                this.emit("debug", {
                  action: "receiveError",
                  id,
                  reason: "proxy-NOTOK",
                  error: result
                });
                response.throwThrottleError(result.result, THROTTLE);
              }
            } else {
              if (throttle) {
                this.emit("debug", {
                  action: "receiveError",
                  id,
                  reason: "null result",
                  error: result.result
                });
                response.throwThrottleError(result.result, THROTTLE);
              }
            }
            return response;
          };
          if (payload) {
            request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
            request.body = Object.keys(payload).map(k => `${k}=${payload[k]}`).join("&");
          }
          const response = await request.send();
          try {
            response.assertOk();
          } catch (error) {
            this.emit("debug", {
              action: "receiveError",
              id,
              error,
              reason: "assertOk"
            });
            (0, index_js_4.assert)(false, "response error", "SERVER_ERROR", {
              request,
              response
            });
          }
          if (!response.hasBody()) {
            this.emit("debug", {
              action: "receiveError",
              id,
              error: "missing body",
              reason: "null body"
            });
            (0, index_js_4.assert)(false, "missing response", "SERVER_ERROR", {
              request,
              response
            });
          }
          const result = JSON.parse((0, index_js_4.toUtf8String)(response.body));
          if (module === "proxy") {
            if (result.jsonrpc != "2.0") {
              this.emit("debug", {
                action: "receiveError",
                id,
                result,
                reason: "invalid JSON-RPC"
              });
              (0, index_js_4.assert)(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", {
                request,
                response,
                info: {
                  result
                }
              });
            }
            if (result.error) {
              this.emit("debug", {
                action: "receiveError",
                id,
                result,
                reason: "JSON-RPC error"
              });
              (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", {
                request,
                response,
                info: {
                  result
                }
              });
            }
            this.emit("debug", {
              action: "receiveRequest",
              id,
              result
            });
            return result.result;
          } else {
            if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
              this.emit("debug", {
                action: "receiveRequest",
                id,
                result
              });
              return result.result;
            }
            if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
              this.emit("debug", {
                action: "receiveError",
                id,
                result
              });
              (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", {
                request,
                response,
                info: {
                  result
                }
              });
            }
            this.emit("debug", {
              action: "receiveRequest",
              id,
              result
            });
            return result.result;
          }
        }
        _getTransactionPostData(transaction) {
          const result = {};
          for (let key in transaction) {
            if (skipKeys.indexOf(key) >= 0) {
              continue;
            }
            if (transaction[key] == null) {
              continue;
            }
            let value = transaction[key];
            if (key === "type" && value === 0) {
              continue;
            }
            if ({
              type: true,
              gasLimit: true,
              gasPrice: true,
              maxFeePerGs: true,
              maxPriorityFeePerGas: true,
              nonce: true,
              value: true
            }[key]) {
              value = (0, index_js_4.toQuantity)(value);
            } else if (key === "accessList") {
              value = "[" + (0, index_js_3.accessListify)(value).map(set => {
                return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
              }).join(",") + "]";
            } else {
              value = (0, index_js_4.hexlify)(value);
            }
            result[key] = value;
          }
          return result;
        }
        _checkError(req, error, transaction) {
          let message = "";
          if ((0, index_js_4.isError)(error, "SERVER_ERROR")) {
            try {
              message = error.info.result.error.message;
            } catch (e) {}
            if (!message) {
              try {
                message = error.info.message;
              } catch (e) {}
            }
          }
          if (req.method === "estimateGas") {
            if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
              (0, index_js_4.assert)(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
                transaction: req.transaction
              });
            }
          }
          if (req.method === "call" || req.method === "estimateGas") {
            if (message.match(/execution reverted/i)) {
              let data = "";
              try {
                data = error.info.result.error.data;
              } catch (error) {}
              const e = index_js_1.AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
              e.info = {
                request: req,
                error
              };
              throw e;
            }
          }
          if (message) {
            if (req.method === "broadcastTransaction") {
              const transaction = index_js_3.Transaction.from(req.signedTransaction);
              if (message.match(/replacement/i) && message.match(/underpriced/i)) {
                (0, index_js_4.assert)(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                  transaction
                });
              }
              if (message.match(/insufficient funds/)) {
                (0, index_js_4.assert)(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                  transaction
                });
              }
              if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
                (0, index_js_4.assert)(false, "nonce has already been used", "NONCE_EXPIRED", {
                  transaction
                });
              }
            }
          }
          throw error;
        }
        async _detectNetwork() {
          return this.network;
        }
        async _perform(req) {
          switch (req.method) {
            case "chainId":
              return this.network.chainId;
            case "getBlockNumber":
              return this.fetch("proxy", {
                action: "eth_blockNumber"
              });
            case "getGasPrice":
              return this.fetch("proxy", {
                action: "eth_gasPrice"
              });
            case "getBalance":
              return this.fetch("account", {
                action: "balance",
                address: req.address,
                tag: req.blockTag
              });
            case "getTransactionCount":
              return this.fetch("proxy", {
                action: "eth_getTransactionCount",
                address: req.address,
                tag: req.blockTag
              });
            case "getCode":
              return this.fetch("proxy", {
                action: "eth_getCode",
                address: req.address,
                tag: req.blockTag
              });
            case "getStorage":
              return this.fetch("proxy", {
                action: "eth_getStorageAt",
                address: req.address,
                position: req.position,
                tag: req.blockTag
              });
            case "broadcastTransaction":
              return this.fetch("proxy", {
                action: "eth_sendRawTransaction",
                hex: req.signedTransaction
              }, true).catch(error => {
                return this._checkError(req, error, req.signedTransaction);
              });
            case "getBlock":
              if ("blockTag" in req) {
                return this.fetch("proxy", {
                  action: "eth_getBlockByNumber",
                  tag: req.blockTag,
                  boolean: req.includeTransactions ? "true" : "false"
                });
              }
              (0, index_js_4.assert)(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
                operation: "getBlock(blockHash)"
              });
            case "getTransaction":
              return this.fetch("proxy", {
                action: "eth_getTransactionByHash",
                txhash: req.hash
              });
            case "getTransactionReceipt":
              return this.fetch("proxy", {
                action: "eth_getTransactionReceipt",
                txhash: req.hash
              });
            case "call":
              {
                if (req.blockTag !== "latest") {
                  throw new Error("EtherscanProvider does not support blockTag for call");
                }
                const postData = this._getTransactionPostData(req.transaction);
                postData.module = "proxy";
                postData.action = "eth_call";
                try {
                  return await this.fetch("proxy", postData, true);
                } catch (error) {
                  return this._checkError(req, error, req.transaction);
                }
              }
            case "estimateGas":
              {
                const postData = this._getTransactionPostData(req.transaction);
                postData.module = "proxy";
                postData.action = "eth_estimateGas";
                try {
                  return await this.fetch("proxy", postData, true);
                } catch (error) {
                  return this._checkError(req, error, req.transaction);
                }
              }
            default:
              break;
          }
          return super._perform(req);
        }
        async getNetwork() {
          return this.network;
        }
        async getEtherPrice() {
          if (this.network.name !== "mainnet") {
            return 0.0;
          }
          return parseFloat((await this.fetch("stats", {
            action: "ethprice"
          })).ethusd);
        }
        async getContract(_address) {
          let address = this._getAddress(_address);
          if (isPromise(address)) {
            address = await address;
          }
          try {
            const resp = await this.fetch("contract", {
              action: "getabi",
              address
            });
            const abi = JSON.parse(resp);
            return new index_js_2.Contract(address, abi, this);
          } catch (error) {
            return null;
          }
        }
        isCommunityResource() {
          return this.apiKey == null;
        }
      }
      exports.EtherscanProvider = EtherscanProvider;
    },
    9474: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FallbackProvider = void 0;
      const index_js_1 = __webpack_require__(9830);
      const abstract_provider_js_1 = __webpack_require__(2629);
      const network_js_1 = __webpack_require__(7104);
      const BN_1 = BigInt("1");
      const BN_2 = BigInt("2");
      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = array[i];
          array[i] = array[j];
          array[j] = tmp;
        }
      }
      function stall(duration) {
        return new Promise(resolve => {
          setTimeout(resolve, duration);
        });
      }
      function getTime() {
        return new Date().getTime();
      }
      function stringify(value) {
        return JSON.stringify(value, (key, value) => {
          if (typeof value === "bigint") {
            return {
              type: "bigint",
              value: value.toString()
            };
          }
          return value;
        });
      }
      ;
      const defaultConfig = {
        stallTimeout: 400,
        priority: 1,
        weight: 1
      };
      const defaultState = {
        blockNumber: -2,
        requests: 0,
        lateResponses: 0,
        errorResponses: 0,
        outOfSync: -1,
        unsupportedEvents: 0,
        rollingDuration: 0,
        score: 0,
        _network: null,
        _updateNumber: null,
        _totalTime: 0,
        _lastFatalError: null,
        _lastFatalErrorTimestamp: 0
      };
      async function waitForSync(config, blockNumber) {
        while (config.blockNumber < 0 || config.blockNumber < blockNumber) {
          if (!config._updateNumber) {
            config._updateNumber = (async () => {
              try {
                const blockNumber = await config.provider.getBlockNumber();
                if (blockNumber > config.blockNumber) {
                  config.blockNumber = blockNumber;
                }
              } catch (error) {
                config.blockNumber = -2;
                config._lastFatalError = error;
                config._lastFatalErrorTimestamp = getTime();
              }
              config._updateNumber = null;
            })();
          }
          await config._updateNumber;
          config.outOfSync++;
          if (config._lastFatalError) {
            break;
          }
        }
      }
      function _normalize(value) {
        if (value == null) {
          return "null";
        }
        if (Array.isArray(value)) {
          return "[" + value.map(_normalize).join(",") + "]";
        }
        if (typeof value === "object" && typeof value.toJSON === "function") {
          return _normalize(value.toJSON());
        }
        switch (typeof value) {
          case "boolean":
          case "symbol":
            return value.toString();
          case "bigint":
          case "number":
            return BigInt(value).toString();
          case "string":
            return JSON.stringify(value);
          case "object":
            {
              const keys = Object.keys(value);
              keys.sort();
              return "{" + keys.map(k => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(",") + "}";
            }
        }
        console.log("Could not serialize", value);
        throw new Error("Hmm...");
      }
      function normalizeResult(value) {
        if ("error" in value) {
          const error = value.error;
          return {
            tag: _normalize(error),
            value: error
          };
        }
        const result = value.result;
        return {
          tag: _normalize(result),
          value: result
        };
      }
      function checkQuorum(quorum, results) {
        const tally = new Map();
        for (const {
          value,
          tag,
          weight
        } of results) {
          const t = tally.get(tag) || {
            value,
            weight: 0
          };
          t.weight += weight;
          tally.set(tag, t);
        }
        let best = null;
        for (const r of tally.values()) {
          if (r.weight >= quorum && (!best || r.weight > best.weight)) {
            best = r;
          }
        }
        if (best) {
          return best.value;
        }
        return undefined;
      }
      function getMedian(quorum, results) {
        let resultWeight = 0;
        const errorMap = new Map();
        let bestError = null;
        const values = [];
        for (const {
          value,
          tag,
          weight
        } of results) {
          if (value instanceof Error) {
            const e = errorMap.get(tag) || {
              value,
              weight: 0
            };
            e.weight += weight;
            errorMap.set(tag, e);
            if (bestError == null || e.weight > bestError.weight) {
              bestError = e;
            }
          } else {
            values.push(BigInt(value));
            resultWeight += weight;
          }
        }
        if (resultWeight < quorum) {
          if (bestError && bestError.weight >= quorum) {
            return bestError.value;
          }
          return undefined;
        }
        values.sort((a, b) => a < b ? -1 : b > a ? 1 : 0);
        const mid = Math.floor(values.length / 2);
        if (values.length % 2) {
          return values[mid];
        }
        return (values[mid - 1] + values[mid] + BN_1) / BN_2;
      }
      function getAnyResult(quorum, results) {
        const result = checkQuorum(quorum, results);
        if (result !== undefined) {
          return result;
        }
        for (const r of results) {
          if (r.value) {
            return r.value;
          }
        }
        return undefined;
      }
      function getFuzzyMode(quorum, results) {
        if (quorum === 1) {
          return (0, index_js_1.getNumber)(getMedian(quorum, results), "%internal");
        }
        const tally = new Map();
        const add = (result, weight) => {
          const t = tally.get(result) || {
            result,
            weight: 0
          };
          t.weight += weight;
          tally.set(result, t);
        };
        for (const {
          weight,
          value
        } of results) {
          const r = (0, index_js_1.getNumber)(value);
          add(r - 1, weight);
          add(r, weight);
          add(r + 1, weight);
        }
        let bestWeight = 0;
        let bestResult = undefined;
        for (const {
          weight,
          result
        } of tally.values()) {
          if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {
            bestWeight = weight;
            bestResult = result;
          }
        }
        return bestResult;
      }
      class FallbackProvider extends abstract_provider_js_1.AbstractProvider {
        quorum;
        eventQuorum;
        eventWorkers;
        #configs;
        #height;
        #initialSyncPromise;
        constructor(providers, network, options) {
          super(network, options);
          this.#configs = providers.map(p => {
            if (p instanceof abstract_provider_js_1.AbstractProvider) {
              return Object.assign({
                provider: p
              }, defaultConfig, defaultState);
            } else {
              return Object.assign({}, defaultConfig, p, defaultState);
            }
          });
          this.#height = -2;
          this.#initialSyncPromise = null;
          if (options && options.quorum != null) {
            this.quorum = options.quorum;
          } else {
            this.quorum = Math.ceil(this.#configs.reduce((accum, config) => {
              accum += config.weight;
              return accum;
            }, 0) / 2);
          }
          this.eventQuorum = 1;
          this.eventWorkers = 1;
          (0, index_js_1.assertArgument)(this.quorum <= this.#configs.reduce((a, c) => a + c.weight, 0), "quorum exceed provider wieght", "quorum", this.quorum);
        }
        get providerConfigs() {
          return this.#configs.map(c => {
            const result = Object.assign({}, c);
            for (const key in result) {
              if (key[0] === "_") {
                delete result[key];
              }
            }
            return result;
          });
        }
        async _detectNetwork() {
          return network_js_1.Network.from((0, index_js_1.getBigInt)(await this._perform({
            method: "chainId"
          })));
        }
        async _translatePerform(provider, req) {
          switch (req.method) {
            case "broadcastTransaction":
              return await provider.broadcastTransaction(req.signedTransaction);
            case "call":
              return await provider.call(Object.assign({}, req.transaction, {
                blockTag: req.blockTag
              }));
            case "chainId":
              return (await provider.getNetwork()).chainId;
            case "estimateGas":
              return await provider.estimateGas(req.transaction);
            case "getBalance":
              return await provider.getBalance(req.address, req.blockTag);
            case "getBlock":
              {
                const block = "blockHash" in req ? req.blockHash : req.blockTag;
                return await provider.getBlock(block, req.includeTransactions);
              }
            case "getBlockNumber":
              return await provider.getBlockNumber();
            case "getCode":
              return await provider.getCode(req.address, req.blockTag);
            case "getGasPrice":
              return (await provider.getFeeData()).gasPrice;
            case "getLogs":
              return await provider.getLogs(req.filter);
            case "getStorage":
              return await provider.getStorage(req.address, req.position, req.blockTag);
            case "getTransaction":
              return await provider.getTransaction(req.hash);
            case "getTransactionCount":
              return await provider.getTransactionCount(req.address, req.blockTag);
            case "getTransactionReceipt":
              return await provider.getTransactionReceipt(req.hash);
            case "getTransactionResult":
              return await provider.getTransactionResult(req.hash);
          }
        }
        #getNextConfig(running) {
          const configs = Array.from(running).map(r => r.config);
          const allConfigs = this.#configs.slice();
          shuffle(allConfigs);
          allConfigs.sort((a, b) => a.priority - b.priority);
          for (const config of allConfigs) {
            if (config._lastFatalError) {
              continue;
            }
            if (configs.indexOf(config) === -1) {
              return config;
            }
          }
          return null;
        }
        #addRunner(running, req) {
          const config = this.#getNextConfig(running);
          if (config == null) {
            return null;
          }
          const runner = {
            config,
            result: null,
            didBump: false,
            perform: null,
            staller: null
          };
          const now = getTime();
          runner.perform = (async () => {
            try {
              config.requests++;
              const result = await this._translatePerform(config.provider, req);
              runner.result = {
                result
              };
            } catch (error) {
              config.errorResponses++;
              runner.result = {
                error
              };
            }
            const dt = getTime() - now;
            config._totalTime += dt;
            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;
            runner.perform = null;
          })();
          runner.staller = (async () => {
            await stall(config.stallTimeout);
            runner.staller = null;
          })();
          running.add(runner);
          return runner;
        }
        async #initialSync() {
          let initialSync = this.#initialSyncPromise;
          if (!initialSync) {
            const promises = [];
            this.#configs.forEach(config => {
              promises.push((async () => {
                await waitForSync(config, 0);
                if (!config._lastFatalError) {
                  config._network = await config.provider.getNetwork();
                }
              })());
            });
            this.#initialSyncPromise = initialSync = (async () => {
              await Promise.all(promises);
              let chainId = null;
              for (const config of this.#configs) {
                if (config._lastFatalError) {
                  continue;
                }
                const network = config._network;
                if (chainId == null) {
                  chainId = network.chainId;
                } else if (network.chainId !== chainId) {
                  (0, index_js_1.assert)(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
                    operation: "new FallbackProvider"
                  });
                }
              }
            })();
          }
          await initialSync;
        }
        async #checkQuorum(running, req) {
          const results = [];
          for (const runner of running) {
            if (runner.result != null) {
              const {
                tag,
                value
              } = normalizeResult(runner.result);
              results.push({
                tag,
                value,
                weight: runner.config.weight
              });
            }
          }
          if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {
            return undefined;
          }
          switch (req.method) {
            case "getBlockNumber":
              {
                if (this.#height === -2) {
                  this.#height = Math.ceil((0, index_js_1.getNumber)(getMedian(this.quorum, this.#configs.filter(c => !c._lastFatalError).map(c => ({
                    value: c.blockNumber,
                    tag: (0, index_js_1.getNumber)(c.blockNumber).toString(),
                    weight: c.weight
                  })))));
                }
                const mode = getFuzzyMode(this.quorum, results);
                if (mode === undefined) {
                  return undefined;
                }
                if (mode > this.#height) {
                  this.#height = mode;
                }
                return this.#height;
              }
            case "getGasPrice":
            case "estimateGas":
              return getMedian(this.quorum, results);
            case "getBlock":
              if ("blockTag" in req && req.blockTag === "pending") {
                return getAnyResult(this.quorum, results);
              }
              return checkQuorum(this.quorum, results);
            case "call":
            case "chainId":
            case "getBalance":
            case "getTransactionCount":
            case "getCode":
            case "getStorage":
            case "getTransaction":
            case "getTransactionReceipt":
            case "getLogs":
              return checkQuorum(this.quorum, results);
            case "broadcastTransaction":
              return getAnyResult(this.quorum, results);
          }
          (0, index_js_1.assert)(false, "unsupported method", "UNSUPPORTED_OPERATION", {
            operation: `_perform(${stringify(req.method)})`
          });
        }
        async #waitForQuorum(running, req) {
          if (running.size === 0) {
            throw new Error("no runners?!");
          }
          const interesting = [];
          let newRunners = 0;
          for (const runner of running) {
            if (runner.perform) {
              interesting.push(runner.perform);
            }
            if (runner.staller) {
              interesting.push(runner.staller);
              continue;
            }
            if (runner.didBump) {
              continue;
            }
            runner.didBump = true;
            newRunners++;
          }
          const value = await this.#checkQuorum(running, req);
          if (value !== undefined) {
            if (value instanceof Error) {
              throw value;
            }
            return value;
          }
          for (let i = 0; i < newRunners; i++) {
            this.#addRunner(running, req);
          }
          (0, index_js_1.assert)(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
            request: "%sub-requests",
            info: {
              request: req,
              results: Array.from(running).map(r => stringify(r.result))
            }
          });
          await Promise.race(interesting);
          return await this.#waitForQuorum(running, req);
        }
        async _perform(req) {
          if (req.method === "broadcastTransaction") {
            const results = await Promise.all(this.#configs.map(async ({
              provider,
              weight
            }) => {
              try {
                const result = await provider._perform(req);
                return Object.assign(normalizeResult({
                  result
                }), {
                  weight
                });
              } catch (error) {
                return Object.assign(normalizeResult({
                  error
                }), {
                  weight
                });
              }
            }));
            const result = getAnyResult(this.quorum, results);
            (0, index_js_1.assert)(result !== undefined, "problem multi-broadcasting", "SERVER_ERROR", {
              request: "%sub-requests",
              info: {
                request: req,
                results: results.map(stringify)
              }
            });
            if (result instanceof Error) {
              throw result;
            }
            return result;
          }
          await this.#initialSync();
          const running = new Set();
          for (let i = 0; i < this.quorum; i++) {
            this.#addRunner(running, req);
          }
          const result = await this.#waitForQuorum(running, req);
          for (const runner of running) {
            if (runner.perform && runner.result == null) {
              runner.config.lateResponses++;
            }
          }
          return result;
        }
        async destroy() {
          for (const {
            provider
          } of this.#configs) {
            provider.destroy();
          }
          super.destroy();
        }
      }
      exports.FallbackProvider = FallbackProvider;
    },
    4390: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;
      const index_js_1 = __webpack_require__(9830);
      const community_js_1 = __webpack_require__(1791);
      const network_js_1 = __webpack_require__(7104);
      const provider_jsonrpc_js_1 = __webpack_require__(2314);
      const provider_websocket_js_1 = __webpack_require__(8303);
      const defaultProjectId = "84842078b09946638c03157f83405213";
      function getHost(name) {
        switch (name) {
          case "mainnet":
            return "mainnet.infura.io";
          case "goerli":
            return "goerli.infura.io";
          case "sepolia":
            return "sepolia.infura.io";
          case "arbitrum":
            return "arbitrum-mainnet.infura.io";
          case "arbitrum-goerli":
            return "arbitrum-goerli.infura.io";
          case "linea":
            return "linea-mainnet.infura.io";
          case "linea-goerli":
            return "linea-goerli.infura.io";
          case "matic":
            return "polygon-mainnet.infura.io";
          case "matic-mumbai":
            return "polygon-mumbai.infura.io";
          case "optimism":
            return "optimism-mainnet.infura.io";
          case "optimism-goerli":
            return "optimism-goerli.infura.io";
        }
        (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
      }
      class InfuraWebSocketProvider extends provider_websocket_js_1.WebSocketProvider {
        projectId;
        projectSecret;
        constructor(network, projectId) {
          const provider = new InfuraProvider(network, projectId);
          const req = provider._getConnection();
          (0, index_js_1.assert)(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", {
            operation: "InfuraProvider.getWebSocketProvider()"
          });
          const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
          super(url, network);
          (0, index_js_1.defineProperties)(this, {
            projectId: provider.projectId,
            projectSecret: provider.projectSecret
          });
        }
        isCommunityResource() {
          return this.projectId === defaultProjectId;
        }
      }
      exports.InfuraWebSocketProvider = InfuraWebSocketProvider;
      class InfuraProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
        projectId;
        projectSecret;
        constructor(_network, projectId, projectSecret) {
          if (_network == null) {
            _network = "mainnet";
          }
          const network = network_js_1.Network.from(_network);
          if (projectId == null) {
            projectId = defaultProjectId;
          }
          if (projectSecret == null) {
            projectSecret = null;
          }
          const request = InfuraProvider.getRequest(network, projectId, projectSecret);
          super(request, network, {
            staticNetwork: network
          });
          (0, index_js_1.defineProperties)(this, {
            projectId,
            projectSecret
          });
        }
        _getProvider(chainId) {
          try {
            return new InfuraProvider(chainId, this.projectId, this.projectSecret);
          } catch (error) {}
          return super._getProvider(chainId);
        }
        isCommunityResource() {
          return this.projectId === defaultProjectId;
        }
        static getWebSocketProvider(network, projectId) {
          return new InfuraWebSocketProvider(network, projectId);
        }
        static getRequest(network, projectId, projectSecret) {
          if (projectId == null) {
            projectId = defaultProjectId;
          }
          if (projectSecret == null) {
            projectSecret = null;
          }
          const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/v3/${projectId}`);
          request.allowGzip = true;
          if (projectSecret) {
            request.setCredentials("", projectSecret);
          }
          if (projectId === defaultProjectId) {
            request.retryFunc = async (request, response, attempt) => {
              (0, community_js_1.showThrottleMessage)("InfuraProvider");
              return true;
            };
          }
          return request;
        }
      }
      exports.InfuraProvider = InfuraProvider;
    },
    8282: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.IpcSocketProvider = void 0;
      const IpcSocketProvider = undefined;
      exports.IpcSocketProvider = IpcSocketProvider;
    },
    2314: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.JsonRpcProvider = exports.JsonRpcApiPollingProvider = exports.JsonRpcApiProvider = exports.JsonRpcSigner = void 0;
      const index_js_1 = __webpack_require__(5262);
      const index_js_2 = __webpack_require__(2134);
      const index_js_3 = __webpack_require__(5714);
      const index_js_4 = __webpack_require__(2877);
      const index_js_5 = __webpack_require__(9830);
      const abstract_provider_js_1 = __webpack_require__(2629);
      const abstract_signer_js_1 = __webpack_require__(8401);
      const network_js_1 = __webpack_require__(7104);
      const subscriber_filterid_js_1 = __webpack_require__(128);
      const subscriber_polling_js_1 = __webpack_require__(4975);
      const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
      function deepCopy(value) {
        if (value == null || Primitive.indexOf(typeof value) >= 0) {
          return value;
        }
        if (typeof value.getAddress === "function") {
          return value;
        }
        if (Array.isArray(value)) {
          return value.map(deepCopy);
        }
        if (typeof value === "object") {
          return Object.keys(value).reduce((accum, key) => {
            accum[key] = value[key];
            return accum;
          }, {});
        }
        throw new Error(`should not happen: ${value} (${typeof value})`);
      }
      function stall(duration) {
        return new Promise(resolve => {
          setTimeout(resolve, duration);
        });
      }
      function getLowerCase(value) {
        if (value) {
          return value.toLowerCase();
        }
        return value;
      }
      function isPollable(value) {
        return value && typeof value.pollingInterval === "number";
      }
      const defaultOptions = {
        polling: false,
        staticNetwork: null,
        batchStallTime: 10,
        batchMaxSize: 1 << 20,
        batchMaxCount: 100,
        cacheTimeout: 250,
        pollingInterval: 4000
      };
      class JsonRpcSigner extends abstract_signer_js_1.AbstractSigner {
        address;
        constructor(provider, address) {
          super(provider);
          address = (0, index_js_2.getAddress)(address);
          (0, index_js_5.defineProperties)(this, {
            address
          });
        }
        connect(provider) {
          (0, index_js_5.assert)(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
            operation: "signer.connect"
          });
        }
        async getAddress() {
          return this.address;
        }
        async populateTransaction(tx) {
          return await this.populateCall(tx);
        }
        async sendUncheckedTransaction(_tx) {
          const tx = deepCopy(_tx);
          const promises = [];
          if (tx.from) {
            const _from = tx.from;
            promises.push((async () => {
              const from = await (0, index_js_2.resolveAddress)(_from, this.provider);
              (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
              tx.from = from;
            })());
          } else {
            tx.from = this.address;
          }
          if (tx.gasLimit == null) {
            promises.push((async () => {
              tx.gasLimit = await this.provider.estimateGas({
                ...tx,
                from: this.address
              });
            })());
          }
          if (tx.to != null) {
            const _to = tx.to;
            promises.push((async () => {
              tx.to = await (0, index_js_2.resolveAddress)(_to, this.provider);
            })());
          }
          if (promises.length) {
            await Promise.all(promises);
          }
          const hexTx = this.provider.getRpcTransaction(tx);
          return this.provider.send("eth_sendTransaction", [hexTx]);
        }
        async sendTransaction(tx) {
          const blockNumber = await this.provider.getBlockNumber();
          const hash = await this.sendUncheckedTransaction(tx);
          return await new Promise((resolve, reject) => {
            const timeouts = [1000, 100];
            const checkTx = async () => {
              const tx = await this.provider.getTransaction(hash);
              if (tx != null) {
                resolve(tx.replaceableTransaction(blockNumber));
                return;
              }
              this.provider._setTimeout(() => {
                checkTx();
              }, timeouts.pop() || 4000);
            };
            checkTx();
          });
        }
        async signTransaction(_tx) {
          const tx = deepCopy(_tx);
          if (tx.from) {
            const from = await (0, index_js_2.resolveAddress)(tx.from, this.provider);
            (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
            tx.from = from;
          } else {
            tx.from = this.address;
          }
          const hexTx = this.provider.getRpcTransaction(tx);
          return await this.provider.send("eth_signTransaction", [hexTx]);
        }
        async signMessage(_message) {
          const message = typeof _message === "string" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;
          return await this.provider.send("personal_sign", [(0, index_js_5.hexlify)(message), this.address.toLowerCase()]);
        }
        async signTypedData(domain, types, _value) {
          const value = deepCopy(_value);
          const populated = await index_js_3.TypedDataEncoder.resolveNames(domain, types, value, async value => {
            const address = await (0, index_js_2.resolveAddress)(value);
            (0, index_js_5.assertArgument)(address != null, "TypedData does not support null address", "value", value);
            return address;
          });
          return await this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(index_js_3.TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);
        }
        async unlock(password) {
          return this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), password, null]);
        }
        async _legacySignMessage(_message) {
          const message = typeof _message === "string" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;
          return await this.provider.send("eth_sign", [this.address.toLowerCase(), (0, index_js_5.hexlify)(message)]);
        }
      }
      exports.JsonRpcSigner = JsonRpcSigner;
      class JsonRpcApiProvider extends abstract_provider_js_1.AbstractProvider {
        #options;
        #nextId;
        #payloads;
        #drainTimer;
        #notReady;
        #network;
        #scheduleDrain() {
          if (this.#drainTimer) {
            return;
          }
          const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
          this.#drainTimer = setTimeout(() => {
            this.#drainTimer = null;
            const payloads = this.#payloads;
            this.#payloads = [];
            while (payloads.length) {
              const batch = [payloads.shift()];
              while (payloads.length) {
                if (batch.length === this.#options.batchMaxCount) {
                  break;
                }
                batch.push(payloads.shift());
                const bytes = JSON.stringify(batch.map(p => p.payload));
                if (bytes.length > this.#options.batchMaxSize) {
                  payloads.unshift(batch.pop());
                  break;
                }
              }
              (async () => {
                const payload = batch.length === 1 ? batch[0].payload : batch.map(p => p.payload);
                this.emit("debug", {
                  action: "sendRpcPayload",
                  payload
                });
                try {
                  const result = await this._send(payload);
                  this.emit("debug", {
                    action: "receiveRpcResult",
                    result
                  });
                  for (const {
                    resolve,
                    reject,
                    payload
                  } of batch) {
                    if (this.destroyed) {
                      reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                        operation: payload.method
                      }));
                      continue;
                    }
                    const resp = result.filter(r => r.id === payload.id)[0];
                    if (resp == null) {
                      const error = (0, index_js_5.makeError)("missing response for request", "BAD_DATA", {
                        value: result,
                        info: {
                          payload
                        }
                      });
                      this.emit("error", error);
                      reject(error);
                      continue;
                    }
                    if ("error" in resp) {
                      reject(this.getRpcError(payload, resp));
                      continue;
                    }
                    resolve(resp.result);
                  }
                } catch (error) {
                  this.emit("debug", {
                    action: "receiveRpcError",
                    error
                  });
                  for (const {
                    reject
                  } of batch) {
                    reject(error);
                  }
                }
              })();
            }
          }, stallTime);
        }
        constructor(network, options) {
          super(network, options);
          this.#nextId = 1;
          this.#options = Object.assign({}, defaultOptions, options || {});
          this.#payloads = [];
          this.#drainTimer = null;
          this.#network = null;
          {
            let resolve = null;
            const promise = new Promise(_resolve => {
              resolve = _resolve;
            });
            this.#notReady = {
              promise,
              resolve
            };
          }
          const staticNetwork = this._getOption("staticNetwork");
          if (staticNetwork) {
            (0, index_js_5.assertArgument)(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
            this.#network = staticNetwork;
          }
        }
        _getOption(key) {
          return this.#options[key];
        }
        get _network() {
          (0, index_js_5.assert)(this.#network, "network is not available yet", "NETWORK_ERROR");
          return this.#network;
        }
        async _perform(req) {
          if (req.method === "call" || req.method === "estimateGas") {
            let tx = req.transaction;
            if (tx && tx.type != null && (0, index_js_5.getBigInt)(tx.type)) {
              if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                const feeData = await this.getFeeData();
                if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                  req = Object.assign({}, req, {
                    transaction: Object.assign({}, tx, {
                      type: undefined
                    })
                  });
                }
              }
            }
          }
          const request = this.getRpcRequest(req);
          if (request != null) {
            return await this.send(request.method, request.args);
          }
          return super._perform(req);
        }
        async _detectNetwork() {
          const network = this._getOption("staticNetwork");
          if (network) {
            return network;
          }
          if (this.ready) {
            return network_js_1.Network.from((0, index_js_5.getBigInt)(await this.send("eth_chainId", [])));
          }
          const payload = {
            id: this.#nextId++,
            method: "eth_chainId",
            params: [],
            jsonrpc: "2.0"
          };
          this.emit("debug", {
            action: "sendRpcPayload",
            payload
          });
          let result;
          try {
            result = (await this._send(payload))[0];
          } catch (error) {
            this.emit("debug", {
              action: "receiveRpcError",
              error
            });
            throw error;
          }
          this.emit("debug", {
            action: "receiveRpcResult",
            result
          });
          if ("result" in result) {
            return network_js_1.Network.from((0, index_js_5.getBigInt)(result.result));
          }
          throw this.getRpcError(payload, result);
        }
        _start() {
          if (this.#notReady == null || this.#notReady.resolve == null) {
            return;
          }
          this.#notReady.resolve();
          this.#notReady = null;
          (async () => {
            while (this.#network == null && !this.destroyed) {
              try {
                this.#network = await this._detectNetwork();
              } catch (error) {
                if (this.destroyed) {
                  break;
                }
                console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
                this.emit("error", (0, index_js_5.makeError)("failed to bootstrap network detection", "NETWORK_ERROR", {
                  event: "initial-network-discovery",
                  info: {
                    error
                  }
                }));
                await stall(1000);
              }
            }
            this.#scheduleDrain();
          })();
        }
        async _waitUntilReady() {
          if (this.#notReady == null) {
            return;
          }
          return await this.#notReady.promise;
        }
        _getSubscriber(sub) {
          if (sub.type === "pending") {
            return new subscriber_filterid_js_1.FilterIdPendingSubscriber(this);
          }
          if (sub.type === "event") {
            if (this._getOption("polling")) {
              return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
            }
            return new subscriber_filterid_js_1.FilterIdEventSubscriber(this, sub.filter);
          }
          if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
            return new abstract_provider_js_1.UnmanagedSubscriber("orphan");
          }
          return super._getSubscriber(sub);
        }
        get ready() {
          return this.#notReady == null;
        }
        getRpcTransaction(tx) {
          const result = {};
          ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(key => {
            if (tx[key] == null) {
              return;
            }
            let dstKey = key;
            if (key === "gasLimit") {
              dstKey = "gas";
            }
            result[dstKey] = (0, index_js_5.toQuantity)((0, index_js_5.getBigInt)(tx[key], `tx.${key}`));
          });
          ["from", "to", "data"].forEach(key => {
            if (tx[key] == null) {
              return;
            }
            result[key] = (0, index_js_5.hexlify)(tx[key]);
          });
          if (tx.accessList) {
            result["accessList"] = (0, index_js_4.accessListify)(tx.accessList);
          }
          return result;
        }
        getRpcRequest(req) {
          switch (req.method) {
            case "chainId":
              return {
                method: "eth_chainId",
                args: []
              };
            case "getBlockNumber":
              return {
                method: "eth_blockNumber",
                args: []
              };
            case "getGasPrice":
              return {
                method: "eth_gasPrice",
                args: []
              };
            case "getBalance":
              return {
                method: "eth_getBalance",
                args: [getLowerCase(req.address), req.blockTag]
              };
            case "getTransactionCount":
              return {
                method: "eth_getTransactionCount",
                args: [getLowerCase(req.address), req.blockTag]
              };
            case "getCode":
              return {
                method: "eth_getCode",
                args: [getLowerCase(req.address), req.blockTag]
              };
            case "getStorage":
              return {
                method: "eth_getStorageAt",
                args: [getLowerCase(req.address), "0x" + req.position.toString(16), req.blockTag]
              };
            case "broadcastTransaction":
              return {
                method: "eth_sendRawTransaction",
                args: [req.signedTransaction]
              };
            case "getBlock":
              if ("blockTag" in req) {
                return {
                  method: "eth_getBlockByNumber",
                  args: [req.blockTag, !!req.includeTransactions]
                };
              } else if ("blockHash" in req) {
                return {
                  method: "eth_getBlockByHash",
                  args: [req.blockHash, !!req.includeTransactions]
                };
              }
              break;
            case "getTransaction":
              return {
                method: "eth_getTransactionByHash",
                args: [req.hash]
              };
            case "getTransactionReceipt":
              return {
                method: "eth_getTransactionReceipt",
                args: [req.hash]
              };
            case "call":
              return {
                method: "eth_call",
                args: [this.getRpcTransaction(req.transaction), req.blockTag]
              };
            case "estimateGas":
              {
                return {
                  method: "eth_estimateGas",
                  args: [this.getRpcTransaction(req.transaction)]
                };
              }
            case "getLogs":
              if (req.filter && req.filter.address != null) {
                if (Array.isArray(req.filter.address)) {
                  req.filter.address = req.filter.address.map(getLowerCase);
                } else {
                  req.filter.address = getLowerCase(req.filter.address);
                }
              }
              return {
                method: "eth_getLogs",
                args: [req.filter]
              };
          }
          return null;
        }
        getRpcError(payload, _error) {
          const {
            method
          } = payload;
          const {
            error
          } = _error;
          if (method === "eth_estimateGas" && error.message) {
            const msg = error.message;
            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
              return (0, index_js_5.makeError)("insufficient funds", "INSUFFICIENT_FUNDS", {
                transaction: payload.params[0],
                info: {
                  payload,
                  error
                }
              });
            }
          }
          if (method === "eth_call" || method === "eth_estimateGas") {
            const result = spelunkData(error);
            const e = index_js_1.AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
            e.info = {
              error,
              payload
            };
            return e;
          }
          const message = JSON.stringify(spelunkMessage(error));
          if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
            const actionMap = {
              eth_sign: "signMessage",
              personal_sign: "signMessage",
              eth_signTypedData_v4: "signTypedData",
              eth_signTransaction: "signTransaction",
              eth_sendTransaction: "sendTransaction",
              eth_requestAccounts: "requestAccess",
              wallet_requestAccounts: "requestAccess"
            };
            return (0, index_js_5.makeError)(`user rejected action`, "ACTION_REJECTED", {
              action: actionMap[method] || "unknown",
              reason: "rejected",
              info: {
                payload,
                error
              }
            });
          }
          if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
            const transaction = payload.params[0];
            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
              return (0, index_js_5.makeError)("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                transaction,
                info: {
                  error
                }
              });
            }
            if (message.match(/nonce/i) && message.match(/too low/i)) {
              return (0, index_js_5.makeError)("nonce has already been used", "NONCE_EXPIRED", {
                transaction,
                info: {
                  error
                }
              });
            }
            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
              return (0, index_js_5.makeError)("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                transaction,
                info: {
                  error
                }
              });
            }
            if (message.match(/only replay-protected/i)) {
              return (0, index_js_5.makeError)("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
                operation: method,
                info: {
                  transaction,
                  info: {
                    error
                  }
                }
              });
            }
          }
          let unsupported = !!message.match(/the method .* does not exist/i);
          if (!unsupported) {
            if (error && error.details && error.details.startsWith("Unauthorized method:")) {
              unsupported = true;
            }
          }
          if (unsupported) {
            return (0, index_js_5.makeError)("unsupported operation", "UNSUPPORTED_OPERATION", {
              operation: payload.method,
              info: {
                error,
                payload
              }
            });
          }
          return (0, index_js_5.makeError)("could not coalesce error", "UNKNOWN_ERROR", {
            error,
            payload
          });
        }
        send(method, params) {
          if (this.destroyed) {
            return Promise.reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
              operation: method
            }));
          }
          const id = this.#nextId++;
          const promise = new Promise((resolve, reject) => {
            this.#payloads.push({
              resolve,
              reject,
              payload: {
                method,
                params,
                id,
                jsonrpc: "2.0"
              }
            });
          });
          this.#scheduleDrain();
          return promise;
        }
        async getSigner(address) {
          if (address == null) {
            address = 0;
          }
          const accountsPromise = this.send("eth_accounts", []);
          if (typeof address === "number") {
            const accounts = await accountsPromise;
            if (address >= accounts.length) {
              throw new Error("no such account");
            }
            return new JsonRpcSigner(this, accounts[address]);
          }
          const {
            accounts
          } = await (0, index_js_5.resolveProperties)({
            network: this.getNetwork(),
            accounts: accountsPromise
          });
          address = (0, index_js_2.getAddress)(address);
          for (const account of accounts) {
            if ((0, index_js_2.getAddress)(account) === address) {
              return new JsonRpcSigner(this, address);
            }
          }
          throw new Error("invalid account");
        }
        async listAccounts() {
          const accounts = await this.send("eth_accounts", []);
          return accounts.map(a => new JsonRpcSigner(this, a));
        }
        destroy() {
          if (this.#drainTimer) {
            clearTimeout(this.#drainTimer);
            this.#drainTimer = null;
          }
          for (const {
            payload,
            reject
          } of this.#payloads) {
            reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
              operation: payload.method
            }));
          }
          this.#payloads = [];
          super.destroy();
        }
      }
      exports.JsonRpcApiProvider = JsonRpcApiProvider;
      class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
        #pollingInterval;
        constructor(network, options) {
          super(network, options);
          this.#pollingInterval = 4000;
        }
        _getSubscriber(sub) {
          const subscriber = super._getSubscriber(sub);
          if (isPollable(subscriber)) {
            subscriber.pollingInterval = this.#pollingInterval;
          }
          return subscriber;
        }
        get pollingInterval() {
          return this.#pollingInterval;
        }
        set pollingInterval(value) {
          if (!Number.isInteger(value) || value < 0) {
            throw new Error("invalid interval");
          }
          this.#pollingInterval = value;
          this._forEachSubscriber(sub => {
            if (isPollable(sub)) {
              sub.pollingInterval = this.#pollingInterval;
            }
          });
        }
      }
      exports.JsonRpcApiPollingProvider = JsonRpcApiPollingProvider;
      class JsonRpcProvider extends JsonRpcApiPollingProvider {
        #connect;
        constructor(url, network, options) {
          if (url == null) {
            url = "http:/\/localhost:8545";
          }
          super(network, options);
          if (typeof url === "string") {
            this.#connect = new index_js_5.FetchRequest(url);
          } else {
            this.#connect = url.clone();
          }
        }
        _getConnection() {
          return this.#connect.clone();
        }
        async send(method, params) {
          await this._start();
          return await super.send(method, params);
        }
        async _send(payload) {
          const request = this._getConnection();
          request.body = JSON.stringify(payload);
          request.setHeader("content-type", "application/json");
          const response = await request.send();
          response.assertOk();
          let resp = response.bodyJson;
          if (!Array.isArray(resp)) {
            resp = [resp];
          }
          return resp;
        }
      }
      exports.JsonRpcProvider = JsonRpcProvider;
      function spelunkData(value) {
        if (value == null) {
          return null;
        }
        if (typeof value.message === "string" && value.message.match(/revert/i) && (0, index_js_5.isHexString)(value.data)) {
          return {
            message: value.message,
            data: value.data
          };
        }
        if (typeof value === "object") {
          for (const key in value) {
            const result = spelunkData(value[key]);
            if (result) {
              return result;
            }
          }
          return null;
        }
        if (typeof value === "string") {
          try {
            return spelunkData(JSON.parse(value));
          } catch (error) {}
        }
        return null;
      }
      function _spelunkMessage(value, result) {
        if (value == null) {
          return;
        }
        if (typeof value.message === "string") {
          result.push(value.message);
        }
        if (typeof value === "object") {
          for (const key in value) {
            _spelunkMessage(value[key], result);
          }
        }
        if (typeof value === "string") {
          try {
            return _spelunkMessage(JSON.parse(value), result);
          } catch (error) {}
        }
      }
      function spelunkMessage(value) {
        const result = [];
        _spelunkMessage(value, result);
        return result;
      }
    },
    8938: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PocketProvider = void 0;
      const index_js_1 = __webpack_require__(9830);
      const community_js_1 = __webpack_require__(1791);
      const network_js_1 = __webpack_require__(7104);
      const provider_jsonrpc_js_1 = __webpack_require__(2314);
      const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
      function getHost(name) {
        switch (name) {
          case "mainnet":
            return "eth-mainnet.gateway.pokt.network";
          case "goerli":
            return "eth-goerli.gateway.pokt.network";
          case "matic":
            return "poly-mainnet.gateway.pokt.network";
          case "matic-mumbai":
            return "polygon-mumbai-rpc.gateway.pokt.network";
        }
        (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
      }
      class PocketProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
        applicationId;
        applicationSecret;
        constructor(_network, applicationId, applicationSecret) {
          if (_network == null) {
            _network = "mainnet";
          }
          const network = network_js_1.Network.from(_network);
          if (applicationId == null) {
            applicationId = defaultApplicationId;
          }
          if (applicationSecret == null) {
            applicationSecret = null;
          }
          const options = {
            staticNetwork: network
          };
          const request = PocketProvider.getRequest(network, applicationId, applicationSecret);
          super(request, network, options);
          (0, index_js_1.defineProperties)(this, {
            applicationId,
            applicationSecret
          });
        }
        _getProvider(chainId) {
          try {
            return new PocketProvider(chainId, this.applicationId, this.applicationSecret);
          } catch (error) {}
          return super._getProvider(chainId);
        }
        static getRequest(network, applicationId, applicationSecret) {
          if (applicationId == null) {
            applicationId = defaultApplicationId;
          }
          const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/v1/lb/${applicationId}`);
          request.allowGzip = true;
          if (applicationSecret) {
            request.setCredentials("", applicationSecret);
          }
          if (applicationId === defaultApplicationId) {
            request.retryFunc = async (request, response, attempt) => {
              (0, community_js_1.showThrottleMessage)("PocketProvider");
              return true;
            };
          }
          return request;
        }
        isCommunityResource() {
          return this.applicationId === defaultApplicationId;
        }
      }
      exports.PocketProvider = PocketProvider;
    },
    6120: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.QuickNodeProvider = void 0;
      const index_js_1 = __webpack_require__(9830);
      const community_js_1 = __webpack_require__(1791);
      const network_js_1 = __webpack_require__(7104);
      const provider_jsonrpc_js_1 = __webpack_require__(2314);
      const defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
      function getHost(name) {
        switch (name) {
          case "mainnet":
            return "ethers.quiknode.pro";
          case "goerli":
            return "ethers.ethereum-goerli.quiknode.pro";
          case "arbitrum":
            return "ethers.arbitrum-mainnet.quiknode.pro";
          case "arbitrum-goerli":
            return "ethers.arbitrum-goerli.quiknode.pro";
          case "matic":
            return "ethers.matic.quiknode.pro";
          case "matic-mumbai":
            return "ethers.matic-testnet.quiknode.pro";
          case "optimism":
            return "ethers.optimism.quiknode.pro";
          case "optimism-goerli":
            return "ethers.optimism-goerli.quiknode.pro";
        }
        (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
      }
      class QuickNodeProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
        token;
        constructor(_network, token) {
          if (_network == null) {
            _network = "mainnet";
          }
          const network = network_js_1.Network.from(_network);
          if (token == null) {
            token = defaultToken;
          }
          const request = QuickNodeProvider.getRequest(network, token);
          super(request, network, {
            staticNetwork: network
          });
          (0, index_js_1.defineProperties)(this, {
            token
          });
        }
        _getProvider(chainId) {
          try {
            return new QuickNodeProvider(chainId, this.token);
          } catch (error) {}
          return super._getProvider(chainId);
        }
        isCommunityResource() {
          return this.token === defaultToken;
        }
        static getRequest(network, token) {
          if (token == null) {
            token = defaultToken;
          }
          const request = new index_js_1.FetchRequest(`https:/\/${getHost(network.name)}/${token}`);
          request.allowGzip = true;
          if (token === defaultToken) {
            request.retryFunc = async (request, response, attempt) => {
              (0, community_js_1.showThrottleMessage)("QuickNodeProvider");
              return true;
            };
          }
          return request;
        }
      }
      exports.QuickNodeProvider = QuickNodeProvider;
    },
    518: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SocketProvider = exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = void 0;
      const abstract_provider_js_1 = __webpack_require__(2629);
      const index_js_1 = __webpack_require__(9830);
      const provider_jsonrpc_js_1 = __webpack_require__(2314);
      class SocketSubscriber {
        #provider;
        #filter;
        get filter() {
          return JSON.parse(this.#filter);
        }
        #filterId;
        #paused;
        #emitPromise;
        constructor(provider, filter) {
          this.#provider = provider;
          this.#filter = JSON.stringify(filter);
          this.#filterId = null;
          this.#paused = null;
          this.#emitPromise = null;
        }
        start() {
          this.#filterId = this.#provider.send("eth_subscribe", this.filter).then(filterId => {
            ;
            this.#provider._register(filterId, this);
            return filterId;
          });
        }
        stop() {
          this.#filterId.then(filterId => {
            this.#provider.send("eth_unsubscribe", [filterId]);
          });
          this.#filterId = null;
        }
        pause(dropWhilePaused) {
          (0, index_js_1.assert)(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", {
            operation: "pause(false)"
          });
          this.#paused = !!dropWhilePaused;
        }
        resume() {
          this.#paused = null;
        }
        _handleMessage(message) {
          if (this.#filterId == null) {
            return;
          }
          if (this.#paused === null) {
            let emitPromise = this.#emitPromise;
            if (emitPromise == null) {
              emitPromise = this._emit(this.#provider, message);
            } else {
              emitPromise = emitPromise.then(async () => {
                await this._emit(this.#provider, message);
              });
            }
            this.#emitPromise = emitPromise.then(() => {
              if (this.#emitPromise === emitPromise) {
                this.#emitPromise = null;
              }
            });
          }
        }
        async _emit(provider, message) {
          throw new Error("sub-classes must implemente this; _emit");
        }
      }
      exports.SocketSubscriber = SocketSubscriber;
      class SocketBlockSubscriber extends SocketSubscriber {
        constructor(provider) {
          super(provider, ["newHeads"]);
        }
        async _emit(provider, message) {
          provider.emit("block", parseInt(message.number));
        }
      }
      exports.SocketBlockSubscriber = SocketBlockSubscriber;
      class SocketPendingSubscriber extends SocketSubscriber {
        constructor(provider) {
          super(provider, ["newPendingTransactions"]);
        }
        async _emit(provider, message) {
          provider.emit("pending", message);
        }
      }
      exports.SocketPendingSubscriber = SocketPendingSubscriber;
      class SocketEventSubscriber extends SocketSubscriber {
        #logFilter;
        get logFilter() {
          return JSON.parse(this.#logFilter);
        }
        constructor(provider, filter) {
          super(provider, ["logs", filter]);
          this.#logFilter = JSON.stringify(filter);
        }
        async _emit(provider, message) {
          provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
        }
      }
      exports.SocketEventSubscriber = SocketEventSubscriber;
      class SocketProvider extends provider_jsonrpc_js_1.JsonRpcApiProvider {
        #callbacks;
        #subs;
        #pending;
        constructor(network) {
          super(network, {
            batchMaxCount: 1
          });
          this.#callbacks = new Map();
          this.#subs = new Map();
          this.#pending = new Map();
        }
        _getSubscriber(sub) {
          switch (sub.type) {
            case "close":
              return new abstract_provider_js_1.UnmanagedSubscriber("close");
            case "block":
              return new SocketBlockSubscriber(this);
            case "pending":
              return new SocketPendingSubscriber(this);
            case "event":
              return new SocketEventSubscriber(this, sub.filter);
            case "orphan":
              if (sub.filter.orphan === "drop-log") {
                return new abstract_provider_js_1.UnmanagedSubscriber("drop-log");
              }
          }
          return super._getSubscriber(sub);
        }
        _register(filterId, subscriber) {
          this.#subs.set(filterId, subscriber);
          const pending = this.#pending.get(filterId);
          if (pending) {
            for (const message of pending) {
              subscriber._handleMessage(message);
            }
            this.#pending.delete(filterId);
          }
        }
        async _send(payload) {
          (0, index_js_1.assertArgument)(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
          const promise = new Promise((resolve, reject) => {
            this.#callbacks.set(payload.id, {
              payload,
              resolve,
              reject
            });
          });
          await this._waitUntilReady();
          await this._write(JSON.stringify(payload));
          return [await promise];
        }
        async _processMessage(message) {
          const result = JSON.parse(message);
          if (result && typeof result === "object" && "id" in result) {
            const callback = this.#callbacks.get(result.id);
            if (callback == null) {
              this.emit("error", (0, index_js_1.makeError)("received result for unknown id", "UNKNOWN_ERROR", {
                reasonCode: "UNKNOWN_ID",
                result
              }));
              return;
            }
            this.#callbacks.delete(result.id);
            callback.resolve(result);
          } else if (result && result.method === "eth_subscription") {
            const filterId = result.params.subscription;
            const subscriber = this.#subs.get(filterId);
            if (subscriber) {
              subscriber._handleMessage(result.params.result);
            } else {
              let pending = this.#pending.get(filterId);
              if (pending == null) {
                pending = [];
                this.#pending.set(filterId, pending);
              }
              pending.push(result.params.result);
            }
          } else {
            this.emit("error", (0, index_js_1.makeError)("received unexpected message", "UNKNOWN_ERROR", {
              reasonCode: "UNEXPECTED_MESSAGE",
              result
            }));
            return;
          }
        }
        async _write(message) {
          throw new Error("sub-classes must override this");
        }
      }
      exports.SocketProvider = SocketProvider;
    },
    8303: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.WebSocketProvider = void 0;
      const ws_js_1 = __webpack_require__(8620);
      const provider_socket_js_1 = __webpack_require__(518);
      class WebSocketProvider extends provider_socket_js_1.SocketProvider {
        #connect;
        #websocket;
        get websocket() {
          if (this.#websocket == null) {
            throw new Error("websocket closed");
          }
          return this.#websocket;
        }
        constructor(url, network) {
          super(network);
          if (typeof url === "string") {
            this.#connect = () => {
              return new ws_js_1.WebSocket(url);
            };
            this.#websocket = this.#connect();
          } else if (typeof url === "function") {
            this.#connect = url;
            this.#websocket = url();
          } else {
            this.#connect = null;
            this.#websocket = url;
          }
          this.websocket.onopen = async () => {
            try {
              await this._start();
              this.resume();
            } catch (error) {
              console.log("failed to start WebsocketProvider", error);
            }
          };
          this.websocket.onmessage = message => {
            this._processMessage(message.data);
          };
        }
        async _write(message) {
          this.websocket.send(message);
        }
        async destroy() {
          if (this.#websocket != null) {
            this.#websocket.close();
            this.#websocket = null;
          }
          super.destroy();
        }
      }
      exports.WebSocketProvider = WebSocketProvider;
    },
    1607: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.Block = exports.copyRequest = exports.FeeData = void 0;
      const index_js_1 = __webpack_require__(9830);
      const index_js_2 = __webpack_require__(2877);
      const BN_0 = BigInt(0);
      function getValue(value) {
        if (value == null) {
          return null;
        }
        return value;
      }
      function toJson(value) {
        if (value == null) {
          return null;
        }
        return value.toString();
      }
      class FeeData {
        gasPrice;
        maxFeePerGas;
        maxPriorityFeePerGas;
        constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
          (0, index_js_1.defineProperties)(this, {
            gasPrice: getValue(gasPrice),
            maxFeePerGas: getValue(maxFeePerGas),
            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
          });
        }
        toJSON() {
          const {
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas
          } = this;
          return {
            _type: "FeeData",
            gasPrice: toJson(gasPrice),
            maxFeePerGas: toJson(maxFeePerGas),
            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
          };
        }
      }
      exports.FeeData = FeeData;
      ;
      function copyRequest(req) {
        const result = {};
        if (req.to) {
          result.to = req.to;
        }
        if (req.from) {
          result.from = req.from;
        }
        if (req.data) {
          result.data = (0, index_js_1.hexlify)(req.data);
        }
        const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
        for (const key of bigIntKeys) {
          if (!(key in req) || req[key] == null) {
            continue;
          }
          result[key] = (0, index_js_1.getBigInt)(req[key], `request.${key}`);
        }
        const numberKeys = "type,nonce".split(/,/);
        for (const key of numberKeys) {
          if (!(key in req) || req[key] == null) {
            continue;
          }
          result[key] = (0, index_js_1.getNumber)(req[key], `request.${key}`);
        }
        if (req.accessList) {
          result.accessList = (0, index_js_2.accessListify)(req.accessList);
        }
        if ("blockTag" in req) {
          result.blockTag = req.blockTag;
        }
        if ("enableCcipRead" in req) {
          result.enableCcipRead = !!req.enableCcipRead;
        }
        if ("customData" in req) {
          result.customData = req.customData;
        }
        return result;
      }
      exports.copyRequest = copyRequest;
      class Block {
        provider;
        number;
        hash;
        timestamp;
        parentHash;
        nonce;
        difficulty;
        gasLimit;
        gasUsed;
        miner;
        extraData;
        baseFeePerGas;
        #transactions;
        constructor(block, provider) {
          this.#transactions = block.transactions.map(tx => {
            if (typeof tx !== "string") {
              return new TransactionResponse(tx, provider);
            }
            return tx;
          });
          (0, index_js_1.defineProperties)(this, {
            provider,
            hash: getValue(block.hash),
            number: block.number,
            timestamp: block.timestamp,
            parentHash: block.parentHash,
            nonce: block.nonce,
            difficulty: block.difficulty,
            gasLimit: block.gasLimit,
            gasUsed: block.gasUsed,
            miner: block.miner,
            extraData: block.extraData,
            baseFeePerGas: getValue(block.baseFeePerGas)
          });
        }
        get transactions() {
          return this.#transactions.map(tx => {
            if (typeof tx === "string") {
              return tx;
            }
            return tx.hash;
          });
        }
        get prefetchedTransactions() {
          const txs = this.#transactions.slice();
          if (txs.length === 0) {
            return [];
          }
          (0, index_js_1.assert)(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
            operation: "transactionResponses()"
          });
          return txs;
        }
        toJSON() {
          const {
            baseFeePerGas,
            difficulty,
            extraData,
            gasLimit,
            gasUsed,
            hash,
            miner,
            nonce,
            number,
            parentHash,
            timestamp,
            transactions
          } = this;
          return {
            _type: "Block",
            baseFeePerGas: toJson(baseFeePerGas),
            difficulty: toJson(difficulty),
            extraData,
            gasLimit: toJson(gasLimit),
            gasUsed: toJson(gasUsed),
            hash,
            miner,
            nonce,
            number,
            parentHash,
            timestamp,
            transactions
          };
        }
        [Symbol.iterator]() {
          let index = 0;
          const txs = this.transactions;
          return {
            next: () => {
              if (index < this.length) {
                return {
                  value: txs[index++],
                  done: false
                };
              }
              return {
                value: undefined,
                done: true
              };
            }
          };
        }
        get length() {
          return this.#transactions.length;
        }
        get date() {
          if (this.timestamp == null) {
            return null;
          }
          return new Date(this.timestamp * 1000);
        }
        async getTransaction(indexOrHash) {
          let tx = undefined;
          if (typeof indexOrHash === "number") {
            tx = this.#transactions[indexOrHash];
          } else {
            const hash = indexOrHash.toLowerCase();
            for (const v of this.#transactions) {
              if (typeof v === "string") {
                if (v !== hash) {
                  continue;
                }
                tx = v;
                break;
              } else {
                if (v.hash === hash) {
                  continue;
                }
                tx = v;
                break;
              }
            }
          }
          if (tx == null) {
            throw new Error("no such tx");
          }
          if (typeof tx === "string") {
            return await this.provider.getTransaction(tx);
          } else {
            return tx;
          }
        }
        getPrefetchedTransaction(indexOrHash) {
          const txs = this.prefetchedTransactions;
          if (typeof indexOrHash === "number") {
            return txs[indexOrHash];
          }
          indexOrHash = indexOrHash.toLowerCase();
          for (const tx of txs) {
            if (tx.hash === indexOrHash) {
              return tx;
            }
          }
          (0, index_js_1.assertArgument)(false, "no matching transaction", "indexOrHash", indexOrHash);
        }
        isMined() {
          return !!this.hash;
        }
        isLondon() {
          return !!this.baseFeePerGas;
        }
        orphanedEvent() {
          if (!this.isMined()) {
            throw new Error("");
          }
          return createOrphanedBlockFilter(this);
        }
      }
      exports.Block = Block;
      class Log {
        provider;
        transactionHash;
        blockHash;
        blockNumber;
        removed;
        address;
        data;
        topics;
        index;
        transactionIndex;
        constructor(log, provider) {
          this.provider = provider;
          const topics = Object.freeze(log.topics.slice());
          (0, index_js_1.defineProperties)(this, {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            removed: log.removed,
            address: log.address,
            data: log.data,
            topics,
            index: log.index,
            transactionIndex: log.transactionIndex
          });
        }
        toJSON() {
          const {
            address,
            blockHash,
            blockNumber,
            data,
            index,
            removed,
            topics,
            transactionHash,
            transactionIndex
          } = this;
          return {
            _type: "log",
            address,
            blockHash,
            blockNumber,
            data,
            index,
            removed,
            topics,
            transactionHash,
            transactionIndex
          };
        }
        async getBlock() {
          const block = await this.provider.getBlock(this.blockHash);
          (0, index_js_1.assert)(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
          return block;
        }
        async getTransaction() {
          const tx = await this.provider.getTransaction(this.transactionHash);
          (0, index_js_1.assert)(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
          return tx;
        }
        async getTransactionReceipt() {
          const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
          (0, index_js_1.assert)(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
          return receipt;
        }
        removedEvent() {
          return createRemovedLogFilter(this);
        }
      }
      exports.Log = Log;
      class TransactionReceipt {
        provider;
        to;
        from;
        contractAddress;
        hash;
        index;
        blockHash;
        blockNumber;
        logsBloom;
        gasUsed;
        cumulativeGasUsed;
        gasPrice;
        type;
        status;
        root;
        #logs;
        constructor(tx, provider) {
          this.#logs = Object.freeze(tx.logs.map(log => {
            return new Log(log, provider);
          }));
          let gasPrice = BN_0;
          if (tx.effectiveGasPrice != null) {
            gasPrice = tx.effectiveGasPrice;
          } else if (tx.gasPrice != null) {
            gasPrice = tx.gasPrice;
          }
          (0, index_js_1.defineProperties)(this, {
            provider,
            to: tx.to,
            from: tx.from,
            contractAddress: tx.contractAddress,
            hash: tx.hash,
            index: tx.index,
            blockHash: tx.blockHash,
            blockNumber: tx.blockNumber,
            logsBloom: tx.logsBloom,
            gasUsed: tx.gasUsed,
            cumulativeGasUsed: tx.cumulativeGasUsed,
            gasPrice,
            type: tx.type,
            status: tx.status,
            root: tx.root
          });
        }
        get logs() {
          return this.#logs;
        }
        toJSON() {
          const {
            to,
            from,
            contractAddress,
            hash,
            index,
            blockHash,
            blockNumber,
            logsBloom,
            logs,
            status,
            root
          } = this;
          return {
            _type: "TransactionReceipt",
            blockHash,
            blockNumber,
            contractAddress,
            cumulativeGasUsed: toJson(this.cumulativeGasUsed),
            from,
            gasPrice: toJson(this.gasPrice),
            gasUsed: toJson(this.gasUsed),
            hash,
            index,
            logs,
            logsBloom,
            root,
            status,
            to
          };
        }
        get length() {
          return this.logs.length;
        }
        [Symbol.iterator]() {
          let index = 0;
          return {
            next: () => {
              if (index < this.length) {
                return {
                  value: this.logs[index++],
                  done: false
                };
              }
              return {
                value: undefined,
                done: true
              };
            }
          };
        }
        get fee() {
          return this.gasUsed * this.gasPrice;
        }
        async getBlock() {
          const block = await this.provider.getBlock(this.blockHash);
          if (block == null) {
            throw new Error("TODO");
          }
          return block;
        }
        async getTransaction() {
          const tx = await this.provider.getTransaction(this.hash);
          if (tx == null) {
            throw new Error("TODO");
          }
          return tx;
        }
        async getResult() {
          return await this.provider.getTransactionResult(this.hash);
        }
        async confirmations() {
          return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
        }
        removedEvent() {
          return createRemovedTransactionFilter(this);
        }
        reorderedEvent(other) {
          (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "reorderedEvent(other)"
          });
          return createReorderedTransactionFilter(this, other);
        }
      }
      exports.TransactionReceipt = TransactionReceipt;
      class TransactionResponse {
        provider;
        blockNumber;
        blockHash;
        index;
        hash;
        type;
        to;
        from;
        nonce;
        gasLimit;
        gasPrice;
        maxPriorityFeePerGas;
        maxFeePerGas;
        data;
        value;
        chainId;
        signature;
        accessList;
        #startBlock;
        constructor(tx, provider) {
          this.provider = provider;
          this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
          this.blockHash = tx.blockHash != null ? tx.blockHash : null;
          this.hash = tx.hash;
          this.index = tx.index;
          this.type = tx.type;
          this.from = tx.from;
          this.to = tx.to || null;
          this.gasLimit = tx.gasLimit;
          this.nonce = tx.nonce;
          this.data = tx.data;
          this.value = tx.value;
          this.gasPrice = tx.gasPrice;
          this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
          this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
          this.chainId = tx.chainId;
          this.signature = tx.signature;
          this.accessList = tx.accessList != null ? tx.accessList : null;
          this.#startBlock = -1;
        }
        toJSON() {
          const {
            blockNumber,
            blockHash,
            index,
            hash,
            type,
            to,
            from,
            nonce,
            data,
            signature,
            accessList
          } = this;
          return {
            _type: "TransactionReceipt",
            accessList,
            blockNumber,
            blockHash,
            chainId: toJson(this.chainId),
            data,
            from,
            gasLimit: toJson(this.gasLimit),
            gasPrice: toJson(this.gasPrice),
            hash,
            maxFeePerGas: toJson(this.maxFeePerGas),
            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
            nonce,
            signature,
            to,
            index,
            type,
            value: toJson(this.value)
          };
        }
        async getBlock() {
          let blockNumber = this.blockNumber;
          if (blockNumber == null) {
            const tx = await this.getTransaction();
            if (tx) {
              blockNumber = tx.blockNumber;
            }
          }
          if (blockNumber == null) {
            return null;
          }
          const block = this.provider.getBlock(blockNumber);
          if (block == null) {
            throw new Error("TODO");
          }
          return block;
        }
        async getTransaction() {
          return this.provider.getTransaction(this.hash);
        }
        async confirmations() {
          if (this.blockNumber == null) {
            const {
              tx,
              blockNumber
            } = await (0, index_js_1.resolveProperties)({
              tx: this.getTransaction(),
              blockNumber: this.provider.getBlockNumber()
            });
            if (tx == null || tx.blockNumber == null) {
              return 0;
            }
            return blockNumber - tx.blockNumber + 1;
          }
          const blockNumber = await this.provider.getBlockNumber();
          return blockNumber - this.blockNumber + 1;
        }
        async wait(_confirms, _timeout) {
          const confirms = _confirms == null ? 1 : _confirms;
          const timeout = _timeout == null ? 0 : _timeout;
          let startBlock = this.#startBlock;
          let nextScan = -1;
          let stopScanning = startBlock === -1 ? true : false;
          const checkReplacement = async () => {
            if (stopScanning) {
              return null;
            }
            const {
              blockNumber,
              nonce
            } = await (0, index_js_1.resolveProperties)({
              blockNumber: this.provider.getBlockNumber(),
              nonce: this.provider.getTransactionCount(this.from)
            });
            if (nonce < this.nonce) {
              startBlock = blockNumber;
              return;
            }
            if (stopScanning) {
              return null;
            }
            const mined = await this.getTransaction();
            if (mined && mined.blockNumber != null) {
              return;
            }
            if (nextScan === -1) {
              nextScan = startBlock - 3;
              if (nextScan < this.#startBlock) {
                nextScan = this.#startBlock;
              }
            }
            while (nextScan <= blockNumber) {
              if (stopScanning) {
                return null;
              }
              const block = await this.provider.getBlock(nextScan, true);
              if (block == null) {
                return;
              }
              for (const hash of block) {
                if (hash === this.hash) {
                  return;
                }
              }
              for (let i = 0; i < block.length; i++) {
                const tx = await block.getTransaction(i);
                if (tx.from === this.from && tx.nonce === this.nonce) {
                  if (stopScanning) {
                    return null;
                  }
                  const receipt = await this.provider.getTransactionReceipt(tx.hash);
                  if (receipt == null) {
                    return;
                  }
                  if (blockNumber - receipt.blockNumber + 1 < confirms) {
                    return;
                  }
                  let reason = "replaced";
                  if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                    reason = "repriced";
                  } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0) {
                    reason = "cancelled";
                  }
                  (0, index_js_1.assert)(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                    cancelled: reason === "replaced" || reason === "cancelled",
                    reason,
                    replacement: tx.replaceableTransaction(startBlock),
                    hash: tx.hash,
                    receipt
                  });
                }
              }
              nextScan++;
            }
            return;
          };
          const checkReceipt = receipt => {
            if (receipt == null || receipt.status !== 0) {
              return receipt;
            }
            (0, index_js_1.assert)(false, "transaction execution reverted", "CALL_EXCEPTION", {
              action: "sendTransaction",
              data: null,
              reason: null,
              invocation: null,
              revert: null,
              transaction: {
                to: receipt.to,
                from: receipt.from,
                data: ""
              },
              receipt
            });
          };
          const receipt = await this.provider.getTransactionReceipt(this.hash);
          if (confirms === 0) {
            return checkReceipt(receipt);
          }
          if (receipt) {
            if ((await receipt.confirmations()) >= confirms) {
              return checkReceipt(receipt);
            }
          } else {
            await checkReplacement();
            if (confirms === 0) {
              return null;
            }
          }
          const waiter = new Promise((resolve, reject) => {
            const cancellers = [];
            const cancel = () => {
              cancellers.forEach(c => c());
            };
            cancellers.push(() => {
              stopScanning = true;
            });
            if (timeout > 0) {
              const timer = setTimeout(() => {
                cancel();
                reject((0, index_js_1.makeError)("wait for transaction timeout", "TIMEOUT"));
              }, timeout);
              cancellers.push(() => {
                clearTimeout(timer);
              });
            }
            const txListener = async receipt => {
              if ((await receipt.confirmations()) >= confirms) {
                cancel();
                try {
                  resolve(checkReceipt(receipt));
                } catch (error) {
                  reject(error);
                }
              }
            };
            cancellers.push(() => {
              this.provider.off(this.hash, txListener);
            });
            this.provider.on(this.hash, txListener);
            if (startBlock >= 0) {
              const replaceListener = async () => {
                try {
                  await checkReplacement();
                } catch (error) {
                  if ((0, index_js_1.isError)(error, "TRANSACTION_REPLACED")) {
                    cancel();
                    reject(error);
                    return;
                  }
                }
                if (!stopScanning) {
                  this.provider.once("block", replaceListener);
                }
              };
              cancellers.push(() => {
                this.provider.off("block", replaceListener);
              });
              this.provider.once("block", replaceListener);
            }
          });
          return await waiter;
        }
        isMined() {
          return this.blockHash != null;
        }
        isLegacy() {
          return this.type === 0;
        }
        isBerlin() {
          return this.type === 1;
        }
        isLondon() {
          return this.type === 2;
        }
        removedEvent() {
          (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
          });
          return createRemovedTransactionFilter(this);
        }
        reorderedEvent(other) {
          (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
          });
          (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
          });
          return createReorderedTransactionFilter(this, other);
        }
        replaceableTransaction(startBlock) {
          (0, index_js_1.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
          const tx = new TransactionResponse(this, this.provider);
          tx.#startBlock = startBlock;
          return tx;
        }
      }
      exports.TransactionResponse = TransactionResponse;
      function createOrphanedBlockFilter(block) {
        return {
          orphan: "drop-block",
          hash: block.hash,
          number: block.number
        };
      }
      function createReorderedTransactionFilter(tx, other) {
        return {
          orphan: "reorder-transaction",
          tx,
          other
        };
      }
      function createRemovedTransactionFilter(tx) {
        return {
          orphan: "drop-transaction",
          tx
        };
      }
      function createRemovedLogFilter(log) {
        return {
          orphan: "drop-log",
          log: {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            address: log.address,
            data: log.data,
            topics: Object.freeze(log.topics.slice()),
            index: log.index
          }
        };
      }
    },
    3671: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NonceManager = void 0;
      const index_js_1 = __webpack_require__(9830);
      const abstract_signer_js_1 = __webpack_require__(8401);
      class NonceManager extends abstract_signer_js_1.AbstractSigner {
        signer;
        #noncePromise;
        #delta;
        constructor(signer) {
          super(signer.provider);
          (0, index_js_1.defineProperties)(this, {
            signer
          });
          this.#noncePromise = null;
          this.#delta = 0;
        }
        async getAddress() {
          return this.signer.getAddress();
        }
        connect(provider) {
          return new NonceManager(this.signer.connect(provider));
        }
        async getNonce(blockTag) {
          if (blockTag === "pending") {
            if (this.#noncePromise == null) {
              this.#noncePromise = super.getNonce("pending");
            }
            const delta = this.#delta;
            return (await this.#noncePromise) + delta;
          }
          return super.getNonce(blockTag);
        }
        increment() {
          this.#delta++;
        }
        reset() {
          this.#delta = 0;
          this.#noncePromise = null;
        }
        async sendTransaction(tx) {
          const noncePromise = this.getNonce("pending");
          this.increment();
          tx = await this.signer.populateTransaction(tx);
          tx.nonce = await noncePromise;
          return await this.signer.sendTransaction(tx);
        }
        signTransaction(tx) {
          return this.signer.signTransaction(tx);
        }
        signMessage(message) {
          return this.signer.signMessage(message);
        }
        signTypedData(domain, types, value) {
          return this.signer.signTypedData(domain, types, value);
        }
      }
      exports.NonceManager = NonceManager;
    },
    128: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FilterIdPendingSubscriber = exports.FilterIdEventSubscriber = exports.FilterIdSubscriber = void 0;
      const index_js_1 = __webpack_require__(9830);
      const subscriber_polling_js_1 = __webpack_require__(4975);
      function copy(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
      class FilterIdSubscriber {
        #provider;
        #filterIdPromise;
        #poller;
        #running;
        #network;
        #hault;
        constructor(provider) {
          this.#provider = provider;
          this.#filterIdPromise = null;
          this.#poller = this.#poll.bind(this);
          this.#running = false;
          this.#network = null;
          this.#hault = false;
        }
        _subscribe(provider) {
          throw new Error("subclasses must override this");
        }
        _emitResults(provider, result) {
          throw new Error("subclasses must override this");
        }
        _recover(provider) {
          throw new Error("subclasses must override this");
        }
        async #poll(blockNumber) {
          try {
            if (this.#filterIdPromise == null) {
              this.#filterIdPromise = this._subscribe(this.#provider);
            }
            let filterId = null;
            try {
              filterId = await this.#filterIdPromise;
            } catch (error) {
              if (!(0, index_js_1.isError)(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
                throw error;
              }
            }
            if (filterId == null) {
              this.#filterIdPromise = null;
              this.#provider._recoverSubscriber(this, this._recover(this.#provider));
              return;
            }
            const network = await this.#provider.getNetwork();
            if (!this.#network) {
              this.#network = network;
            }
            if (this.#network.chainId !== network.chainId) {
              throw new Error("chaid changed");
            }
            if (this.#hault) {
              return;
            }
            const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
            await this._emitResults(this.#provider, result);
          } catch (error) {
            console.log("@TODO", error);
          }
          this.#provider.once("block", this.#poller);
        }
        #teardown() {
          const filterIdPromise = this.#filterIdPromise;
          if (filterIdPromise) {
            this.#filterIdPromise = null;
            filterIdPromise.then(filterId => {
              this.#provider.send("eth_uninstallFilter", [filterId]);
            });
          }
        }
        start() {
          if (this.#running) {
            return;
          }
          this.#running = true;
          this.#poll(-2);
        }
        stop() {
          if (!this.#running) {
            return;
          }
          this.#running = false;
          this.#hault = true;
          this.#teardown();
          this.#provider.off("block", this.#poller);
        }
        pause(dropWhilePaused) {
          if (dropWhilePaused) {
            this.#teardown();
          }
          this.#provider.off("block", this.#poller);
        }
        resume() {
          this.start();
        }
      }
      exports.FilterIdSubscriber = FilterIdSubscriber;
      class FilterIdEventSubscriber extends FilterIdSubscriber {
        #event;
        constructor(provider, filter) {
          super(provider);
          this.#event = copy(filter);
        }
        _recover(provider) {
          return new subscriber_polling_js_1.PollingEventSubscriber(provider, this.#event);
        }
        async _subscribe(provider) {
          const filterId = await provider.send("eth_newFilter", [this.#event]);
          return filterId;
        }
        async _emitResults(provider, results) {
          for (const result of results) {
            provider.emit(this.#event, provider._wrapLog(result, provider._network));
          }
        }
      }
      exports.FilterIdEventSubscriber = FilterIdEventSubscriber;
      class FilterIdPendingSubscriber extends FilterIdSubscriber {
        async _subscribe(provider) {
          return await provider.send("eth_newPendingTransactionFilter", []);
        }
        async _emitResults(provider, results) {
          for (const result of results) {
            provider.emit("pending", result);
          }
        }
      }
      exports.FilterIdPendingSubscriber = FilterIdPendingSubscriber;
    },
    4975: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;
      const index_js_1 = __webpack_require__(9830);
      function copy(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
      function getPollingSubscriber(provider, event) {
        if (event === "block") {
          return new PollingBlockSubscriber(provider);
        }
        if ((0, index_js_1.isHexString)(event, 32)) {
          return new PollingTransactionSubscriber(provider, event);
        }
        (0, index_js_1.assert)(false, "unsupported polling event", "UNSUPPORTED_OPERATION", {
          operation: "getPollingSubscriber",
          info: {
            event
          }
        });
      }
      exports.getPollingSubscriber = getPollingSubscriber;
      class PollingBlockSubscriber {
        #provider;
        #poller;
        #interval;
        #blockNumber;
        constructor(provider) {
          this.#provider = provider;
          this.#poller = null;
          this.#interval = 4000;
          this.#blockNumber = -2;
        }
        get pollingInterval() {
          return this.#interval;
        }
        set pollingInterval(value) {
          this.#interval = value;
        }
        async #poll() {
          try {
            const blockNumber = await this.#provider.getBlockNumber();
            if (this.#blockNumber === -2) {
              this.#blockNumber = blockNumber;
              return;
            }
            if (blockNumber !== this.#blockNumber) {
              for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {
                if (this.#poller == null) {
                  return;
                }
                await this.#provider.emit("block", b);
              }
              this.#blockNumber = blockNumber;
            }
          } catch (error) {}
          if (this.#poller == null) {
            return;
          }
          this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
        }
        start() {
          if (this.#poller) {
            return;
          }
          this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
          this.#poll();
        }
        stop() {
          if (!this.#poller) {
            return;
          }
          this.#provider._clearTimeout(this.#poller);
          this.#poller = null;
        }
        pause(dropWhilePaused) {
          this.stop();
          if (dropWhilePaused) {
            this.#blockNumber = -2;
          }
        }
        resume() {
          this.start();
        }
      }
      exports.PollingBlockSubscriber = PollingBlockSubscriber;
      class OnBlockSubscriber {
        #provider;
        #poll;
        #running;
        constructor(provider) {
          this.#provider = provider;
          this.#running = false;
          this.#poll = blockNumber => {
            this._poll(blockNumber, this.#provider);
          };
        }
        async _poll(blockNumber, provider) {
          throw new Error("sub-classes must override this");
        }
        start() {
          if (this.#running) {
            return;
          }
          this.#running = true;
          this.#poll(-2);
          this.#provider.on("block", this.#poll);
        }
        stop() {
          if (!this.#running) {
            return;
          }
          this.#running = false;
          this.#provider.off("block", this.#poll);
        }
        pause(dropWhilePaused) {
          this.stop();
        }
        resume() {
          this.start();
        }
      }
      exports.OnBlockSubscriber = OnBlockSubscriber;
      class PollingOrphanSubscriber extends OnBlockSubscriber {
        #filter;
        constructor(provider, filter) {
          super(provider);
          this.#filter = copy(filter);
        }
        async _poll(blockNumber, provider) {
          throw new Error("@TODO");
          console.log(this.#filter);
        }
      }
      exports.PollingOrphanSubscriber = PollingOrphanSubscriber;
      class PollingTransactionSubscriber extends OnBlockSubscriber {
        #hash;
        constructor(provider, hash) {
          super(provider);
          this.#hash = hash;
        }
        async _poll(blockNumber, provider) {
          const tx = await provider.getTransactionReceipt(this.#hash);
          if (tx) {
            provider.emit(this.#hash, tx);
          }
        }
      }
      exports.PollingTransactionSubscriber = PollingTransactionSubscriber;
      class PollingEventSubscriber {
        #provider;
        #filter;
        #poller;
        #running;
        #blockNumber;
        constructor(provider, filter) {
          this.#provider = provider;
          this.#filter = copy(filter);
          this.#poller = this.#poll.bind(this);
          this.#running = false;
          this.#blockNumber = -2;
        }
        async #poll(blockNumber) {
          if (this.#blockNumber === -2) {
            return;
          }
          const filter = copy(this.#filter);
          filter.fromBlock = this.#blockNumber + 1;
          filter.toBlock = blockNumber;
          const logs = await this.#provider.getLogs(filter);
          if (logs.length === 0) {
            if (this.#blockNumber < blockNumber - 60) {
              this.#blockNumber = blockNumber - 60;
            }
            return;
          }
          for (const log of logs) {
            this.#provider.emit(this.#filter, log);
            this.#blockNumber = log.blockNumber;
          }
        }
        start() {
          if (this.#running) {
            return;
          }
          this.#running = true;
          if (this.#blockNumber === -2) {
            this.#provider.getBlockNumber().then(blockNumber => {
              this.#blockNumber = blockNumber;
            });
          }
          this.#provider.on("block", this.#poller);
        }
        stop() {
          if (!this.#running) {
            return;
          }
          this.#running = false;
          this.#provider.off("block", this.#poller);
        }
        pause(dropWhilePaused) {
          this.stop();
          if (dropWhilePaused) {
            this.#blockNumber = -2;
          }
        }
        resume() {
          this.start();
        }
      }
      exports.PollingEventSubscriber = PollingEventSubscriber;
    },
    8620: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.WebSocket = void 0;
      function getGlobal() {
        if (typeof self !== 'undefined') {
          return self;
        }
        if (typeof window !== 'undefined') {
          return window;
        }
        if (typeof __webpack_require__.g !== 'undefined') {
          return __webpack_require__.g;
        }
        throw new Error('unable to locate global object');
      }
      ;
      const _WebSocket = getGlobal().WebSocket;
      exports.WebSocket = _WebSocket;
    },
    1612: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.accessListify = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(9830);
      function accessSetify(addr, storageKeys) {
        return {
          address: (0, index_js_1.getAddress)(addr),
          storageKeys: storageKeys.map((storageKey, index) => {
            (0, index_js_2.assertArgument)((0, index_js_2.isHexString)(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
            return storageKey.toLowerCase();
          })
        };
      }
      function accessListify(value) {
        if (Array.isArray(value)) {
          return value.map((set, index) => {
            if (Array.isArray(set)) {
              (0, index_js_2.assertArgument)(set.length === 2, "invalid slot set", `value[${index}]`, set);
              return accessSetify(set[0], set[1]);
            }
            (0, index_js_2.assertArgument)(set != null && typeof set === "object", "invalid address-slot set", "value", value);
            return accessSetify(set.address, set.storageKeys);
          });
        }
        (0, index_js_2.assertArgument)(value != null && typeof value === "object", "invalid access list", "value", value);
        const result = Object.keys(value).map(addr => {
          const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
          }, {});
          return accessSetify(addr, Object.keys(storageKeys).sort());
        });
        result.sort((a, b) => a.address.localeCompare(b.address));
        return result;
      }
      exports.accessListify = accessListify;
    },
    3782: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.recoverAddress = exports.computeAddress = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(9420);
      function computeAddress(key) {
        let pubkey;
        if (typeof key === "string") {
          pubkey = index_js_2.SigningKey.computePublicKey(key, false);
        } else {
          pubkey = key.publicKey;
        }
        return (0, index_js_1.getAddress)((0, index_js_2.keccak256)("0x" + pubkey.substring(4)).substring(26));
      }
      exports.computeAddress = computeAddress;
      function recoverAddress(digest, signature) {
        return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));
      }
      exports.recoverAddress = recoverAddress;
    },
    2877: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = void 0;
      null;
      var accesslist_js_1 = __webpack_require__(1612);
      Object.defineProperty(exports, "accessListify", {
        enumerable: true,
        get: function () {
          return accesslist_js_1.accessListify;
        }
      });
      var address_js_1 = __webpack_require__(3782);
      Object.defineProperty(exports, "computeAddress", {
        enumerable: true,
        get: function () {
          return address_js_1.computeAddress;
        }
      });
      Object.defineProperty(exports, "recoverAddress", {
        enumerable: true,
        get: function () {
          return address_js_1.recoverAddress;
        }
      });
      var transaction_js_1 = __webpack_require__(80);
      Object.defineProperty(exports, "Transaction", {
        enumerable: true,
        get: function () {
          return transaction_js_1.Transaction;
        }
      });
    },
    80: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Transaction = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(9420);
      const index_js_3 = __webpack_require__(9830);
      const accesslist_js_1 = __webpack_require__(1612);
      const address_js_1 = __webpack_require__(3782);
      const BN_0 = BigInt(0);
      const BN_2 = BigInt(2);
      const BN_27 = BigInt(27);
      const BN_28 = BigInt(28);
      const BN_35 = BigInt(35);
      const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      function handleAddress(value) {
        if (value === "0x") {
          return null;
        }
        return (0, index_js_1.getAddress)(value);
      }
      function handleAccessList(value, param) {
        try {
          return (0, accesslist_js_1.accessListify)(value);
        } catch (error) {
          (0, index_js_3.assertArgument)(false, error.message, param, value);
        }
      }
      function handleNumber(_value, param) {
        if (_value === "0x") {
          return 0;
        }
        return (0, index_js_3.getNumber)(_value, param);
      }
      function handleUint(_value, param) {
        if (_value === "0x") {
          return BN_0;
        }
        const value = (0, index_js_3.getBigInt)(_value, param);
        (0, index_js_3.assertArgument)(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
        return value;
      }
      function formatNumber(_value, name) {
        const value = (0, index_js_3.getBigInt)(_value, "value");
        const result = (0, index_js_3.toBeArray)(value);
        (0, index_js_3.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);
        return result;
      }
      function formatAccessList(value) {
        return (0, accesslist_js_1.accessListify)(value).map(set => [set.address, set.storageKeys]);
      }
      function _parseLegacy(data) {
        const fields = (0, index_js_3.decodeRlp)(data);
        (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
        const tx = {
          type: 0,
          nonce: handleNumber(fields[0], "nonce"),
          gasPrice: handleUint(fields[1], "gasPrice"),
          gasLimit: handleUint(fields[2], "gasLimit"),
          to: handleAddress(fields[3]),
          value: handleUint(fields[4], "value"),
          data: (0, index_js_3.hexlify)(fields[5]),
          chainId: BN_0
        };
        if (fields.length === 6) {
          return tx;
        }
        const v = handleUint(fields[6], "v");
        const r = handleUint(fields[7], "r");
        const s = handleUint(fields[8], "s");
        if (r === BN_0 && s === BN_0) {
          tx.chainId = v;
        } else {
          let chainId = (v - BN_35) / BN_2;
          if (chainId < BN_0) {
            chainId = BN_0;
          }
          tx.chainId = chainId;
          (0, index_js_3.assertArgument)(chainId !== BN_0 || v === BN_27 || v === BN_28, "non-canonical legacy v", "v", fields[6]);
          tx.signature = index_js_2.Signature.from({
            r: (0, index_js_3.zeroPadValue)(fields[7], 32),
            s: (0, index_js_3.zeroPadValue)(fields[8], 32),
            v
          });
          tx.hash = (0, index_js_2.keccak256)(data);
        }
        return tx;
      }
      function _serializeLegacy(tx, sig) {
        const fields = [formatNumber(tx.nonce || 0, "nonce"), formatNumber(tx.gasPrice || 0, "gasPrice"), formatNumber(tx.gasLimit || 0, "gasLimit"), tx.to != null ? (0, index_js_1.getAddress)(tx.to) : "0x", formatNumber(tx.value || 0, "value"), tx.data || "0x"];
        let chainId = BN_0;
        if (tx.chainId != BN_0) {
          chainId = (0, index_js_3.getBigInt)(tx.chainId, "tx.chainId");
          (0, index_js_3.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
        } else if (tx.signature) {
          const legacy = tx.signature.legacyChainId;
          if (legacy != null) {
            chainId = legacy;
          }
        }
        if (!sig) {
          if (chainId !== BN_0) {
            fields.push((0, index_js_3.toBeArray)(chainId));
            fields.push("0x");
            fields.push("0x");
          }
          return (0, index_js_3.encodeRlp)(fields);
        }
        let v = BigInt(27 + sig.yParity);
        if (chainId !== BN_0) {
          v = index_js_2.Signature.getChainIdV(chainId, sig.v);
        } else if (BigInt(sig.v) !== v) {
          (0, index_js_3.assertArgument)(false, "tx.chainId/sig.v mismatch", "sig", sig);
        }
        fields.push((0, index_js_3.toBeArray)(v));
        fields.push((0, index_js_3.toBeArray)(sig.r));
        fields.push((0, index_js_3.toBeArray)(sig.s));
        return (0, index_js_3.encodeRlp)(fields);
      }
      function _parseEipSignature(tx, fields) {
        let yParity;
        try {
          yParity = handleNumber(fields[0], "yParity");
          if (yParity !== 0 && yParity !== 1) {
            throw new Error("bad yParity");
          }
        } catch (error) {
          (0, index_js_3.assertArgument)(false, "invalid yParity", "yParity", fields[0]);
        }
        const r = (0, index_js_3.zeroPadValue)(fields[1], 32);
        const s = (0, index_js_3.zeroPadValue)(fields[2], 32);
        const signature = index_js_2.Signature.from({
          r,
          s,
          yParity
        });
        tx.signature = signature;
      }
      function _parseEip1559(data) {
        const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
        (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", (0, index_js_3.hexlify)(data));
        const maxPriorityFeePerGas = handleUint(fields[2], "maxPriorityFeePerGas");
        const maxFeePerGas = handleUint(fields[3], "maxFeePerGas");
        const tx = {
          type: 2,
          chainId: handleUint(fields[0], "chainId"),
          nonce: handleNumber(fields[1], "nonce"),
          maxPriorityFeePerGas: maxPriorityFeePerGas,
          maxFeePerGas: maxFeePerGas,
          gasPrice: null,
          gasLimit: handleUint(fields[4], "gasLimit"),
          to: handleAddress(fields[5]),
          value: handleUint(fields[6], "value"),
          data: (0, index_js_3.hexlify)(fields[7]),
          accessList: handleAccessList(fields[8], "accessList")
        };
        if (fields.length === 9) {
          return tx;
        }
        tx.hash = (0, index_js_2.keccak256)(data);
        _parseEipSignature(tx, fields.slice(9));
        return tx;
      }
      function _serializeEip1559(tx, sig) {
        const fields = [formatNumber(tx.chainId || 0, "chainId"), formatNumber(tx.nonce || 0, "nonce"), formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(tx.gasLimit || 0, "gasLimit"), tx.to != null ? (0, index_js_1.getAddress)(tx.to) : "0x", formatNumber(tx.value || 0, "value"), tx.data || "0x", formatAccessList(tx.accessList || [])];
        if (sig) {
          fields.push(formatNumber(sig.yParity, "yParity"));
          fields.push((0, index_js_3.toBeArray)(sig.r));
          fields.push((0, index_js_3.toBeArray)(sig.s));
        }
        return (0, index_js_3.concat)(["0x02", (0, index_js_3.encodeRlp)(fields)]);
      }
      function _parseEip2930(data) {
        const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
        (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", (0, index_js_3.hexlify)(data));
        const tx = {
          type: 1,
          chainId: handleUint(fields[0], "chainId"),
          nonce: handleNumber(fields[1], "nonce"),
          gasPrice: handleUint(fields[2], "gasPrice"),
          gasLimit: handleUint(fields[3], "gasLimit"),
          to: handleAddress(fields[4]),
          value: handleUint(fields[5], "value"),
          data: (0, index_js_3.hexlify)(fields[6]),
          accessList: handleAccessList(fields[7], "accessList")
        };
        if (fields.length === 8) {
          return tx;
        }
        tx.hash = (0, index_js_2.keccak256)(data);
        _parseEipSignature(tx, fields.slice(8));
        return tx;
      }
      function _serializeEip2930(tx, sig) {
        const fields = [formatNumber(tx.chainId || 0, "chainId"), formatNumber(tx.nonce || 0, "nonce"), formatNumber(tx.gasPrice || 0, "gasPrice"), formatNumber(tx.gasLimit || 0, "gasLimit"), tx.to != null ? (0, index_js_1.getAddress)(tx.to) : "0x", formatNumber(tx.value || 0, "value"), tx.data || "0x", formatAccessList(tx.accessList || [])];
        if (sig) {
          fields.push(formatNumber(sig.yParity, "recoveryParam"));
          fields.push((0, index_js_3.toBeArray)(sig.r));
          fields.push((0, index_js_3.toBeArray)(sig.s));
        }
        return (0, index_js_3.concat)(["0x01", (0, index_js_3.encodeRlp)(fields)]);
      }
      class Transaction {
        #type;
        #to;
        #data;
        #nonce;
        #gasLimit;
        #gasPrice;
        #maxPriorityFeePerGas;
        #maxFeePerGas;
        #value;
        #chainId;
        #sig;
        #accessList;
        get type() {
          return this.#type;
        }
        set type(value) {
          switch (value) {
            case null:
              this.#type = null;
              break;
            case 0:
            case "legacy":
              this.#type = 0;
              break;
            case 1:
            case "berlin":
            case "eip-2930":
              this.#type = 1;
              break;
            case 2:
            case "london":
            case "eip-1559":
              this.#type = 2;
              break;
            default:
              (0, index_js_3.assertArgument)(false, "unsupported transaction type", "type", value);
          }
        }
        get typeName() {
          switch (this.type) {
            case 0:
              return "legacy";
            case 1:
              return "eip-2930";
            case 2:
              return "eip-1559";
          }
          return null;
        }
        get to() {
          return this.#to;
        }
        set to(value) {
          this.#to = value == null ? null : (0, index_js_1.getAddress)(value);
        }
        get nonce() {
          return this.#nonce;
        }
        set nonce(value) {
          this.#nonce = (0, index_js_3.getNumber)(value, "value");
        }
        get gasLimit() {
          return this.#gasLimit;
        }
        set gasLimit(value) {
          this.#gasLimit = (0, index_js_3.getBigInt)(value);
        }
        get gasPrice() {
          const value = this.#gasPrice;
          if (value == null && (this.type === 0 || this.type === 1)) {
            return BN_0;
          }
          return value;
        }
        set gasPrice(value) {
          this.#gasPrice = value == null ? null : (0, index_js_3.getBigInt)(value, "gasPrice");
        }
        get maxPriorityFeePerGas() {
          const value = this.#maxPriorityFeePerGas;
          if (value == null) {
            if (this.type === 2) {
              return BN_0;
            }
            return null;
          }
          return value;
        }
        set maxPriorityFeePerGas(value) {
          this.#maxPriorityFeePerGas = value == null ? null : (0, index_js_3.getBigInt)(value, "maxPriorityFeePerGas");
        }
        get maxFeePerGas() {
          const value = this.#maxFeePerGas;
          if (value == null) {
            if (this.type === 2) {
              return BN_0;
            }
            return null;
          }
          return value;
        }
        set maxFeePerGas(value) {
          this.#maxFeePerGas = value == null ? null : (0, index_js_3.getBigInt)(value, "maxFeePerGas");
        }
        get data() {
          return this.#data;
        }
        set data(value) {
          this.#data = (0, index_js_3.hexlify)(value);
        }
        get value() {
          return this.#value;
        }
        set value(value) {
          this.#value = (0, index_js_3.getBigInt)(value, "value");
        }
        get chainId() {
          return this.#chainId;
        }
        set chainId(value) {
          this.#chainId = (0, index_js_3.getBigInt)(value);
        }
        get signature() {
          return this.#sig || null;
        }
        set signature(value) {
          this.#sig = value == null ? null : index_js_2.Signature.from(value);
        }
        get accessList() {
          const value = this.#accessList || null;
          if (value == null) {
            if (this.type === 1 || this.type === 2) {
              return [];
            }
            return null;
          }
          return value;
        }
        set accessList(value) {
          this.#accessList = value == null ? null : (0, accesslist_js_1.accessListify)(value);
        }
        constructor() {
          this.#type = null;
          this.#to = null;
          this.#nonce = 0;
          this.#gasLimit = BigInt(0);
          this.#gasPrice = null;
          this.#maxPriorityFeePerGas = null;
          this.#maxFeePerGas = null;
          this.#data = "0x";
          this.#value = BigInt(0);
          this.#chainId = BigInt(0);
          this.#sig = null;
          this.#accessList = null;
        }
        get hash() {
          if (this.signature == null) {
            return null;
          }
          return (0, index_js_2.keccak256)(this.serialized);
        }
        get unsignedHash() {
          return (0, index_js_2.keccak256)(this.unsignedSerialized);
        }
        get from() {
          if (this.signature == null) {
            return null;
          }
          return (0, address_js_1.recoverAddress)(this.unsignedHash, this.signature);
        }
        get fromPublicKey() {
          if (this.signature == null) {
            return null;
          }
          return index_js_2.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
        }
        isSigned() {
          return this.signature != null;
        }
        get serialized() {
          (0, index_js_3.assert)(this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
            operation: ".serialized"
          });
          switch (this.inferType()) {
            case 0:
              return _serializeLegacy(this, this.signature);
            case 1:
              return _serializeEip2930(this, this.signature);
            case 2:
              return _serializeEip1559(this, this.signature);
          }
          (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
            operation: ".serialized"
          });
        }
        get unsignedSerialized() {
          switch (this.inferType()) {
            case 0:
              return _serializeLegacy(this);
            case 1:
              return _serializeEip2930(this);
            case 2:
              return _serializeEip1559(this);
          }
          (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
            operation: ".unsignedSerialized"
          });
        }
        inferType() {
          return this.inferTypes().pop();
        }
        inferTypes() {
          const hasGasPrice = this.gasPrice != null;
          const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
          const hasAccessList = this.accessList != null;
          if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
            (0, index_js_3.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
              value: this
            });
          }
          (0, index_js_3.assert)(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
            value: this
          });
          (0, index_js_3.assert)(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", {
            value: this
          });
          const types = [];
          if (this.type != null) {
            types.push(this.type);
          } else {
            if (hasFee) {
              types.push(2);
            } else if (hasGasPrice) {
              types.push(1);
              if (!hasAccessList) {
                types.push(0);
              }
            } else if (hasAccessList) {
              types.push(1);
              types.push(2);
            } else {
              types.push(0);
              types.push(1);
              types.push(2);
            }
          }
          types.sort();
          return types;
        }
        isLegacy() {
          return this.type === 0;
        }
        isBerlin() {
          return this.type === 1;
        }
        isLondon() {
          return this.type === 2;
        }
        clone() {
          return Transaction.from(this);
        }
        toJSON() {
          const s = v => {
            if (v == null) {
              return null;
            }
            return v.toString();
          };
          return {
            type: this.type,
            to: this.to,
            data: this.data,
            nonce: this.nonce,
            gasLimit: s(this.gasLimit),
            gasPrice: s(this.gasPrice),
            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
            maxFeePerGas: s(this.maxFeePerGas),
            value: s(this.value),
            chainId: s(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList
          };
        }
        static from(tx) {
          if (tx == null) {
            return new Transaction();
          }
          if (typeof tx === "string") {
            const payload = (0, index_js_3.getBytes)(tx);
            if (payload[0] >= 0x7f) {
              return Transaction.from(_parseLegacy(payload));
            }
            switch (payload[0]) {
              case 1:
                return Transaction.from(_parseEip2930(payload));
              case 2:
                return Transaction.from(_parseEip1559(payload));
            }
            (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: "from"
            });
          }
          const result = new Transaction();
          if (tx.type != null) {
            result.type = tx.type;
          }
          if (tx.to != null) {
            result.to = tx.to;
          }
          if (tx.nonce != null) {
            result.nonce = tx.nonce;
          }
          if (tx.gasLimit != null) {
            result.gasLimit = tx.gasLimit;
          }
          if (tx.gasPrice != null) {
            result.gasPrice = tx.gasPrice;
          }
          if (tx.maxPriorityFeePerGas != null) {
            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
          }
          if (tx.maxFeePerGas != null) {
            result.maxFeePerGas = tx.maxFeePerGas;
          }
          if (tx.data != null) {
            result.data = tx.data;
          }
          if (tx.value != null) {
            result.value = tx.value;
          }
          if (tx.chainId != null) {
            result.chainId = tx.chainId;
          }
          if (tx.signature != null) {
            result.signature = index_js_2.Signature.from(tx.signature);
          }
          if (tx.accessList != null) {
            result.accessList = tx.accessList;
          }
          if (tx.hash != null) {
            (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define hash", "tx", tx);
            (0, index_js_3.assertArgument)(result.hash === tx.hash, "hash mismatch", "tx", tx);
          }
          if (tx.from != null) {
            (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define from", "tx", tx);
            (0, index_js_3.assertArgument)(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
          }
          return result;
        }
      }
      exports.Transaction = Transaction;
    },
    5637: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decodeBase58 = exports.encodeBase58 = void 0;
      const data_js_1 = __webpack_require__(7924);
      const errors_js_1 = __webpack_require__(7505);
      const maths_js_1 = __webpack_require__(9018);
      const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      let Lookup = null;
      function getAlpha(letter) {
        if (Lookup == null) {
          Lookup = {};
          for (let i = 0; i < Alphabet.length; i++) {
            Lookup[Alphabet[i]] = BigInt(i);
          }
        }
        const result = Lookup[letter];
        (0, errors_js_1.assertArgument)(result != null, `invalid base58 value`, "letter", letter);
        return result;
      }
      const BN_0 = BigInt(0);
      const BN_58 = BigInt(58);
      function encodeBase58(_value) {
        let value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value));
        let result = "";
        while (value) {
          result = Alphabet[Number(value % BN_58)] + result;
          value /= BN_58;
        }
        return result;
      }
      exports.encodeBase58 = encodeBase58;
      function decodeBase58(value) {
        let result = BN_0;
        for (let i = 0; i < value.length; i++) {
          result *= BN_58;
          result += getAlpha(value[i]);
        }
        return result;
      }
      exports.decodeBase58 = decodeBase58;
    },
    7993: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.encodeBase64 = exports.decodeBase64 = void 0;
      const data_js_1 = __webpack_require__(7924);
      function decodeBase64(textData) {
        textData = atob(textData);
        const data = new Uint8Array(textData.length);
        for (let i = 0; i < textData.length; i++) {
          data[i] = textData.charCodeAt(i);
        }
        return (0, data_js_1.getBytes)(data);
      }
      exports.decodeBase64 = decodeBase64;
      function encodeBase64(_data) {
        const data = (0, data_js_1.getBytes)(_data);
        let textData = "";
        for (let i = 0; i < data.length; i++) {
          textData += String.fromCharCode(data[i]);
        }
        return btoa(textData);
      }
      exports.encodeBase64 = encodeBase64;
    },
    7924: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = void 0;
      const errors_js_1 = __webpack_require__(7505);
      function _getBytes(value, name, copy) {
        if (value instanceof Uint8Array) {
          if (copy) {
            return new Uint8Array(value);
          }
          return value;
        }
        if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
          const result = new Uint8Array((value.length - 2) / 2);
          let offset = 2;
          for (let i = 0; i < result.length; i++) {
            result[i] = parseInt(value.substring(offset, offset + 2), 16);
            offset += 2;
          }
          return result;
        }
        (0, errors_js_1.assertArgument)(false, "invalid BytesLike value", name || "value", value);
      }
      function getBytes(value, name) {
        return _getBytes(value, name, false);
      }
      exports.getBytes = getBytes;
      function getBytesCopy(value, name) {
        return _getBytes(value, name, true);
      }
      exports.getBytesCopy = getBytesCopy;
      function isHexString(value, length) {
        if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
          return false;
        }
        if (typeof length === "number" && value.length !== 2 + 2 * length) {
          return false;
        }
        if (length === true && value.length % 2 !== 0) {
          return false;
        }
        return true;
      }
      exports.isHexString = isHexString;
      function isBytesLike(value) {
        return isHexString(value, true) || value instanceof Uint8Array;
      }
      exports.isBytesLike = isBytesLike;
      const HexCharacters = "0123456789abcdef";
      function hexlify(data) {
        const bytes = getBytes(data);
        let result = "0x";
        for (let i = 0; i < bytes.length; i++) {
          const v = bytes[i];
          result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
      }
      exports.hexlify = hexlify;
      function concat(datas) {
        return "0x" + datas.map(d => hexlify(d).substring(2)).join("");
      }
      exports.concat = concat;
      function dataLength(data) {
        if (isHexString(data, true)) {
          return (data.length - 2) / 2;
        }
        return getBytes(data).length;
      }
      exports.dataLength = dataLength;
      function dataSlice(data, start, end) {
        const bytes = getBytes(data);
        if (end != null && end > bytes.length) {
          (0, errors_js_1.assert)(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
            buffer: bytes,
            length: bytes.length,
            offset: end
          });
        }
        return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
      }
      exports.dataSlice = dataSlice;
      function stripZerosLeft(data) {
        let bytes = hexlify(data).substring(2);
        while (bytes.startsWith("00")) {
          bytes = bytes.substring(2);
        }
        return "0x" + bytes;
      }
      exports.stripZerosLeft = stripZerosLeft;
      function zeroPad(data, length, left) {
        const bytes = getBytes(data);
        (0, errors_js_1.assert)(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
          buffer: new Uint8Array(bytes),
          length: length,
          offset: length + 1
        });
        const result = new Uint8Array(length);
        result.fill(0);
        if (left) {
          result.set(bytes, length - bytes.length);
        } else {
          result.set(bytes, 0);
        }
        return hexlify(result);
      }
      function zeroPadValue(data, length) {
        return zeroPad(data, length, true);
      }
      exports.zeroPadValue = zeroPadValue;
      function zeroPadBytes(data, length) {
        return zeroPad(data, length, false);
      }
      exports.zeroPadBytes = zeroPadBytes;
    },
    7505: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.makeError = exports.isCallException = exports.isError = void 0;
      const _version_js_1 = __webpack_require__(9737);
      const properties_js_1 = __webpack_require__(9795);
      function stringify(value) {
        if (value == null) {
          return "null";
        }
        if (Array.isArray(value)) {
          return "[ " + value.map(stringify).join(", ") + " ]";
        }
        if (value instanceof Uint8Array) {
          const HEX = "0123456789abcdef";
          let result = "0x";
          for (let i = 0; i < value.length; i++) {
            result += HEX[value[i] >> 4];
            result += HEX[value[i] & 0xf];
          }
          return result;
        }
        if (typeof value === "object" && typeof value.toJSON === "function") {
          return stringify(value.toJSON());
        }
        switch (typeof value) {
          case "boolean":
          case "symbol":
            return value.toString();
          case "bigint":
            return BigInt(value).toString();
          case "number":
            return value.toString();
          case "string":
            return JSON.stringify(value);
          case "object":
            {
              const keys = Object.keys(value);
              keys.sort();
              return "{ " + keys.map(k => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
            }
        }
        return `[ COULD NOT SERIALIZE ]`;
      }
      function isError(error, code) {
        return error && error.code === code;
      }
      exports.isError = isError;
      function isCallException(error) {
        return isError(error, "CALL_EXCEPTION");
      }
      exports.isCallException = isCallException;
      function makeError(message, code, info) {
        {
          const details = [];
          if (info) {
            if ("message" in info || "code" in info || "name" in info) {
              throw new Error(`value will overwrite populated values: ${stringify(info)}`);
            }
            for (const key in info) {
              const value = info[key];
              details.push(key + "=" + stringify(value));
            }
          }
          details.push(`code=${code}`);
          details.push(`version=${_version_js_1.version}`);
          if (details.length) {
            message += " (" + details.join(", ") + ")";
          }
        }
        let error;
        switch (code) {
          case "INVALID_ARGUMENT":
            error = new TypeError(message);
            break;
          case "NUMERIC_FAULT":
          case "BUFFER_OVERRUN":
            error = new RangeError(message);
            break;
          default:
            error = new Error(message);
        }
        (0, properties_js_1.defineProperties)(error, {
          code
        });
        if (info) {
          Object.assign(error, info);
        }
        return error;
      }
      exports.makeError = makeError;
      function assert(check, message, code, info) {
        if (!check) {
          throw makeError(message, code, info);
        }
      }
      exports.assert = assert;
      function assertArgument(check, message, name, value) {
        assert(check, message, "INVALID_ARGUMENT", {
          argument: name,
          value: value
        });
      }
      exports.assertArgument = assertArgument;
      function assertArgumentCount(count, expectedCount, message) {
        if (message == null) {
          message = "";
        }
        if (message) {
          message = ": " + message;
        }
        assert(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
          count: count,
          expectedCount: expectedCount
        });
        assert(count <= expectedCount, "too many arguemnts" + message, "UNEXPECTED_ARGUMENT", {
          count: count,
          expectedCount: expectedCount
        });
      }
      exports.assertArgumentCount = assertArgumentCount;
      const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
        try {
          if ("test".normalize(form) !== "test") {
            throw new Error("bad");
          }
          ;
          if (form === "NFD") {
            const check = String.fromCharCode(0xe9).normalize("NFD");
            const expected = String.fromCharCode(0x65, 0x0301);
            if (check !== expected) {
              throw new Error("broken");
            }
          }
          accum.push(form);
        } catch (error) {}
        return accum;
      }, []);
      function assertNormalize(form) {
        assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
          operation: "String.prototype.normalize",
          info: {
            form
          }
        });
      }
      exports.assertNormalize = assertNormalize;
      function assertPrivate(givenGuard, guard, className) {
        if (className == null) {
          className = "";
        }
        if (givenGuard !== guard) {
          let method = className,
            operation = "new";
          if (className) {
            method += ".";
            operation += " " + className;
          }
          assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
            operation
          });
        }
      }
      exports.assertPrivate = assertPrivate;
    },
    7961: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.EventPayload = void 0;
      const properties_js_1 = __webpack_require__(9795);
      class EventPayload {
        filter;
        emitter;
        #listener;
        constructor(emitter, listener, filter) {
          this.#listener = listener;
          (0, properties_js_1.defineProperties)(this, {
            emitter,
            filter
          });
        }
        async removeListener() {
          if (this.#listener == null) {
            return;
          }
          await this.emitter.off(this.filter, this.#listener);
        }
      }
      exports.EventPayload = EventPayload;
    },
    7121: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FetchResponse = exports.FetchRequest = exports.FetchCancelSignal = void 0;
      const base64_js_1 = __webpack_require__(7993);
      const data_js_1 = __webpack_require__(7924);
      const errors_js_1 = __webpack_require__(7505);
      const properties_js_1 = __webpack_require__(9795);
      const utf8_js_1 = __webpack_require__(8002);
      const geturl_js_1 = __webpack_require__(5296);
      const MAX_ATTEMPTS = 12;
      const SLOT_INTERVAL = 250;
      let getUrlFunc = geturl_js_1.getUrl;
      const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
      const reIpfs = new RegExp("^ipfs:/\/(ipfs/)?(.*)$", "i");
      let locked = false;
      async function dataGatewayFunc(url, signal) {
        try {
          const match = url.match(reData);
          if (!match) {
            throw new Error("invalid data");
          }
          return new FetchResponse(200, "OK", {
            "content-type": match[1] || "text/plain"
          }, match[2] ? (0, base64_js_1.decodeBase64)(match[3]) : unpercent(match[3]));
        } catch (error) {
          return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
        }
      }
      function getIpfsGatewayFunc(baseUrl) {
        async function gatewayIpfs(url, signal) {
          try {
            const match = url.match(reIpfs);
            if (!match) {
              throw new Error("invalid link");
            }
            return new FetchRequest(`${baseUrl}${match[2]}`);
          } catch (error) {
            return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
          }
        }
        return gatewayIpfs;
      }
      const Gateways = {
        "data": dataGatewayFunc,
        "ipfs": getIpfsGatewayFunc("https:/\/gateway.ipfs.io/ipfs/")
      };
      const fetchSignals = new WeakMap();
      class FetchCancelSignal {
        #listeners;
        #cancelled;
        constructor(request) {
          this.#listeners = [];
          this.#cancelled = false;
          fetchSignals.set(request, () => {
            if (this.#cancelled) {
              return;
            }
            this.#cancelled = true;
            for (const listener of this.#listeners) {
              setTimeout(() => {
                listener();
              }, 0);
            }
            this.#listeners = [];
          });
        }
        addListener(listener) {
          (0, errors_js_1.assert)(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
            operation: "fetchCancelSignal.addCancelListener"
          });
          this.#listeners.push(listener);
        }
        get cancelled() {
          return this.#cancelled;
        }
        checkSignal() {
          (0, errors_js_1.assert)(!this.cancelled, "cancelled", "CANCELLED", {});
        }
      }
      exports.FetchCancelSignal = FetchCancelSignal;
      function checkSignal(signal) {
        if (signal == null) {
          throw new Error("missing signal; should not happen");
        }
        signal.checkSignal();
        return signal;
      }
      class FetchRequest {
        #allowInsecure;
        #gzip;
        #headers;
        #method;
        #timeout;
        #url;
        #body;
        #bodyType;
        #creds;
        #preflight;
        #process;
        #retry;
        #signal;
        #throttle;
        get url() {
          return this.#url;
        }
        set url(url) {
          this.#url = String(url);
        }
        get body() {
          if (this.#body == null) {
            return null;
          }
          return new Uint8Array(this.#body);
        }
        set body(body) {
          if (body == null) {
            this.#body = undefined;
            this.#bodyType = undefined;
          } else if (typeof body === "string") {
            this.#body = (0, utf8_js_1.toUtf8Bytes)(body);
            this.#bodyType = "text/plain";
          } else if (body instanceof Uint8Array) {
            this.#body = body;
            this.#bodyType = "application/octet-stream";
          } else if (typeof body === "object") {
            this.#body = (0, utf8_js_1.toUtf8Bytes)(JSON.stringify(body));
            this.#bodyType = "application/json";
          } else {
            throw new Error("invalid body");
          }
        }
        hasBody() {
          return this.#body != null;
        }
        get method() {
          if (this.#method) {
            return this.#method;
          }
          if (this.hasBody()) {
            return "POST";
          }
          return "GET";
        }
        set method(method) {
          if (method == null) {
            method = "";
          }
          this.#method = String(method).toUpperCase();
        }
        get headers() {
          const headers = Object.assign({}, this.#headers);
          if (this.#creds) {
            headers["authorization"] = `Basic ${(0, base64_js_1.encodeBase64)((0, utf8_js_1.toUtf8Bytes)(this.#creds))}`;
          }
          ;
          if (this.allowGzip) {
            headers["accept-encoding"] = "gzip";
          }
          if (headers["content-type"] == null && this.#bodyType) {
            headers["content-type"] = this.#bodyType;
          }
          if (this.body) {
            headers["content-length"] = String(this.body.length);
          }
          return headers;
        }
        getHeader(key) {
          return this.headers[key.toLowerCase()];
        }
        setHeader(key, value) {
          this.#headers[String(key).toLowerCase()] = String(value);
        }
        clearHeaders() {
          this.#headers = {};
        }
        [Symbol.iterator]() {
          const headers = this.headers;
          const keys = Object.keys(headers);
          let index = 0;
          return {
            next: () => {
              if (index < keys.length) {
                const key = keys[index++];
                return {
                  value: [key, headers[key]],
                  done: false
                };
              }
              return {
                value: undefined,
                done: true
              };
            }
          };
        }
        get credentials() {
          return this.#creds || null;
        }
        setCredentials(username, password) {
          (0, errors_js_1.assertArgument)(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
          this.#creds = `${username}:${password}`;
        }
        get allowGzip() {
          return this.#gzip;
        }
        set allowGzip(value) {
          this.#gzip = !!value;
        }
        get allowInsecureAuthentication() {
          return !!this.#allowInsecure;
        }
        set allowInsecureAuthentication(value) {
          this.#allowInsecure = !!value;
        }
        get timeout() {
          return this.#timeout;
        }
        set timeout(timeout) {
          (0, errors_js_1.assertArgument)(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
          this.#timeout = timeout;
        }
        get preflightFunc() {
          return this.#preflight || null;
        }
        set preflightFunc(preflight) {
          this.#preflight = preflight;
        }
        get processFunc() {
          return this.#process || null;
        }
        set processFunc(process) {
          this.#process = process;
        }
        get retryFunc() {
          return this.#retry || null;
        }
        set retryFunc(retry) {
          this.#retry = retry;
        }
        constructor(url) {
          this.#url = String(url);
          this.#allowInsecure = false;
          this.#gzip = true;
          this.#headers = {};
          this.#method = "";
          this.#timeout = 300000;
          this.#throttle = {
            slotInterval: SLOT_INTERVAL,
            maxAttempts: MAX_ATTEMPTS
          };
        }
        toString() {
          return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0, data_js_1.hexlify)(this.#body) : "null"}>`;
        }
        setThrottleParams(params) {
          if (params.slotInterval != null) {
            this.#throttle.slotInterval = params.slotInterval;
          }
          if (params.maxAttempts != null) {
            this.#throttle.maxAttempts = params.maxAttempts;
          }
        }
        async #send(attempt, expires, delay, _request, _response) {
          if (attempt >= this.#throttle.maxAttempts) {
            return _response.makeServerError("exceeded maximum retry limit");
          }
          (0, errors_js_1.assert)(getTime() <= expires, "timeout", "TIMEOUT", {
            operation: "request.send",
            reason: "timeout",
            request: _request
          });
          if (delay > 0) {
            await wait(delay);
          }
          let req = this.clone();
          const scheme = (req.url.split(":")[0] || "").toLowerCase();
          if (scheme in Gateways) {
            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
            if (result instanceof FetchResponse) {
              let response = result;
              if (this.processFunc) {
                checkSignal(_request.#signal);
                try {
                  response = await this.processFunc(req, response);
                } catch (error) {
                  if (error.throttle == null || typeof error.stall !== "number") {
                    response.makeServerError("error in post-processing function", error).assertOk();
                  }
                }
              }
              return response;
            }
            req = result;
          }
          if (this.preflightFunc) {
            req = await this.preflightFunc(req);
          }
          const resp = await getUrlFunc(req, checkSignal(_request.#signal));
          let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
          if (response.statusCode === 301 || response.statusCode === 302) {
            try {
              const location = response.headers.location || "";
              return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
            } catch (error) {}
            return response;
          } else if (response.statusCode === 429) {
            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {
              const retryAfter = response.headers["retry-after"];
              let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
              if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                delay = parseInt(retryAfter);
              }
              return req.clone().#send(attempt + 1, expires, delay, _request, response);
            }
          }
          if (this.processFunc) {
            checkSignal(_request.#signal);
            try {
              response = await this.processFunc(req, response);
            } catch (error) {
              if (error.throttle == null || typeof error.stall !== "number") {
                response.makeServerError("error in post-processing function", error).assertOk();
              }
              let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
              ;
              if (error.stall >= 0) {
                delay = error.stall;
              }
              return req.clone().#send(attempt + 1, expires, delay, _request, response);
            }
          }
          return response;
        }
        send() {
          (0, errors_js_1.assert)(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.send"
          });
          this.#signal = new FetchCancelSignal(this);
          return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
        }
        cancel() {
          (0, errors_js_1.assert)(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.cancel"
          });
          const signal = fetchSignals.get(this);
          if (!signal) {
            throw new Error("missing signal; should not happen");
          }
          signal();
        }
        redirect(location) {
          const current = this.url.split(":")[0].toLowerCase();
          const target = location.split(":")[0].toLowerCase();
          (0, errors_js_1.assert)(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
          });
          const req = new FetchRequest(location);
          req.method = "GET";
          req.allowGzip = this.allowGzip;
          req.timeout = this.timeout;
          req.#headers = Object.assign({}, this.#headers);
          if (this.#body) {
            req.#body = new Uint8Array(this.#body);
          }
          req.#bodyType = this.#bodyType;
          return req;
        }
        clone() {
          const clone = new FetchRequest(this.url);
          clone.#method = this.#method;
          if (this.#body) {
            clone.#body = this.#body;
          }
          clone.#bodyType = this.#bodyType;
          clone.#headers = Object.assign({}, this.#headers);
          clone.#creds = this.#creds;
          if (this.allowGzip) {
            clone.allowGzip = true;
          }
          clone.timeout = this.timeout;
          if (this.allowInsecureAuthentication) {
            clone.allowInsecureAuthentication = true;
          }
          clone.#preflight = this.#preflight;
          clone.#process = this.#process;
          clone.#retry = this.#retry;
          return clone;
        }
        static lockConfig() {
          locked = true;
        }
        static getGateway(scheme) {
          return Gateways[scheme.toLowerCase()] || null;
        }
        static registerGateway(scheme, func) {
          scheme = scheme.toLowerCase();
          if (scheme === "http" || scheme === "https") {
            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
          }
          if (locked) {
            throw new Error("gateways locked");
          }
          Gateways[scheme] = func;
        }
        static registerGetUrl(getUrl) {
          if (locked) {
            throw new Error("gateways locked");
          }
          getUrlFunc = getUrl;
        }
        static createDataGateway() {
          return dataGatewayFunc;
        }
        static createIpfsGatewayFunc(baseUrl) {
          return getIpfsGatewayFunc(baseUrl);
        }
      }
      exports.FetchRequest = FetchRequest;
      ;
      class FetchResponse {
        #statusCode;
        #statusMessage;
        #headers;
        #body;
        #request;
        #error;
        toString() {
          return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0, data_js_1.hexlify)(this.#body) : "null"}>`;
        }
        get statusCode() {
          return this.#statusCode;
        }
        get statusMessage() {
          return this.#statusMessage;
        }
        get headers() {
          return Object.assign({}, this.#headers);
        }
        get body() {
          return this.#body == null ? null : new Uint8Array(this.#body);
        }
        get bodyText() {
          try {
            return this.#body == null ? "" : (0, utf8_js_1.toUtf8String)(this.#body);
          } catch (error) {
            (0, errors_js_1.assert)(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
              operation: "bodyText",
              info: {
                response: this
              }
            });
          }
        }
        get bodyJson() {
          try {
            return JSON.parse(this.bodyText);
          } catch (error) {
            (0, errors_js_1.assert)(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
              operation: "bodyJson",
              info: {
                response: this
              }
            });
          }
        }
        [Symbol.iterator]() {
          const headers = this.headers;
          const keys = Object.keys(headers);
          let index = 0;
          return {
            next: () => {
              if (index < keys.length) {
                const key = keys[index++];
                return {
                  value: [key, headers[key]],
                  done: false
                };
              }
              return {
                value: undefined,
                done: true
              };
            }
          };
        }
        constructor(statusCode, statusMessage, headers, body, request) {
          this.#statusCode = statusCode;
          this.#statusMessage = statusMessage;
          this.#headers = Object.keys(headers).reduce((accum, k) => {
            accum[k.toLowerCase()] = String(headers[k]);
            return accum;
          }, {});
          this.#body = body == null ? null : new Uint8Array(body);
          this.#request = request || null;
          this.#error = {
            message: ""
          };
        }
        makeServerError(message, error) {
          let statusMessage;
          if (!message) {
            message = `${this.statusCode} ${this.statusMessage}`;
            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
          } else {
            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
          }
          const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);
          response.#error = {
            message,
            error
          };
          return response;
        }
        throwThrottleError(message, stall) {
          if (stall == null) {
            stall = -1;
          } else {
            (0, errors_js_1.assertArgument)(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
          }
          const error = new Error(message || "throttling requests");
          (0, properties_js_1.defineProperties)(error, {
            stall,
            throttle: true
          });
          throw error;
        }
        getHeader(key) {
          return this.headers[key.toLowerCase()];
        }
        hasBody() {
          return this.#body != null;
        }
        get request() {
          return this.#request;
        }
        ok() {
          return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
        }
        assertOk() {
          if (this.ok()) {
            return;
          }
          let {
            message,
            error
          } = this.#error;
          if (message === "") {
            message = `server response ${this.statusCode} ${this.statusMessage}`;
          }
          (0, errors_js_1.assert)(false, message, "SERVER_ERROR", {
            request: this.request || "unknown request",
            response: this,
            error
          });
        }
      }
      exports.FetchResponse = FetchResponse;
      function getTime() {
        return new Date().getTime();
      }
      function unpercent(value) {
        return (0, utf8_js_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
          return String.fromCharCode(parseInt(code, 16));
        }));
      }
      function wait(delay) {
        return new Promise(resolve => setTimeout(resolve, delay));
      }
    },
    8359: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FixedNumber = void 0;
      const data_js_1 = __webpack_require__(7924);
      const errors_js_1 = __webpack_require__(7505);
      const maths_js_1 = __webpack_require__(9018);
      const properties_js_1 = __webpack_require__(9795);
      const BN_N1 = BigInt(-1);
      const BN_0 = BigInt(0);
      const BN_1 = BigInt(1);
      const BN_5 = BigInt(5);
      const _guard = {};
      let Zeros = "0000";
      while (Zeros.length < 80) {
        Zeros += Zeros;
      }
      function getTens(decimals) {
        let result = Zeros;
        while (result.length < decimals) {
          result += result;
        }
        return BigInt("1" + result.substring(0, decimals));
      }
      function checkValue(val, format, safeOp) {
        const width = BigInt(format.width);
        if (format.signed) {
          const limit = BN_1 << width - BN_1;
          (0, errors_js_1.assert)(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
            operation: safeOp,
            fault: "overflow",
            value: val
          });
          if (val > BN_0) {
            val = (0, maths_js_1.fromTwos)((0, maths_js_1.mask)(val, width), width);
          } else {
            val = -(0, maths_js_1.fromTwos)((0, maths_js_1.mask)(-val, width), width);
          }
        } else {
          const limit = BN_1 << width;
          (0, errors_js_1.assert)(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
            operation: safeOp,
            fault: "overflow",
            value: val
          });
          val = (val % limit + limit) % limit & limit - BN_1;
        }
        return val;
      }
      function getFormat(value) {
        if (typeof value === "number") {
          value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof value === "string") {
          if (value === "fixed") {} else if (value === "ufixed") {
            signed = false;
          } else {
            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            (0, errors_js_1.assertArgument)(match, "invalid fixed format", "format", value);
            signed = match[1] !== "u";
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
          }
        } else if (value) {
          const v = value;
          const check = (key, type, defaultValue) => {
            if (v[key] == null) {
              return defaultValue;
            }
            (0, errors_js_1.assertArgument)(typeof v[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
            return v[key];
          };
          signed = check("signed", "boolean", signed);
          width = check("width", "number", width);
          decimals = check("decimals", "number", decimals);
        }
        (0, errors_js_1.assertArgument)(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
        (0, errors_js_1.assertArgument)(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
        const name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        return {
          signed,
          width,
          decimals,
          name
        };
      }
      function toString(val, decimals) {
        let negative = "";
        if (val < BN_0) {
          negative = "-";
          val *= BN_N1;
        }
        let str = val.toString();
        if (decimals === 0) {
          return negative + str;
        }
        while (str.length <= decimals) {
          str = Zeros + str;
        }
        const index = str.length - decimals;
        str = str.substring(0, index) + "." + str.substring(index);
        while (str[0] === "0" && str[1] !== ".") {
          str = str.substring(1);
        }
        while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
          str = str.substring(0, str.length - 1);
        }
        return negative + str;
      }
      class FixedNumber {
        format;
        #format;
        #val;
        #tens;
        _value;
        constructor(guard, value, format) {
          (0, errors_js_1.assertPrivate)(guard, _guard, "FixedNumber");
          this.#val = value;
          this.#format = format;
          const _value = toString(value, format.decimals);
          (0, properties_js_1.defineProperties)(this, {
            format: format.name,
            _value
          });
          this.#tens = getTens(format.decimals);
        }
        get signed() {
          return this.#format.signed;
        }
        get width() {
          return this.#format.width;
        }
        get decimals() {
          return this.#format.decimals;
        }
        get value() {
          return this.#val;
        }
        #checkFormat(other) {
          (0, errors_js_1.assertArgument)(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
        }
        #checkValue(val, safeOp) {
          val = checkValue(val, this.#format, safeOp);
          return new FixedNumber(_guard, val, this.#format);
        }
        #add(o, safeOp) {
          this.#checkFormat(o);
          return this.#checkValue(this.#val + o.#val, safeOp);
        }
        addUnsafe(other) {
          return this.#add(other);
        }
        add(other) {
          return this.#add(other, "add");
        }
        #sub(o, safeOp) {
          this.#checkFormat(o);
          return this.#checkValue(this.#val - o.#val, safeOp);
        }
        subUnsafe(other) {
          return this.#sub(other);
        }
        sub(other) {
          return this.#sub(other, "sub");
        }
        #mul(o, safeOp) {
          this.#checkFormat(o);
          return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);
        }
        mulUnsafe(other) {
          return this.#mul(other);
        }
        mul(other) {
          return this.#mul(other, "mul");
        }
        mulSignal(other) {
          this.#checkFormat(other);
          const value = this.#val * other.#val;
          (0, errors_js_1.assert)(value % this.#tens === BN_0, "precision lost during signalling mul", "NUMERIC_FAULT", {
            operation: "mulSignal",
            fault: "underflow",
            value: this
          });
          return this.#checkValue(value / this.#tens, "mulSignal");
        }
        #div(o, safeOp) {
          (0, errors_js_1.assert)(o.#val !== BN_0, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
          });
          this.#checkFormat(o);
          return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);
        }
        divUnsafe(other) {
          return this.#div(other);
        }
        div(other) {
          return this.#div(other, "div");
        }
        divSignal(other) {
          (0, errors_js_1.assert)(other.#val !== BN_0, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
          });
          this.#checkFormat(other);
          const value = this.#val * this.#tens;
          (0, errors_js_1.assert)(value % other.#val === BN_0, "precision lost during signalling div", "NUMERIC_FAULT", {
            operation: "divSignal",
            fault: "underflow",
            value: this
          });
          return this.#checkValue(value / other.#val, "divSignal");
        }
        cmp(other) {
          let a = this.value,
            b = other.value;
          const delta = this.decimals - other.decimals;
          if (delta > 0) {
            b *= getTens(delta);
          } else if (delta < 0) {
            a *= getTens(-delta);
          }
          if (a < b) {
            return -1;
          }
          if (a > b) {
            return 1;
          }
          return 0;
        }
        eq(other) {
          return this.cmp(other) === 0;
        }
        lt(other) {
          return this.cmp(other) < 0;
        }
        lte(other) {
          return this.cmp(other) <= 0;
        }
        gt(other) {
          return this.cmp(other) > 0;
        }
        gte(other) {
          return this.cmp(other) >= 0;
        }
        floor() {
          let val = this.#val;
          if (this.#val < BN_0) {
            val -= this.#tens - BN_1;
          }
          val = this.#val / this.#tens * this.#tens;
          return this.#checkValue(val, "floor");
        }
        ceiling() {
          let val = this.#val;
          if (this.#val > BN_0) {
            val += this.#tens - BN_1;
          }
          val = this.#val / this.#tens * this.#tens;
          return this.#checkValue(val, "ceiling");
        }
        round(decimals) {
          if (decimals == null) {
            decimals = 0;
          }
          if (decimals >= this.decimals) {
            return this;
          }
          const delta = this.decimals - decimals;
          const bump = BN_5 * getTens(delta - 1);
          let value = this.value + bump;
          const tens = getTens(delta);
          value = value / tens * tens;
          checkValue(value, this.#format, "round");
          return new FixedNumber(_guard, value, this.#format);
        }
        isZero() {
          return this.#val === BN_0;
        }
        isNegative() {
          return this.#val < BN_0;
        }
        toString() {
          return this._value;
        }
        toUnsafeFloat() {
          return parseFloat(this.toString());
        }
        toFormat(format) {
          return FixedNumber.fromString(this.toString(), format);
        }
        static fromValue(_value, _decimals, _format) {
          const decimals = _decimals == null ? 0 : (0, maths_js_1.getNumber)(_decimals);
          const format = getFormat(_format);
          let value = (0, maths_js_1.getBigInt)(_value, "value");
          const delta = decimals - format.decimals;
          if (delta > 0) {
            const tens = getTens(delta);
            (0, errors_js_1.assert)(value % tens === BN_0, "value loses precision for format", "NUMERIC_FAULT", {
              operation: "fromValue",
              fault: "underflow",
              value: _value
            });
            value /= tens;
          } else if (delta < 0) {
            value *= getTens(-delta);
          }
          checkValue(value, format, "fromValue");
          return new FixedNumber(_guard, value, format);
        }
        static fromString(_value, _format) {
          const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
          (0, errors_js_1.assertArgument)(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
          const format = getFormat(_format);
          let whole = match[2] || "0",
            decimal = match[3] || "";
          while (decimal.length < format.decimals) {
            decimal += Zeros;
          }
          (0, errors_js_1.assert)(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
            operation: "fromString",
            fault: "underflow",
            value: _value
          });
          decimal = decimal.substring(0, format.decimals);
          const value = BigInt(match[1] + whole + decimal);
          checkValue(value, format, "fromString");
          return new FixedNumber(_guard, value, format);
        }
        static fromBytes(_value, _format) {
          let value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value, "value"));
          const format = getFormat(_format);
          if (format.signed) {
            value = (0, maths_js_1.fromTwos)(value, format.width);
          }
          checkValue(value, format, "fromBytes");
          return new FixedNumber(_guard, value, format);
        }
      }
      exports.FixedNumber = FixedNumber;
    },
    5296: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getUrl = void 0;
      const errors_js_1 = __webpack_require__(7505);
      async function getUrl(req, _signal) {
        const protocol = req.url.split(":")[0].toLowerCase();
        (0, errors_js_1.assert)(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
          info: {
            protocol
          },
          operation: "request"
        });
        (0, errors_js_1.assert)(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
          operation: "request"
        });
        let signal = undefined;
        if (_signal) {
          const controller = new AbortController();
          signal = controller.signal;
          _signal.addListener(() => {
            controller.abort();
          });
        }
        const init = {
          method: req.method,
          headers: new Headers(Array.from(req)),
          body: req.body || undefined,
          signal
        };
        const resp = await fetch(req.url, init);
        const headers = {};
        resp.headers.forEach((value, key) => {
          headers[key.toLowerCase()] = value;
        });
        const respBody = await resp.arrayBuffer();
        const body = respBody == null ? null : new Uint8Array(respBody);
        return {
          statusCode: resp.status,
          statusMessage: resp.statusText,
          headers,
          body
        };
      }
      exports.getUrl = getUrl;
    },
    9830: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.encodeRlp = exports.decodeRlp = exports.defineProperties = exports.resolveProperties = exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.toBigInt = exports.getUint = exports.getNumber = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.makeError = exports.assertNormalize = exports.assertPrivate = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.isError = exports.isCallException = exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = void 0;
      exports.uuidV4 = exports.Utf8ErrorFuncs = void 0;
      var base58_js_1 = __webpack_require__(5637);
      Object.defineProperty(exports, "decodeBase58", {
        enumerable: true,
        get: function () {
          return base58_js_1.decodeBase58;
        }
      });
      Object.defineProperty(exports, "encodeBase58", {
        enumerable: true,
        get: function () {
          return base58_js_1.encodeBase58;
        }
      });
      var base64_js_1 = __webpack_require__(7993);
      Object.defineProperty(exports, "decodeBase64", {
        enumerable: true,
        get: function () {
          return base64_js_1.decodeBase64;
        }
      });
      Object.defineProperty(exports, "encodeBase64", {
        enumerable: true,
        get: function () {
          return base64_js_1.encodeBase64;
        }
      });
      var data_js_1 = __webpack_require__(7924);
      Object.defineProperty(exports, "getBytes", {
        enumerable: true,
        get: function () {
          return data_js_1.getBytes;
        }
      });
      Object.defineProperty(exports, "getBytesCopy", {
        enumerable: true,
        get: function () {
          return data_js_1.getBytesCopy;
        }
      });
      Object.defineProperty(exports, "isHexString", {
        enumerable: true,
        get: function () {
          return data_js_1.isHexString;
        }
      });
      Object.defineProperty(exports, "isBytesLike", {
        enumerable: true,
        get: function () {
          return data_js_1.isBytesLike;
        }
      });
      Object.defineProperty(exports, "hexlify", {
        enumerable: true,
        get: function () {
          return data_js_1.hexlify;
        }
      });
      Object.defineProperty(exports, "concat", {
        enumerable: true,
        get: function () {
          return data_js_1.concat;
        }
      });
      Object.defineProperty(exports, "dataLength", {
        enumerable: true,
        get: function () {
          return data_js_1.dataLength;
        }
      });
      Object.defineProperty(exports, "dataSlice", {
        enumerable: true,
        get: function () {
          return data_js_1.dataSlice;
        }
      });
      Object.defineProperty(exports, "stripZerosLeft", {
        enumerable: true,
        get: function () {
          return data_js_1.stripZerosLeft;
        }
      });
      Object.defineProperty(exports, "zeroPadValue", {
        enumerable: true,
        get: function () {
          return data_js_1.zeroPadValue;
        }
      });
      Object.defineProperty(exports, "zeroPadBytes", {
        enumerable: true,
        get: function () {
          return data_js_1.zeroPadBytes;
        }
      });
      var errors_js_1 = __webpack_require__(7505);
      Object.defineProperty(exports, "isCallException", {
        enumerable: true,
        get: function () {
          return errors_js_1.isCallException;
        }
      });
      Object.defineProperty(exports, "isError", {
        enumerable: true,
        get: function () {
          return errors_js_1.isError;
        }
      });
      Object.defineProperty(exports, "assert", {
        enumerable: true,
        get: function () {
          return errors_js_1.assert;
        }
      });
      Object.defineProperty(exports, "assertArgument", {
        enumerable: true,
        get: function () {
          return errors_js_1.assertArgument;
        }
      });
      Object.defineProperty(exports, "assertArgumentCount", {
        enumerable: true,
        get: function () {
          return errors_js_1.assertArgumentCount;
        }
      });
      Object.defineProperty(exports, "assertPrivate", {
        enumerable: true,
        get: function () {
          return errors_js_1.assertPrivate;
        }
      });
      Object.defineProperty(exports, "assertNormalize", {
        enumerable: true,
        get: function () {
          return errors_js_1.assertNormalize;
        }
      });
      Object.defineProperty(exports, "makeError", {
        enumerable: true,
        get: function () {
          return errors_js_1.makeError;
        }
      });
      var events_js_1 = __webpack_require__(7961);
      Object.defineProperty(exports, "EventPayload", {
        enumerable: true,
        get: function () {
          return events_js_1.EventPayload;
        }
      });
      var fetch_js_1 = __webpack_require__(7121);
      Object.defineProperty(exports, "FetchRequest", {
        enumerable: true,
        get: function () {
          return fetch_js_1.FetchRequest;
        }
      });
      Object.defineProperty(exports, "FetchResponse", {
        enumerable: true,
        get: function () {
          return fetch_js_1.FetchResponse;
        }
      });
      Object.defineProperty(exports, "FetchCancelSignal", {
        enumerable: true,
        get: function () {
          return fetch_js_1.FetchCancelSignal;
        }
      });
      var fixednumber_js_1 = __webpack_require__(8359);
      Object.defineProperty(exports, "FixedNumber", {
        enumerable: true,
        get: function () {
          return fixednumber_js_1.FixedNumber;
        }
      });
      var maths_js_1 = __webpack_require__(9018);
      Object.defineProperty(exports, "fromTwos", {
        enumerable: true,
        get: function () {
          return maths_js_1.fromTwos;
        }
      });
      Object.defineProperty(exports, "toTwos", {
        enumerable: true,
        get: function () {
          return maths_js_1.toTwos;
        }
      });
      Object.defineProperty(exports, "mask", {
        enumerable: true,
        get: function () {
          return maths_js_1.mask;
        }
      });
      Object.defineProperty(exports, "getBigInt", {
        enumerable: true,
        get: function () {
          return maths_js_1.getBigInt;
        }
      });
      Object.defineProperty(exports, "getNumber", {
        enumerable: true,
        get: function () {
          return maths_js_1.getNumber;
        }
      });
      Object.defineProperty(exports, "getUint", {
        enumerable: true,
        get: function () {
          return maths_js_1.getUint;
        }
      });
      Object.defineProperty(exports, "toBigInt", {
        enumerable: true,
        get: function () {
          return maths_js_1.toBigInt;
        }
      });
      Object.defineProperty(exports, "toNumber", {
        enumerable: true,
        get: function () {
          return maths_js_1.toNumber;
        }
      });
      Object.defineProperty(exports, "toBeHex", {
        enumerable: true,
        get: function () {
          return maths_js_1.toBeHex;
        }
      });
      Object.defineProperty(exports, "toBeArray", {
        enumerable: true,
        get: function () {
          return maths_js_1.toBeArray;
        }
      });
      Object.defineProperty(exports, "toQuantity", {
        enumerable: true,
        get: function () {
          return maths_js_1.toQuantity;
        }
      });
      var properties_js_1 = __webpack_require__(9795);
      Object.defineProperty(exports, "resolveProperties", {
        enumerable: true,
        get: function () {
          return properties_js_1.resolveProperties;
        }
      });
      Object.defineProperty(exports, "defineProperties", {
        enumerable: true,
        get: function () {
          return properties_js_1.defineProperties;
        }
      });
      var rlp_decode_js_1 = __webpack_require__(3207);
      Object.defineProperty(exports, "decodeRlp", {
        enumerable: true,
        get: function () {
          return rlp_decode_js_1.decodeRlp;
        }
      });
      var rlp_encode_js_1 = __webpack_require__(7497);
      Object.defineProperty(exports, "encodeRlp", {
        enumerable: true,
        get: function () {
          return rlp_encode_js_1.encodeRlp;
        }
      });
      var units_js_1 = __webpack_require__(869);
      Object.defineProperty(exports, "formatEther", {
        enumerable: true,
        get: function () {
          return units_js_1.formatEther;
        }
      });
      Object.defineProperty(exports, "parseEther", {
        enumerable: true,
        get: function () {
          return units_js_1.parseEther;
        }
      });
      Object.defineProperty(exports, "formatUnits", {
        enumerable: true,
        get: function () {
          return units_js_1.formatUnits;
        }
      });
      Object.defineProperty(exports, "parseUnits", {
        enumerable: true,
        get: function () {
          return units_js_1.parseUnits;
        }
      });
      var utf8_js_1 = __webpack_require__(8002);
      Object.defineProperty(exports, "toUtf8Bytes", {
        enumerable: true,
        get: function () {
          return utf8_js_1.toUtf8Bytes;
        }
      });
      Object.defineProperty(exports, "toUtf8CodePoints", {
        enumerable: true,
        get: function () {
          return utf8_js_1.toUtf8CodePoints;
        }
      });
      Object.defineProperty(exports, "toUtf8String", {
        enumerable: true,
        get: function () {
          return utf8_js_1.toUtf8String;
        }
      });
      Object.defineProperty(exports, "Utf8ErrorFuncs", {
        enumerable: true,
        get: function () {
          return utf8_js_1.Utf8ErrorFuncs;
        }
      });
      var uuid_js_1 = __webpack_require__(9574);
      Object.defineProperty(exports, "uuidV4", {
        enumerable: true,
        get: function () {
          return uuid_js_1.uuidV4;
        }
      });
    },
    9018: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.getNumber = exports.toBigInt = exports.getUint = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = void 0;
      const data_js_1 = __webpack_require__(7924);
      const errors_js_1 = __webpack_require__(7505);
      const BN_0 = BigInt(0);
      const BN_1 = BigInt(1);
      const maxValue = 0x1fffffffffffff;
      function fromTwos(_value, _width) {
        const value = getUint(_value, "value");
        const width = BigInt(getNumber(_width, "width"));
        (0, errors_js_1.assert)(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
          operation: "fromTwos",
          fault: "overflow",
          value: _value
        });
        if (value >> width - BN_1) {
          const mask = (BN_1 << width) - BN_1;
          return -((~value & mask) + BN_1);
        }
        return value;
      }
      exports.fromTwos = fromTwos;
      function toTwos(_value, _width) {
        let value = getBigInt(_value, "value");
        const width = BigInt(getNumber(_width, "width"));
        const limit = BN_1 << width - BN_1;
        if (value < BN_0) {
          value = -value;
          (0, errors_js_1.assert)(value <= limit, "too low", "NUMERIC_FAULT", {
            operation: "toTwos",
            fault: "overflow",
            value: _value
          });
          const mask = (BN_1 << width) - BN_1;
          return (~value & mask) + BN_1;
        } else {
          (0, errors_js_1.assert)(value < limit, "too high", "NUMERIC_FAULT", {
            operation: "toTwos",
            fault: "overflow",
            value: _value
          });
        }
        return value;
      }
      exports.toTwos = toTwos;
      function mask(_value, _bits) {
        const value = getUint(_value, "value");
        const bits = BigInt(getNumber(_bits, "bits"));
        return value & (BN_1 << bits) - BN_1;
      }
      exports.mask = mask;
      function getBigInt(value, name) {
        switch (typeof value) {
          case "bigint":
            return value;
          case "number":
            (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return BigInt(value);
          case "string":
            try {
              if (value === "") {
                throw new Error("empty string");
              }
              if (value[0] === "-" && value[1] !== "-") {
                return -BigInt(value.substring(1));
              }
              return BigInt(value);
            } catch (e) {
              (0, errors_js_1.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
            }
        }
        (0, errors_js_1.assertArgument)(false, "invalid BigNumberish value", name || "value", value);
      }
      exports.getBigInt = getBigInt;
      function getUint(value, name) {
        const result = getBigInt(value, name);
        (0, errors_js_1.assert)(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
          fault: "overflow",
          operation: "getUint",
          value
        });
        return result;
      }
      exports.getUint = getUint;
      const Nibbles = "0123456789abcdef";
      function toBigInt(value) {
        if (value instanceof Uint8Array) {
          let result = "0x0";
          for (const v of value) {
            result += Nibbles[v >> 4];
            result += Nibbles[v & 0x0f];
          }
          return BigInt(result);
        }
        return getBigInt(value);
      }
      exports.toBigInt = toBigInt;
      function getNumber(value, name) {
        switch (typeof value) {
          case "bigint":
            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return Number(value);
          case "number":
            (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
            return value;
          case "string":
            try {
              if (value === "") {
                throw new Error("empty string");
              }
              return getNumber(BigInt(value), name);
            } catch (e) {
              (0, errors_js_1.assertArgument)(false, `invalid numeric string: ${e.message}`, name || "value", value);
            }
        }
        (0, errors_js_1.assertArgument)(false, "invalid numeric value", name || "value", value);
      }
      exports.getNumber = getNumber;
      function toNumber(value) {
        return getNumber(toBigInt(value));
      }
      exports.toNumber = toNumber;
      function toBeHex(_value, _width) {
        const value = getUint(_value, "value");
        let result = value.toString(16);
        if (_width == null) {
          if (result.length % 2) {
            result = "0" + result;
          }
        } else {
          const width = getNumber(_width, "width");
          (0, errors_js_1.assert)(width * 2 >= result.length, `value exceeds width (${width} bits)`, "NUMERIC_FAULT", {
            operation: "toBeHex",
            fault: "overflow",
            value: _value
          });
          while (result.length < width * 2) {
            result = "0" + result;
          }
        }
        return "0x" + result;
      }
      exports.toBeHex = toBeHex;
      function toBeArray(_value) {
        const value = getUint(_value, "value");
        if (value === BN_0) {
          return new Uint8Array([]);
        }
        let hex = value.toString(16);
        if (hex.length % 2) {
          hex = "0" + hex;
        }
        const result = new Uint8Array(hex.length / 2);
        for (let i = 0; i < result.length; i++) {
          const offset = i * 2;
          result[i] = parseInt(hex.substring(offset, offset + 2), 16);
        }
        return result;
      }
      exports.toBeArray = toBeArray;
      function toQuantity(value) {
        let result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);
        while (result.startsWith("0")) {
          result = result.substring(1);
        }
        if (result === "") {
          result = "0";
        }
        return "0x" + result;
      }
      exports.toQuantity = toQuantity;
    },
    9795: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defineProperties = exports.resolveProperties = void 0;
      function checkType(value, type, name) {
        const types = type.split("|").map(t => t.trim());
        for (let i = 0; i < types.length; i++) {
          switch (type) {
            case "any":
              return;
            case "bigint":
            case "boolean":
            case "number":
            case "string":
              if (typeof value === type) {
                return;
              }
          }
        }
        const error = new Error(`invalid value for type ${type}`);
        error.code = "INVALID_ARGUMENT";
        error.argument = `value.${name}`;
        error.value = value;
        throw error;
      }
      async function resolveProperties(value) {
        const keys = Object.keys(value);
        const results = await Promise.all(keys.map(k => Promise.resolve(value[k])));
        return results.reduce((accum, v, index) => {
          accum[keys[index]] = v;
          return accum;
        }, {});
      }
      exports.resolveProperties = resolveProperties;
      function defineProperties(target, values, types) {
        for (let key in values) {
          let value = values[key];
          const type = types ? types[key] : null;
          if (type) {
            checkType(value, type, key);
          }
          Object.defineProperty(target, key, {
            enumerable: true,
            value,
            writable: false
          });
        }
      }
      exports.defineProperties = defineProperties;
    },
    3207: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decodeRlp = void 0;
      const data_js_1 = __webpack_require__(7924);
      const errors_js_1 = __webpack_require__(7505);
      const data_js_2 = __webpack_require__(7924);
      function hexlifyByte(value) {
        let result = value.toString(16);
        while (result.length < 2) {
          result = "0" + result;
        }
        return "0x" + result;
      }
      function unarrayifyInteger(data, offset, length) {
        let result = 0;
        for (let i = 0; i < length; i++) {
          result = result * 256 + data[offset + i];
        }
        return result;
      }
      function _decodeChildren(data, offset, childOffset, length) {
        const result = [];
        while (childOffset < offset + 1 + length) {
          const decoded = _decode(data, childOffset);
          result.push(decoded.result);
          childOffset += decoded.consumed;
          (0, errors_js_1.assert)(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
            buffer: data,
            length,
            offset
          });
        }
        return {
          consumed: 1 + length,
          result: result
        };
      }
      function _decode(data, offset) {
        (0, errors_js_1.assert)(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
          buffer: data,
          length: 0,
          offset: 1
        });
        const checkOffset = offset => {
          (0, errors_js_1.assert)(offset <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
            buffer: data,
            length: data.length,
            offset
          });
        };
        if (data[offset] >= 0xf8) {
          const lengthLength = data[offset] - 0xf7;
          checkOffset(offset + 1 + lengthLength);
          const length = unarrayifyInteger(data, offset + 1, lengthLength);
          checkOffset(offset + 1 + lengthLength + length);
          return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
        } else if (data[offset] >= 0xc0) {
          const length = data[offset] - 0xc0;
          checkOffset(offset + 1 + length);
          return _decodeChildren(data, offset, offset + 1, length);
        } else if (data[offset] >= 0xb8) {
          const lengthLength = data[offset] - 0xb7;
          checkOffset(offset + 1 + lengthLength);
          const length = unarrayifyInteger(data, offset + 1, lengthLength);
          checkOffset(offset + 1 + lengthLength + length);
          const result = (0, data_js_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
          return {
            consumed: 1 + lengthLength + length,
            result: result
          };
        } else if (data[offset] >= 0x80) {
          const length = data[offset] - 0x80;
          checkOffset(offset + 1 + length);
          const result = (0, data_js_1.hexlify)(data.slice(offset + 1, offset + 1 + length));
          return {
            consumed: 1 + length,
            result: result
          };
        }
        return {
          consumed: 1,
          result: hexlifyByte(data[offset])
        };
      }
      function decodeRlp(_data) {
        const data = (0, data_js_2.getBytes)(_data, "data");
        const decoded = _decode(data, 0);
        (0, errors_js_1.assertArgument)(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
        return decoded.result;
      }
      exports.decodeRlp = decodeRlp;
    },
    7497: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.encodeRlp = void 0;
      const data_js_1 = __webpack_require__(7924);
      function arrayifyInteger(value) {
        const result = [];
        while (value) {
          result.unshift(value & 0xff);
          value >>= 8;
        }
        return result;
      }
      function _encode(object) {
        if (Array.isArray(object)) {
          let payload = [];
          object.forEach(function (child) {
            payload = payload.concat(_encode(child));
          });
          if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
          }
          const length = arrayifyInteger(payload.length);
          length.unshift(0xf7 + length.length);
          return length.concat(payload);
        }
        const data = Array.prototype.slice.call((0, data_js_1.getBytes)(object, "object"));
        if (data.length === 1 && data[0] <= 0x7f) {
          return data;
        } else if (data.length <= 55) {
          data.unshift(0x80 + data.length);
          return data;
        }
        const length = arrayifyInteger(data.length);
        length.unshift(0xb7 + length.length);
        return length.concat(data);
      }
      const nibbles = "0123456789abcdef";
      function encodeRlp(object) {
        let result = "0x";
        for (const v of _encode(object)) {
          result += nibbles[v >> 4];
          result += nibbles[v & 0xf];
        }
        return result;
      }
      exports.encodeRlp = encodeRlp;
    },
    869: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = void 0;
      const errors_js_1 = __webpack_require__(7505);
      const fixednumber_js_1 = __webpack_require__(8359);
      const maths_js_1 = __webpack_require__(9018);
      const names = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
      function formatUnits(value, unit) {
        let decimals = 18;
        if (typeof unit === "string") {
          const index = names.indexOf(unit);
          (0, errors_js_1.assertArgument)(index >= 0, "invalid unit", "unit", unit);
          decimals = 3 * index;
        } else if (unit != null) {
          decimals = (0, maths_js_1.getNumber)(unit, "unit");
        }
        return fixednumber_js_1.FixedNumber.fromValue(value, decimals, {
          decimals,
          width: 512
        }).toString();
      }
      exports.formatUnits = formatUnits;
      function parseUnits(value, unit) {
        (0, errors_js_1.assertArgument)(typeof value === "string", "value must be a string", "value", value);
        let decimals = 18;
        if (typeof unit === "string") {
          const index = names.indexOf(unit);
          (0, errors_js_1.assertArgument)(index >= 0, "invalid unit", "unit", unit);
          decimals = 3 * index;
        } else if (unit != null) {
          decimals = (0, maths_js_1.getNumber)(unit, "unit");
        }
        return fixednumber_js_1.FixedNumber.fromString(value, {
          decimals,
          width: 512
        }).value;
      }
      exports.parseUnits = parseUnits;
      function formatEther(wei) {
        return formatUnits(wei, 18);
      }
      exports.formatEther = formatEther;
      function parseEther(ether) {
        return parseUnits(ether, 18);
      }
      exports.parseEther = parseEther;
    },
    8002: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toUtf8CodePoints = exports.toUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = void 0;
      const data_js_1 = __webpack_require__(7924);
      const errors_js_1 = __webpack_require__(7505);
      function errorFunc(reason, offset, bytes, output, badCodepoint) {
        (0, errors_js_1.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
      }
      function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
        if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
          let i = 0;
          for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
              break;
            }
            i++;
          }
          return i;
        }
        if (reason === "OVERRUN") {
          return bytes.length - offset - 1;
        }
        return 0;
      }
      function replaceFunc(reason, offset, bytes, output, badCodepoint) {
        if (reason === "OVERLONG") {
          (0, errors_js_1.assertArgument)(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
          output.push(badCodepoint);
          return 0;
        }
        output.push(0xfffd);
        return ignoreFunc(reason, offset, bytes, output, badCodepoint);
      }
      exports.Utf8ErrorFuncs = Object.freeze({
        error: errorFunc,
        ignore: ignoreFunc,
        replace: replaceFunc
      });
      function getUtf8CodePoints(_bytes, onError) {
        if (onError == null) {
          onError = exports.Utf8ErrorFuncs.error;
        }
        const bytes = (0, data_js_1.getBytes)(_bytes, "bytes");
        const result = [];
        let i = 0;
        while (i < bytes.length) {
          const c = bytes[i++];
          if (c >> 7 === 0) {
            result.push(c);
            continue;
          }
          let extraLength = null;
          let overlongMask = null;
          if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
          } else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
          } else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
          } else {
            if ((c & 0xc0) === 0x80) {
              i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
            } else {
              i += onError("BAD_PREFIX", i - 1, bytes, result);
            }
            continue;
          }
          if (i - 1 + extraLength >= bytes.length) {
            i += onError("OVERRUN", i - 1, bytes, result);
            continue;
          }
          let res = c & (1 << 8 - extraLength - 1) - 1;
          for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            if ((nextChar & 0xc0) != 0x80) {
              i += onError("MISSING_CONTINUE", i, bytes, result);
              res = null;
              break;
            }
            ;
            res = res << 6 | nextChar & 0x3f;
            i++;
          }
          if (res === null) {
            continue;
          }
          if (res > 0x10ffff) {
            i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
            continue;
          }
          if (res >= 0xd800 && res <= 0xdfff) {
            i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
            continue;
          }
          if (res <= overlongMask) {
            i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
            continue;
          }
          result.push(res);
        }
        return result;
      }
      function toUtf8Bytes(str, form) {
        if (form != null) {
          (0, errors_js_1.assertNormalize)(form);
          str = str.normalize(form);
        }
        let result = [];
        for (let i = 0; i < str.length; i++) {
          const c = str.charCodeAt(i);
          if (c < 0x80) {
            result.push(c);
          } else if (c < 0x800) {
            result.push(c >> 6 | 0xc0);
            result.push(c & 0x3f | 0x80);
          } else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            (0, errors_js_1.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, "invalid surrogate pair", "str", str);
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push(pair >> 18 | 0xf0);
            result.push(pair >> 12 & 0x3f | 0x80);
            result.push(pair >> 6 & 0x3f | 0x80);
            result.push(pair & 0x3f | 0x80);
          } else {
            result.push(c >> 12 | 0xe0);
            result.push(c >> 6 & 0x3f | 0x80);
            result.push(c & 0x3f | 0x80);
          }
        }
        return new Uint8Array(result);
      }
      exports.toUtf8Bytes = toUtf8Bytes;
      ;
      function _toUtf8String(codePoints) {
        return codePoints.map(codePoint => {
          if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
          }
          codePoint -= 0x10000;
          return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
        }).join("");
      }
      function toUtf8String(bytes, onError) {
        return _toUtf8String(getUtf8CodePoints(bytes, onError));
      }
      exports.toUtf8String = toUtf8String;
      function toUtf8CodePoints(str, form) {
        return getUtf8CodePoints(toUtf8Bytes(str, form));
      }
      exports.toUtf8CodePoints = toUtf8CodePoints;
    },
    9574: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.uuidV4 = void 0;
      const data_js_1 = __webpack_require__(7924);
      function uuidV4(randomBytes) {
        const bytes = (0, data_js_1.getBytes)(randomBytes, "randomBytes");
        bytes[6] = bytes[6] & 0x0f | 0x40;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        const value = (0, data_js_1.hexlify)(bytes);
        return [value.substring(2, 10), value.substring(10, 14), value.substring(14, 18), value.substring(18, 22), value.substring(22, 34)].join("-");
      }
      exports.uuidV4 = uuidV4;
    },
    4830: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BaseWallet = void 0;
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(5714);
      const index_js_3 = __webpack_require__(3898);
      const index_js_4 = __webpack_require__(2877);
      const index_js_5 = __webpack_require__(9830);
      class BaseWallet extends index_js_3.AbstractSigner {
        address;
        #signingKey;
        constructor(privateKey, provider) {
          super(provider);
          (0, index_js_5.assertArgument)(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
          this.#signingKey = privateKey;
          const address = (0, index_js_4.computeAddress)(this.signingKey.publicKey);
          (0, index_js_5.defineProperties)(this, {
            address
          });
        }
        get signingKey() {
          return this.#signingKey;
        }
        get privateKey() {
          return this.signingKey.privateKey;
        }
        async getAddress() {
          return this.address;
        }
        connect(provider) {
          return new BaseWallet(this.#signingKey, provider);
        }
        async signTransaction(tx) {
          const {
            to,
            from
          } = await (0, index_js_5.resolveProperties)({
            to: tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : undefined,
            from: tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : undefined
          });
          if (to != null) {
            tx.to = to;
          }
          if (from != null) {
            tx.from = from;
          }
          if (tx.from != null) {
            (0, index_js_5.assertArgument)((0, index_js_1.getAddress)(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
            delete tx.from;
          }
          const btx = index_js_4.Transaction.from(tx);
          btx.signature = this.signingKey.sign(btx.unsignedHash);
          return btx.serialized;
        }
        async signMessage(message) {
          return this.signMessageSync(message);
        }
        signMessageSync(message) {
          return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;
        }
        async signTypedData(domain, types, value) {
          const populated = await index_js_2.TypedDataEncoder.resolveNames(domain, types, value, async name => {
            (0, index_js_5.assert)(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
              operation: "resolveName",
              info: {
                name
              }
            });
            const address = await this.provider.resolveName(name);
            (0, index_js_5.assert)(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
              value: name
            });
            return address;
          });
          return this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
        }
      }
      exports.BaseWallet = BaseWallet;
    },
    9218: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getIndexedAccountPath = exports.getAccountPath = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.defaultPath = void 0;
      const index_js_1 = __webpack_require__(9420);
      const index_js_2 = __webpack_require__(3898);
      const index_js_3 = __webpack_require__(2877);
      const index_js_4 = __webpack_require__(9830);
      const lang_en_js_1 = __webpack_require__(1517);
      const base_wallet_js_1 = __webpack_require__(4830);
      const mnemonic_js_1 = __webpack_require__(7436);
      const json_keystore_js_1 = __webpack_require__(4851);
      exports.defaultPath = "m/44'/60'/0'/0/0";
      const MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
      const HardenedBit = 0x80000000;
      const N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      const Nibbles = "0123456789abcdef";
      function zpad(value, length) {
        let result = "";
        while (value) {
          result = Nibbles[value % 16] + result;
          value = Math.trunc(value / 16);
        }
        while (result.length < length * 2) {
          result = "0" + result;
        }
        return "0x" + result;
      }
      function encodeBase58Check(_value) {
        const value = (0, index_js_4.getBytes)(_value);
        const check = (0, index_js_4.dataSlice)((0, index_js_1.sha256)((0, index_js_1.sha256)(value)), 0, 4);
        const bytes = (0, index_js_4.concat)([value, check]);
        return (0, index_js_4.encodeBase58)(bytes);
      }
      const _guard = {};
      function ser_I(index, chainCode, publicKey, privateKey) {
        const data = new Uint8Array(37);
        if (index & HardenedBit) {
          (0, index_js_4.assert)(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
            operation: "deriveChild"
          });
          data.set((0, index_js_4.getBytes)(privateKey), 1);
        } else {
          data.set((0, index_js_4.getBytes)(publicKey));
        }
        for (let i = 24; i >= 0; i -= 8) {
          data[33 + (i >> 3)] = index >> 24 - i & 0xff;
        }
        const I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", chainCode, data));
        return {
          IL: I.slice(0, 32),
          IR: I.slice(32)
        };
      }
      function derivePath(node, path) {
        const components = path.split("/");
        (0, index_js_4.assertArgument)(components.length > 0 && (components[0] === "m" || node.depth > 0), "invalid path", "path", path);
        if (components[0] === "m") {
          components.shift();
        }
        let result = node;
        for (let i = 0; i < components.length; i++) {
          const component = components[i];
          if (component.match(/^[0-9]+'$/)) {
            const index = parseInt(component.substring(0, component.length - 1));
            (0, index_js_4.assertArgument)(index < HardenedBit, "invalid path index", `path[${i}]`, component);
            result = result.deriveChild(HardenedBit + index);
          } else if (component.match(/^[0-9]+$/)) {
            const index = parseInt(component);
            (0, index_js_4.assertArgument)(index < HardenedBit, "invalid path index", `path[${i}]`, component);
            result = result.deriveChild(index);
          } else {
            (0, index_js_4.assertArgument)(false, "invalid path component", `path[${i}]`, component);
          }
        }
        return result;
      }
      class HDNodeWallet extends base_wallet_js_1.BaseWallet {
        publicKey;
        fingerprint;
        parentFingerprint;
        mnemonic;
        chainCode;
        path;
        index;
        depth;
        constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
          super(signingKey, provider);
          (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeWallet");
          (0, index_js_4.defineProperties)(this, {
            publicKey: signingKey.compressedPublicKey
          });
          const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(this.publicKey)), 0, 4);
          (0, index_js_4.defineProperties)(this, {
            parentFingerprint,
            fingerprint,
            chainCode,
            path,
            index,
            depth
          });
          (0, index_js_4.defineProperties)(this, {
            mnemonic
          });
        }
        connect(provider) {
          return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
        }
        #account() {
          const account = {
            address: this.address,
            privateKey: this.privateKey
          };
          const m = this.mnemonic;
          if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
            account.mnemonic = {
              path: this.path,
              locale: "en",
              entropy: m.entropy
            };
          }
          return account;
        }
        async encrypt(password, progressCallback) {
          return await (0, json_keystore_js_1.encryptKeystoreJson)(this.#account(), password, {
            progressCallback
          });
        }
        encryptSync(password) {
          return (0, json_keystore_js_1.encryptKeystoreJsonSync)(this.#account(), password);
        }
        get extendedKey() {
          (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
            operation: "extendedKey"
          });
          return encodeBase58Check((0, index_js_4.concat)(["0x0488ADE4", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, (0, index_js_4.concat)(["0x00", this.privateKey])]));
        }
        hasPath() {
          return this.path != null;
        }
        neuter() {
          return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
        }
        deriveChild(_index) {
          const index = (0, index_js_4.getNumber)(_index, "index");
          (0, index_js_4.assertArgument)(index <= 0xffffffff, "invalid index", "index", index);
          let path = this.path;
          if (path) {
            path += "/" + (index & ~HardenedBit);
            if (index & HardenedBit) {
              path += "'";
            }
          }
          const {
            IR,
            IL
          } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
          const ki = new index_js_1.SigningKey((0, index_js_4.toBeHex)(((0, index_js_4.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));
          return new HDNodeWallet(_guard, ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
        }
        derivePath(path) {
          return derivePath(this, path);
        }
        static #fromSeed(_seed, mnemonic) {
          (0, index_js_4.assertArgument)((0, index_js_4.isBytesLike)(_seed), "invalid seed", "seed", "[REDACTED]");
          const seed = (0, index_js_4.getBytes)(_seed, "seed");
          (0, index_js_4.assertArgument)(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
          const I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", MasterSecret, seed));
          const signingKey = new index_js_1.SigningKey((0, index_js_4.hexlify)(I.slice(0, 32)));
          return new HDNodeWallet(_guard, signingKey, "0x00000000", (0, index_js_4.hexlify)(I.slice(32)), "m", 0, 0, mnemonic, null);
        }
        static fromExtendedKey(extendedKey) {
          const bytes = (0, index_js_4.toBeArray)((0, index_js_4.decodeBase58)(extendedKey));
          (0, index_js_4.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
          const depth = bytes[4];
          const parentFingerprint = (0, index_js_4.hexlify)(bytes.slice(5, 9));
          const index = parseInt((0, index_js_4.hexlify)(bytes.slice(9, 13)).substring(2), 16);
          const chainCode = (0, index_js_4.hexlify)(bytes.slice(13, 45));
          const key = bytes.slice(45, 78);
          switch ((0, index_js_4.hexlify)(bytes.slice(0, 4))) {
            case "0x0488b21e":
            case "0x043587cf":
              {
                const publicKey = (0, index_js_4.hexlify)(key);
                return new HDNodeVoidWallet(_guard, (0, index_js_3.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
              }
            case "0x0488ade4":
            case "0x04358394 ":
              if (key[0] !== 0) {
                break;
              }
              return new HDNodeWallet(_guard, new index_js_1.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
          }
          (0, index_js_4.assertArgument)(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
        }
        static createRandom(password, path, wordlist) {
          if (password == null) {
            password = "";
          }
          if (path == null) {
            path = exports.defaultPath;
          }
          if (wordlist == null) {
            wordlist = lang_en_js_1.LangEn.wordlist();
          }
          const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy((0, index_js_1.randomBytes)(16), password, wordlist);
          return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        static fromMnemonic(mnemonic, path) {
          if (!path) {
            path = exports.defaultPath;
          }
          return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        static fromPhrase(phrase, password, path, wordlist) {
          if (password == null) {
            password = "";
          }
          if (path == null) {
            path = exports.defaultPath;
          }
          if (wordlist == null) {
            wordlist = lang_en_js_1.LangEn.wordlist();
          }
          const mnemonic = mnemonic_js_1.Mnemonic.fromPhrase(phrase, password, wordlist);
          return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        static fromSeed(seed) {
          return HDNodeWallet.#fromSeed(seed, null);
        }
      }
      exports.HDNodeWallet = HDNodeWallet;
      class HDNodeVoidWallet extends index_js_2.VoidSigner {
        publicKey;
        fingerprint;
        parentFingerprint;
        chainCode;
        path;
        index;
        depth;
        constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
          super(address, provider);
          (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeVoidWallet");
          (0, index_js_4.defineProperties)(this, {
            publicKey
          });
          const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(publicKey)), 0, 4);
          (0, index_js_4.defineProperties)(this, {
            publicKey,
            fingerprint,
            parentFingerprint,
            chainCode,
            path,
            index,
            depth
          });
        }
        connect(provider) {
          return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
        }
        get extendedKey() {
          (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
            operation: "extendedKey"
          });
          return encodeBase58Check((0, index_js_4.concat)(["0x0488B21E", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, this.publicKey]));
        }
        hasPath() {
          return this.path != null;
        }
        deriveChild(_index) {
          const index = (0, index_js_4.getNumber)(_index, "index");
          (0, index_js_4.assertArgument)(index <= 0xffffffff, "invalid index", "index", index);
          let path = this.path;
          if (path) {
            path += "/" + (index & ~HardenedBit);
            if (index & HardenedBit) {
              path += "'";
            }
          }
          const {
            IR,
            IL
          } = ser_I(index, this.chainCode, this.publicKey, null);
          const Ki = index_js_1.SigningKey.addPoints(IL, this.publicKey, true);
          const address = (0, index_js_3.computeAddress)(Ki);
          return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.provider);
        }
        derivePath(path) {
          return derivePath(this, path);
        }
      }
      exports.HDNodeVoidWallet = HDNodeVoidWallet;
      function getAccountPath(_index) {
        const index = (0, index_js_4.getNumber)(_index, "index");
        (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
        return `m/44'/60'/${index}'/0/0`;
      }
      exports.getAccountPath = getAccountPath;
      function getIndexedAccountPath(_index) {
        const index = (0, index_js_4.getNumber)(_index, "index");
        (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
        return `m/44'/60'/0'/0/${index}`;
      }
      exports.getIndexedAccountPath = getIndexedAccountPath;
    },
    4794: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Wallet = exports.Mnemonic = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.BaseWallet = void 0;
      var base_wallet_js_1 = __webpack_require__(4830);
      Object.defineProperty(exports, "BaseWallet", {
        enumerable: true,
        get: function () {
          return base_wallet_js_1.BaseWallet;
        }
      });
      var hdwallet_js_1 = __webpack_require__(9218);
      Object.defineProperty(exports, "defaultPath", {
        enumerable: true,
        get: function () {
          return hdwallet_js_1.defaultPath;
        }
      });
      Object.defineProperty(exports, "getAccountPath", {
        enumerable: true,
        get: function () {
          return hdwallet_js_1.getAccountPath;
        }
      });
      Object.defineProperty(exports, "getIndexedAccountPath", {
        enumerable: true,
        get: function () {
          return hdwallet_js_1.getIndexedAccountPath;
        }
      });
      Object.defineProperty(exports, "HDNodeWallet", {
        enumerable: true,
        get: function () {
          return hdwallet_js_1.HDNodeWallet;
        }
      });
      Object.defineProperty(exports, "HDNodeVoidWallet", {
        enumerable: true,
        get: function () {
          return hdwallet_js_1.HDNodeVoidWallet;
        }
      });
      var json_crowdsale_js_1 = __webpack_require__(6790);
      Object.defineProperty(exports, "isCrowdsaleJson", {
        enumerable: true,
        get: function () {
          return json_crowdsale_js_1.isCrowdsaleJson;
        }
      });
      Object.defineProperty(exports, "decryptCrowdsaleJson", {
        enumerable: true,
        get: function () {
          return json_crowdsale_js_1.decryptCrowdsaleJson;
        }
      });
      var json_keystore_js_1 = __webpack_require__(4851);
      Object.defineProperty(exports, "isKeystoreJson", {
        enumerable: true,
        get: function () {
          return json_keystore_js_1.isKeystoreJson;
        }
      });
      Object.defineProperty(exports, "decryptKeystoreJsonSync", {
        enumerable: true,
        get: function () {
          return json_keystore_js_1.decryptKeystoreJsonSync;
        }
      });
      Object.defineProperty(exports, "decryptKeystoreJson", {
        enumerable: true,
        get: function () {
          return json_keystore_js_1.decryptKeystoreJson;
        }
      });
      Object.defineProperty(exports, "encryptKeystoreJson", {
        enumerable: true,
        get: function () {
          return json_keystore_js_1.encryptKeystoreJson;
        }
      });
      Object.defineProperty(exports, "encryptKeystoreJsonSync", {
        enumerable: true,
        get: function () {
          return json_keystore_js_1.encryptKeystoreJsonSync;
        }
      });
      var mnemonic_js_1 = __webpack_require__(7436);
      Object.defineProperty(exports, "Mnemonic", {
        enumerable: true,
        get: function () {
          return mnemonic_js_1.Mnemonic;
        }
      });
      var wallet_js_1 = __webpack_require__(9958);
      Object.defineProperty(exports, "Wallet", {
        enumerable: true,
        get: function () {
          return wallet_js_1.Wallet;
        }
      });
    },
    6790: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = void 0;
      const aes_js_1 = __webpack_require__(205);
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(9420);
      const index_js_3 = __webpack_require__(5714);
      const index_js_4 = __webpack_require__(9830);
      const utils_js_1 = __webpack_require__(7363);
      function isCrowdsaleJson(json) {
        try {
          const data = JSON.parse(json);
          if (data.encseed) {
            return true;
          }
        } catch (error) {}
        return false;
      }
      exports.isCrowdsaleJson = isCrowdsaleJson;
      function decryptCrowdsaleJson(json, _password) {
        const data = JSON.parse(json);
        const password = (0, utils_js_1.getPassword)(_password);
        const address = (0, index_js_1.getAddress)((0, utils_js_1.spelunk)(data, "ethaddr:string!"));
        const encseed = (0, utils_js_1.looseArrayify)((0, utils_js_1.spelunk)(data, "encseed:string!"));
        (0, index_js_4.assertArgument)(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
        const key = (0, index_js_4.getBytes)((0, index_js_2.pbkdf2)(password, password, 2000, 32, "sha256")).slice(0, 16);
        const iv = encseed.slice(0, 16);
        const encryptedSeed = encseed.slice(16);
        const aesCbc = new aes_js_1.CBC(key, iv);
        const seed = (0, aes_js_1.pkcs7Strip)((0, index_js_4.getBytes)(aesCbc.decrypt(encryptedSeed)));
        let seedHex = "";
        for (let i = 0; i < seed.length; i++) {
          seedHex += String.fromCharCode(seed[i]);
        }
        return {
          address,
          privateKey: (0, index_js_3.id)(seedHex)
        };
      }
      exports.decryptCrowdsaleJson = decryptCrowdsaleJson;
    },
    4851: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.encryptKeystoreJson = exports.encryptKeystoreJsonSync = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = void 0;
      const aes_js_1 = __webpack_require__(205);
      const index_js_1 = __webpack_require__(2134);
      const index_js_2 = __webpack_require__(9420);
      const index_js_3 = __webpack_require__(2877);
      const index_js_4 = __webpack_require__(9830);
      const utils_js_1 = __webpack_require__(7363);
      const _version_js_1 = __webpack_require__(9737);
      const defaultPath = "m/44'/60'/0'/0/0";
      function isKeystoreJson(json) {
        try {
          const data = JSON.parse(json);
          const version = data.version != null ? parseInt(data.version) : 0;
          if (version === 3) {
            return true;
          }
        } catch (error) {}
        return false;
      }
      exports.isKeystoreJson = isKeystoreJson;
      function decrypt(data, key, ciphertext) {
        const cipher = (0, utils_js_1.spelunk)(data, "crypto.cipher:string");
        if (cipher === "aes-128-ctr") {
          const iv = (0, utils_js_1.spelunk)(data, "crypto.cipherparams.iv:data!");
          const aesCtr = new aes_js_1.CTR(key, iv);
          return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));
        }
        (0, index_js_4.assert)(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
          operation: "decrypt"
        });
      }
      function getAccount(data, _key) {
        const key = (0, index_js_4.getBytes)(_key);
        const ciphertext = (0, utils_js_1.spelunk)(data, "crypto.ciphertext:data!");
        const computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([key.slice(16, 32), ciphertext]))).substring(2);
        (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
        const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
        const address = (0, index_js_3.computeAddress)(privateKey);
        if (data.address) {
          let check = data.address.toLowerCase();
          if (!check.startsWith("0x")) {
            check = "0x" + check;
          }
          (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, "keystore address/privateKey mismatch", "address", data.address);
        }
        const account = {
          address,
          privateKey
        };
        const version = (0, utils_js_1.spelunk)(data, "x-ethers.version:string");
        if (version === "0.1") {
          const mnemonicKey = key.slice(32, 64);
          const mnemonicCiphertext = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCiphertext:data!");
          const mnemonicIv = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCounter:data!");
          const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
          account.mnemonic = {
            path: (0, utils_js_1.spelunk)(data, "x-ethers.path:string") || defaultPath,
            locale: (0, utils_js_1.spelunk)(data, "x-ethers.locale:string") || "en",
            entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
          };
        }
        return account;
      }
      function getDecryptKdfParams(data) {
        const kdf = (0, utils_js_1.spelunk)(data, "crypto.kdf:string");
        if (kdf && typeof kdf === "string") {
          if (kdf.toLowerCase() === "scrypt") {
            const salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
            const N = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.n:int!");
            const r = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.r:int!");
            const p = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.p:int!");
            (0, index_js_4.assertArgument)(N > 0 && (N & N - 1) === 0, "invalid kdf.N", "kdf.N", N);
            (0, index_js_4.assertArgument)(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
            const dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
            (0, index_js_4.assertArgument)(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
            return {
              name: "scrypt",
              salt,
              N,
              r,
              p,
              dkLen: 64
            };
          } else if (kdf.toLowerCase() === "pbkdf2") {
            const salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
            const prf = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.prf:string!");
            const algorithm = prf.split("-").pop();
            (0, index_js_4.assertArgument)(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
            const count = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.c:int!");
            const dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
            (0, index_js_4.assertArgument)(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
            return {
              name: "pbkdf2",
              salt,
              count,
              dkLen,
              algorithm
            };
          }
        }
        (0, index_js_4.assertArgument)(false, "unsupported key-derivation function", "kdf", kdf);
      }
      function decryptKeystoreJsonSync(json, _password) {
        const data = JSON.parse(json);
        const password = (0, utils_js_1.getPassword)(_password);
        const params = getDecryptKdfParams(data);
        if (params.name === "pbkdf2") {
          const {
            salt,
            count,
            dkLen,
            algorithm
          } = params;
          const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);
          return getAccount(data, key);
        }
        (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
          params
        });
        const {
          salt,
          N,
          r,
          p,
          dkLen
        } = params;
        const key = (0, index_js_2.scryptSync)(password, salt, N, r, p, dkLen);
        return getAccount(data, key);
      }
      exports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;
      function stall(duration) {
        return new Promise(resolve => {
          setTimeout(() => {
            resolve();
          }, duration);
        });
      }
      async function decryptKeystoreJson(json, _password, progress) {
        const data = JSON.parse(json);
        const password = (0, utils_js_1.getPassword)(_password);
        const params = getDecryptKdfParams(data);
        if (params.name === "pbkdf2") {
          if (progress) {
            progress(0);
            await stall(0);
          }
          const {
            salt,
            count,
            dkLen,
            algorithm
          } = params;
          const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);
          if (progress) {
            progress(1);
            await stall(0);
          }
          return getAccount(data, key);
        }
        (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
          params
        });
        const {
          salt,
          N,
          r,
          p,
          dkLen
        } = params;
        const key = await (0, index_js_2.scrypt)(password, salt, N, r, p, dkLen, progress);
        return getAccount(data, key);
      }
      exports.decryptKeystoreJson = decryptKeystoreJson;
      function getEncryptKdfParams(options) {
        const salt = options.salt != null ? (0, index_js_4.getBytes)(options.salt, "options.salt") : (0, index_js_2.randomBytes)(32);
        let N = 1 << 17,
          r = 8,
          p = 1;
        if (options.scrypt) {
          if (options.scrypt.N) {
            N = options.scrypt.N;
          }
          if (options.scrypt.r) {
            r = options.scrypt.r;
          }
          if (options.scrypt.p) {
            p = options.scrypt.p;
          }
        }
        (0, index_js_4.assertArgument)(typeof N === "number" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N);
        (0, index_js_4.assertArgument)(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
        (0, index_js_4.assertArgument)(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
        return {
          name: "scrypt",
          dkLen: 32,
          salt,
          N,
          r,
          p
        };
      }
      function _encryptKeystore(key, kdf, account, options) {
        const privateKey = (0, index_js_4.getBytes)(account.privateKey, "privateKey");
        const iv = options.iv != null ? (0, index_js_4.getBytes)(options.iv, "options.iv") : (0, index_js_2.randomBytes)(16);
        (0, index_js_4.assertArgument)(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
        const uuidRandom = options.uuid != null ? (0, index_js_4.getBytes)(options.uuid, "options.uuid") : (0, index_js_2.randomBytes)(16);
        (0, index_js_4.assertArgument)(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
        const derivedKey = key.slice(0, 16);
        const macPrefix = key.slice(16, 32);
        const aesCtr = new aes_js_1.CTR(derivedKey, iv);
        const ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));
        const mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([macPrefix, ciphertext]));
        const data = {
          address: account.address.substring(2).toLowerCase(),
          id: (0, index_js_4.uuidV4)(uuidRandom),
          version: 3,
          Crypto: {
            cipher: "aes-128-ctr",
            cipherparams: {
              iv: (0, index_js_4.hexlify)(iv).substring(2)
            },
            ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),
            kdf: "scrypt",
            kdfparams: {
              salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),
              n: kdf.N,
              dklen: 32,
              p: kdf.p,
              r: kdf.r
            },
            mac: mac.substring(2)
          }
        };
        if (account.mnemonic) {
          const client = options.client != null ? options.client : `ethers/${_version_js_1.version}`;
          const path = account.mnemonic.path || defaultPath;
          const locale = account.mnemonic.locale || "en";
          const mnemonicKey = key.slice(32, 64);
          const entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, "account.mnemonic.entropy");
          const mnemonicIv = (0, index_js_2.randomBytes)(16);
          const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
          const mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));
          const now = new Date();
          const timestamp = now.getUTCFullYear() + "-" + (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + "-" + (0, utils_js_1.zpad)(now.getUTCDate(), 2) + "T" + (0, utils_js_1.zpad)(now.getUTCHours(), 2) + "-" + (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + "-" + (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + ".0Z";
          const gethFilename = "UTC--" + timestamp + "--" + data.address;
          data["x-ethers"] = {
            client,
            gethFilename,
            path,
            locale,
            mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),
            mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),
            version: "0.1"
          };
        }
        return JSON.stringify(data);
      }
      function encryptKeystoreJsonSync(account, password, options) {
        if (options == null) {
          options = {};
        }
        const passwordBytes = (0, utils_js_1.getPassword)(password);
        const kdf = getEncryptKdfParams(options);
        const key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
        return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);
      }
      exports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;
      async function encryptKeystoreJson(account, password, options) {
        if (options == null) {
          options = {};
        }
        const passwordBytes = (0, utils_js_1.getPassword)(password);
        const kdf = getEncryptKdfParams(options);
        const key = await (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
        return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);
      }
      exports.encryptKeystoreJson = encryptKeystoreJson;
    },
    7436: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Mnemonic = void 0;
      const index_js_1 = __webpack_require__(9420);
      const index_js_2 = __webpack_require__(9830);
      const lang_en_js_1 = __webpack_require__(1517);
      function getUpperMask(bits) {
        return (1 << bits) - 1 << 8 - bits & 0xff;
      }
      function getLowerMask(bits) {
        return (1 << bits) - 1 & 0xff;
      }
      function mnemonicToEntropy(mnemonic, wordlist) {
        (0, index_js_2.assertNormalize)("NFKD");
        if (wordlist == null) {
          wordlist = lang_en_js_1.LangEn.wordlist();
        }
        const words = wordlist.split(mnemonic);
        (0, index_js_2.assertArgument)(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
        const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));
        let offset = 0;
        for (let i = 0; i < words.length; i++) {
          let index = wordlist.getWordIndex(words[i].normalize("NFKD"));
          (0, index_js_2.assertArgument)(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
          for (let bit = 0; bit < 11; bit++) {
            if (index & 1 << 10 - bit) {
              entropy[offset >> 3] |= 1 << 7 - offset % 8;
            }
            offset++;
          }
        }
        const entropyBits = 32 * words.length / 3;
        const checksumBits = words.length / 3;
        const checksumMask = getUpperMask(checksumBits);
        const checksum = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
        (0, index_js_2.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
        return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));
      }
      function entropyToMnemonic(entropy, wordlist) {
        (0, index_js_2.assertArgument)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
        if (wordlist == null) {
          wordlist = lang_en_js_1.LangEn.wordlist();
        }
        const indices = [0];
        let remainingBits = 11;
        for (let i = 0; i < entropy.length; i++) {
          if (remainingBits > 8) {
            indices[indices.length - 1] <<= 8;
            indices[indices.length - 1] |= entropy[i];
            remainingBits -= 8;
          } else {
            indices[indices.length - 1] <<= remainingBits;
            indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
            indices.push(entropy[i] & getLowerMask(8 - remainingBits));
            remainingBits += 3;
          }
        }
        const checksumBits = entropy.length / 4;
        const checksum = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
        indices[indices.length - 1] <<= checksumBits;
        indices[indices.length - 1] |= checksum >> 8 - checksumBits;
        return wordlist.join(indices.map(index => wordlist.getWord(index)));
      }
      const _guard = {};
      class Mnemonic {
        phrase;
        password;
        wordlist;
        entropy;
        constructor(guard, entropy, phrase, password, wordlist) {
          if (password == null) {
            password = "";
          }
          if (wordlist == null) {
            wordlist = lang_en_js_1.LangEn.wordlist();
          }
          (0, index_js_2.assertPrivate)(guard, _guard, "Mnemonic");
          (0, index_js_2.defineProperties)(this, {
            phrase,
            password,
            wordlist,
            entropy
          });
        }
        computeSeed() {
          const salt = (0, index_js_2.toUtf8Bytes)("mnemonic" + this.password, "NFKD");
          return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
        }
        static fromPhrase(phrase, password, wordlist) {
          const entropy = mnemonicToEntropy(phrase, wordlist);
          phrase = entropyToMnemonic((0, index_js_2.getBytes)(entropy), wordlist);
          return new Mnemonic(_guard, entropy, phrase, password, wordlist);
        }
        static fromEntropy(_entropy, password, wordlist) {
          const entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
          const phrase = entropyToMnemonic(entropy, wordlist);
          return new Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist);
        }
        static entropyToPhrase(_entropy, wordlist) {
          const entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
          return entropyToMnemonic(entropy, wordlist);
        }
        static phraseToEntropy(phrase, wordlist) {
          return mnemonicToEntropy(phrase, wordlist);
        }
        static isValidMnemonic(phrase, wordlist) {
          try {
            mnemonicToEntropy(phrase, wordlist);
            return true;
          } catch (error) {}
          return false;
        }
      }
      exports.Mnemonic = Mnemonic;
    },
    7363: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.spelunk = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;
      const index_js_1 = __webpack_require__(9830);
      function looseArrayify(hexString) {
        if (typeof hexString === "string" && !hexString.startsWith("0x")) {
          hexString = "0x" + hexString;
        }
        return (0, index_js_1.getBytesCopy)(hexString);
      }
      exports.looseArrayify = looseArrayify;
      function zpad(value, length) {
        value = String(value);
        while (value.length < length) {
          value = '0' + value;
        }
        return value;
      }
      exports.zpad = zpad;
      function getPassword(password) {
        if (typeof password === 'string') {
          return (0, index_js_1.toUtf8Bytes)(password, "NFKC");
        }
        return (0, index_js_1.getBytesCopy)(password);
      }
      exports.getPassword = getPassword;
      function spelunk(object, _path) {
        const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
        (0, index_js_1.assertArgument)(match != null, "invalid path", "path", _path);
        const path = match[1];
        const type = match[3];
        const reqd = match[4] === "!";
        let cur = object;
        for (const comp of path.toLowerCase().split('.')) {
          if (Array.isArray(cur)) {
            if (!comp.match(/^[0-9]+$/)) {
              break;
            }
            cur = cur[parseInt(comp)];
          } else if (typeof cur === "object") {
            let found = null;
            for (const key in cur) {
              if (key.toLowerCase() === comp) {
                found = cur[key];
                break;
              }
            }
            cur = found;
          } else {
            cur = null;
          }
          if (cur == null) {
            break;
          }
        }
        (0, index_js_1.assertArgument)(!reqd || cur != null, "missing required value", "path", path);
        if (type && cur != null) {
          if (type === "int") {
            if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
              return parseInt(cur);
            } else if (Number.isSafeInteger(cur)) {
              return cur;
            }
          }
          if (type === "number") {
            if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
              return parseFloat(cur);
            }
          }
          if (type === "data") {
            if (typeof cur === "string") {
              return looseArrayify(cur);
            }
          }
          if (type === "array" && Array.isArray(cur)) {
            return cur;
          }
          if (type === typeof cur) {
            return cur;
          }
          (0, index_js_1.assertArgument)(false, `wrong type found for ${type} `, "path", path);
        }
        return cur;
      }
      exports.spelunk = spelunk;
    },
    9958: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Wallet = void 0;
      const index_js_1 = __webpack_require__(9420);
      const index_js_2 = __webpack_require__(9830);
      const base_wallet_js_1 = __webpack_require__(4830);
      const hdwallet_js_1 = __webpack_require__(9218);
      const json_crowdsale_js_1 = __webpack_require__(6790);
      const json_keystore_js_1 = __webpack_require__(4851);
      const mnemonic_js_1 = __webpack_require__(7436);
      function stall(duration) {
        return new Promise(resolve => {
          setTimeout(() => {
            resolve();
          }, duration);
        });
      }
      class Wallet extends base_wallet_js_1.BaseWallet {
        constructor(key, provider) {
          if (typeof key === "string" && !key.startsWith("0x")) {
            key = "0x" + key;
          }
          let signingKey = typeof key === "string" ? new index_js_1.SigningKey(key) : key;
          super(signingKey, provider);
        }
        connect(provider) {
          return new Wallet(this.signingKey, provider);
        }
        async encrypt(password, progressCallback) {
          const account = {
            address: this.address,
            privateKey: this.privateKey
          };
          return await (0, json_keystore_js_1.encryptKeystoreJson)(account, password, {
            progressCallback
          });
        }
        encryptSync(password) {
          const account = {
            address: this.address,
            privateKey: this.privateKey
          };
          return (0, json_keystore_js_1.encryptKeystoreJsonSync)(account, password);
        }
        static #fromAccount(account) {
          (0, index_js_2.assertArgument)(account, "invalid JSON wallet", "json", "[ REDACTED ]");
          if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
            const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy(account.mnemonic.entropy);
            const wallet = hdwallet_js_1.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
            if (wallet.address === account.address && wallet.privateKey === account.privateKey) {
              return wallet;
            }
            console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
          }
          const wallet = new Wallet(account.privateKey);
          (0, index_js_2.assertArgument)(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
          return wallet;
        }
        static async fromEncryptedJson(json, password, progress) {
          let account = null;
          if ((0, json_keystore_js_1.isKeystoreJson)(json)) {
            account = await (0, json_keystore_js_1.decryptKeystoreJson)(json, password, progress);
          } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
            if (progress) {
              progress(0);
              await stall(0);
            }
            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
            if (progress) {
              progress(1);
              await stall(0);
            }
          }
          return Wallet.#fromAccount(account);
        }
        static fromEncryptedJsonSync(json, password) {
          let account = null;
          if ((0, json_keystore_js_1.isKeystoreJson)(json)) {
            account = (0, json_keystore_js_1.decryptKeystoreJsonSync)(json, password);
          } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
          } else {
            (0, index_js_2.assertArgument)(false, "invalid JSON wallet", "json", "[ REDACTED ]");
          }
          return Wallet.#fromAccount(account);
        }
        static createRandom(provider) {
          const wallet = hdwallet_js_1.HDNodeWallet.createRandom();
          if (provider) {
            return wallet.connect(provider);
          }
          return wallet;
        }
        static fromPhrase(phrase, provider) {
          const wallet = hdwallet_js_1.HDNodeWallet.fromPhrase(phrase);
          if (provider) {
            return wallet.connect(provider);
          }
          return wallet;
        }
      }
      exports.Wallet = Wallet;
    },
    5943: (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decodeBits = void 0;
      const Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
      function decodeBits(width, data) {
        const maxValue = (1 << width) - 1;
        const result = [];
        let accum = 0,
          bits = 0,
          flood = 0;
        for (let i = 0; i < data.length; i++) {
          accum = accum << 6 | Base64.indexOf(data[i]);
          bits += 6;
          while (bits >= width) {
            const value = accum >> bits - width;
            accum &= (1 << bits - width) - 1;
            bits -= width;
            if (value === 0) {
              flood += maxValue;
            } else {
              result.push(value + flood);
              flood = 0;
            }
          }
        }
        return result;
      }
      exports.decodeBits = decodeBits;
    },
    906: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decodeOwl = exports.decode = void 0;
      const index_js_1 = __webpack_require__(9830);
      const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
      const Word = /^[a-z]*$/i;
      function unfold(words, sep) {
        let initial = 97;
        return words.reduce((accum, word) => {
          if (word === sep) {
            initial++;
          } else if (word.match(Word)) {
            accum.push(String.fromCharCode(initial) + word);
          } else {
            initial = 97;
            accum.push(word);
          }
          return accum;
        }, []);
      }
      function decode(data, subs) {
        for (let i = subsChrs.length - 1; i >= 0; i--) {
          data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
        }
        const clumps = [];
        const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
          if (semi) {
            for (let i = parseInt(semi); i >= 0; i--) {
              clumps.push(";");
            }
          } else {
            clumps.push(item.toLowerCase());
          }
          return "";
        });
        if (leftover) {
          throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
        }
        return unfold(unfold(clumps, ";"), ":");
      }
      exports.decode = decode;
      function decodeOwl(data) {
        (0, index_js_1.assertArgument)(data[0] === "0", "unsupported auwl data", "data", data);
        return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
      }
      exports.decodeOwl = decodeOwl;
    },
    8360: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decodeOwlA = void 0;
      const index_js_1 = __webpack_require__(9830);
      const bit_reader_js_1 = __webpack_require__(5943);
      const decode_owl_js_1 = __webpack_require__(906);
      function decodeOwlA(data, accents) {
        let words = (0, decode_owl_js_1.decodeOwl)(data).join(",");
        accents.split(/,/g).forEach(accent => {
          const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
          (0, index_js_1.assertArgument)(match !== null, "internal error parsing accents", "accents", accents);
          let posOffset = 0;
          const positions = (0, bit_reader_js_1.decodeBits)(parseInt(match[3]), match[4]);
          const charCode = parseInt(match[2]);
          const regex = new RegExp(`([${match[1]}])`, "g");
          words = words.replace(regex, (all, letter) => {
            const rem = --positions[posOffset];
            if (rem === 0) {
              letter = String.fromCharCode(letter.charCodeAt(0), charCode);
              posOffset++;
            }
            return letter;
          });
        });
        return words.split(",");
      }
      exports.decodeOwlA = decodeOwlA;
    },
    4574: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = void 0;
      var wordlist_js_1 = __webpack_require__(3698);
      Object.defineProperty(exports, "Wordlist", {
        enumerable: true,
        get: function () {
          return wordlist_js_1.Wordlist;
        }
      });
      var lang_en_js_1 = __webpack_require__(1517);
      Object.defineProperty(exports, "LangEn", {
        enumerable: true,
        get: function () {
          return lang_en_js_1.LangEn;
        }
      });
      var wordlist_owl_js_1 = __webpack_require__(7072);
      Object.defineProperty(exports, "WordlistOwl", {
        enumerable: true,
        get: function () {
          return wordlist_owl_js_1.WordlistOwl;
        }
      });
      var wordlist_owla_js_1 = __webpack_require__(3950);
      Object.defineProperty(exports, "WordlistOwlA", {
        enumerable: true,
        get: function () {
          return wordlist_owla_js_1.WordlistOwlA;
        }
      });
      var wordlists_js_1 = __webpack_require__(3230);
      Object.defineProperty(exports, "wordlists", {
        enumerable: true,
        get: function () {
          return wordlists_js_1.wordlists;
        }
      });
    },
    1517: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LangEn = void 0;
      const wordlist_owl_js_1 = __webpack_require__(7072);
      const words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
      const checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
      let wordlist = null;
      class LangEn extends wordlist_owl_js_1.WordlistOwl {
        constructor() {
          super("en", words, checksum);
        }
        static wordlist() {
          if (wordlist == null) {
            wordlist = new LangEn();
          }
          return wordlist;
        }
      }
      exports.LangEn = LangEn;
    },
    7072: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.WordlistOwl = void 0;
      const index_js_1 = __webpack_require__(5714);
      const index_js_2 = __webpack_require__(9830);
      const decode_owl_js_1 = __webpack_require__(906);
      const wordlist_js_1 = __webpack_require__(3698);
      class WordlistOwl extends wordlist_js_1.Wordlist {
        #data;
        #checksum;
        constructor(locale, data, checksum) {
          super(locale);
          this.#data = data;
          this.#checksum = checksum;
          this.#words = null;
        }
        get _data() {
          return this.#data;
        }
        _decodeWords() {
          return (0, decode_owl_js_1.decodeOwl)(this.#data);
        }
        #words;
        #loadWords() {
          if (this.#words == null) {
            const words = this._decodeWords();
            const checksum = (0, index_js_1.id)(words.join("\n") + "\n");
            if (checksum !== this.#checksum) {
              throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
            }
            this.#words = words;
          }
          return this.#words;
        }
        getWord(index) {
          const words = this.#loadWords();
          (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
          return words[index];
        }
        getWordIndex(word) {
          return this.#loadWords().indexOf(word);
        }
      }
      exports.WordlistOwl = WordlistOwl;
    },
    3950: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.WordlistOwlA = void 0;
      const wordlist_owl_js_1 = __webpack_require__(7072);
      const decode_owla_js_1 = __webpack_require__(8360);
      class WordlistOwlA extends wordlist_owl_js_1.WordlistOwl {
        #accent;
        constructor(locale, data, accent, checksum) {
          super(locale, data, checksum);
          this.#accent = accent;
        }
        get _accent() {
          return this.#accent;
        }
        _decodeWords() {
          return (0, decode_owla_js_1.decodeOwlA)(this._data, this._accent);
        }
      }
      exports.WordlistOwlA = WordlistOwlA;
    },
    3698: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Wordlist = void 0;
      const index_js_1 = __webpack_require__(9830);
      class Wordlist {
        locale;
        constructor(locale) {
          (0, index_js_1.defineProperties)(this, {
            locale
          });
        }
        split(phrase) {
          return phrase.toLowerCase().split(/\s+/g);
        }
        join(words) {
          return words.join(" ");
        }
      }
      exports.Wordlist = Wordlist;
    },
    3230: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.wordlists = void 0;
      const lang_en_js_1 = __webpack_require__(1517);
      exports.wordlists = {
        en: lang_en_js_1.LangEn.wordlist()
      };
    },
    192: module => {
      "use strict";

      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all) __defProp(target, name, {
          get: all[name],
          enumerable: true
        });
      };
      var __copyProps = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: () => from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
          });
        }
        return to;
      };
      var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
        value: true
      }), mod);
      var src_exports = {};
      __export(src_exports, {
        createFinalURL: () => createFinalURL,
        default: () => createClient,
        defaultBodySerializer: () => defaultBodySerializer,
        defaultQuerySerializer: () => defaultQuerySerializer
      });
      module.exports = __toCommonJS(src_exports);
      var DEFAULT_HEADERS = {
        "Content-Type": "application/json"
      };
      var TRAILING_SLASH_RE = /\/*$/;
      function defaultQuerySerializer(q) {
        const search = new URLSearchParams();
        if (q && typeof q === "object") {
          for (const [k, v] of Object.entries(q)) {
            if (v === void 0 || v === null) continue;
            search.set(k, v);
          }
        }
        return search.toString();
      }
      function defaultBodySerializer(body) {
        return JSON.stringify(body);
      }
      function createFinalURL(url, options) {
        let finalURL = `${options.baseUrl ? options.baseUrl.replace(TRAILING_SLASH_RE, "") : ""}${url}`;
        if (options.params.path) {
          for (const [k, v] of Object.entries(options.params.path)) finalURL = finalURL.replace(`{${k}}`, encodeURIComponent(String(v)));
        }
        if (options.params.query) {
          const search = options.querySerializer(options.params.query);
          if (search) finalURL += `?${search}`;
        }
        return finalURL;
      }
      function createClient(clientOptions = {}) {
        const {
          fetch = globalThis.fetch,
          querySerializer: globalQuerySerializer,
          bodySerializer: globalBodySerializer,
          ...options
        } = clientOptions;
        const defaultHeaders = new Headers({
          ...DEFAULT_HEADERS,
          ...(options.headers ?? {})
        });
        async function coreFetch(url, fetchOptions) {
          const {
            headers,
            body: requestBody,
            params = {},
            parseAs = "json",
            querySerializer = globalQuerySerializer ?? defaultQuerySerializer,
            bodySerializer = globalBodySerializer ?? defaultBodySerializer,
            ...init
          } = fetchOptions || {};
          const finalURL = createFinalURL(url, {
            baseUrl: options.baseUrl,
            params,
            querySerializer
          });
          const baseHeaders = new Headers(defaultHeaders);
          const headerOverrides = new Headers(headers);
          for (const [k, v] of headerOverrides.entries()) {
            if (v === void 0 || v === null) baseHeaders.delete(k);else baseHeaders.set(k, v);
          }
          const requestInit = {
            redirect: "follow",
            ...options,
            ...init,
            headers: baseHeaders
          };
          if (requestBody) requestInit.body = bodySerializer(requestBody);
          baseHeaders.delete("Content-Type");
          const response = await fetch(finalURL, requestInit);
          if (response.status === 204 || response.headers.get("Content-Length") === "0") {
            return response.ok ? {
              data: {},
              response
            } : {
              error: {},
              response
            };
          }
          if (response.ok) {
            let data = response.body;
            if (parseAs !== "stream") {
              const cloned = response.clone();
              data = typeof cloned[parseAs] === "function" ? await cloned[parseAs]() : await cloned.text();
            }
            return {
              data,
              response
            };
          }
          let error = {};
          try {
            error = await response.clone().json();
          } catch {
            error = await response.clone().text();
          }
          return {
            error,
            response
          };
        }
        return {
          async get(url, init) {
            return coreFetch(url, {
              ...init,
              method: "GET"
            });
          },
          async put(url, init) {
            return coreFetch(url, {
              ...init,
              method: "PUT"
            });
          },
          async post(url, init) {
            return coreFetch(url, {
              ...init,
              method: "POST"
            });
          },
          async del(url, init) {
            return coreFetch(url, {
              ...init,
              method: "DELETE"
            });
          },
          async options(url, init) {
            return coreFetch(url, {
              ...init,
              method: "OPTIONS"
            });
          },
          async head(url, init) {
            return coreFetch(url, {
              ...init,
              method: "HEAD"
            });
          },
          async patch(url, init) {
            return coreFetch(url, {
              ...init,
              method: "PATCH"
            });
          },
          async trace(url, init) {
            return coreFetch(url, {
              ...init,
              method: "TRACE"
            });
          }
        };
      }
    },
    9249: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        Struct: () => Struct,
        StructError: () => StructError,
        any: () => any,
        array: () => array,
        assert: () => assert,
        assign: () => assign,
        bigint: () => bigint,
        boolean: () => boolean,
        coerce: () => coerce,
        create: () => create,
        date: () => date,
        defaulted: () => defaulted,
        define: () => define,
        deprecated: () => deprecated,
        dynamic: () => dynamic,
        empty: () => empty,
        enums: () => enums,
        func: () => func,
        instance: () => instance,
        integer: () => integer,
        intersection: () => intersection,
        is: () => is,
        lazy: () => lazy,
        literal: () => literal,
        map: () => map,
        mask: () => mask,
        max: () => max,
        min: () => min,
        never: () => never,
        nonempty: () => nonempty,
        nullable: () => nullable,
        number: () => number,
        object: () => object,
        omit: () => omit,
        optional: () => optional,
        partial: () => partial,
        pattern: () => pattern,
        pick: () => pick,
        record: () => record,
        refine: () => refine,
        regexp: () => regexp,
        set: () => set,
        size: () => size,
        string: () => string,
        struct: () => struct,
        trimmed: () => trimmed,
        tuple: () => tuple,
        type: () => type,
        union: () => union,
        unknown: () => unknown,
        validate: () => validate
      });
      class StructError extends TypeError {
        constructor(failure, failures) {
          let cached;
          const {
            message,
            explanation,
            ...rest
          } = failure;
          const {
            path
          } = failure;
          const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
          super(explanation ?? msg);
          if (explanation != null) this.cause = msg;
          Object.assign(this, rest);
          this.name = this.constructor.name;
          this.failures = () => {
            return cached ?? (cached = [failure, ...failures()]);
          };
        }
      }
      function isIterable(x) {
        return isObject(x) && typeof x[Symbol.iterator] === 'function';
      }
      function isObject(x) {
        return typeof x === 'object' && x != null;
      }
      function isPlainObject(x) {
        if (Object.prototype.toString.call(x) !== '[object Object]') {
          return false;
        }
        const prototype = Object.getPrototypeOf(x);
        return prototype === null || prototype === Object.prototype;
      }
      function print(value) {
        if (typeof value === 'symbol') {
          return value.toString();
        }
        return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
      }
      function shiftIterator(input) {
        const {
          done,
          value
        } = input.next();
        return done ? undefined : value;
      }
      function toFailure(result, context, struct, value) {
        if (result === true) {
          return;
        } else if (result === false) {
          result = {};
        } else if (typeof result === 'string') {
          result = {
            message: result
          };
        }
        const {
          path,
          branch
        } = context;
        const {
          type
        } = struct;
        const {
          refinement,
          message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\``
        } = result;
        return {
          value,
          type,
          refinement,
          key: path[path.length - 1],
          path,
          branch,
          ...result,
          message
        };
      }
      function* toFailures(result, context, struct, value) {
        if (!isIterable(result)) {
          result = [result];
        }
        for (const r of result) {
          const failure = toFailure(r, context, struct, value);
          if (failure) {
            yield failure;
          }
        }
      }
      function* run(value, struct, options = {}) {
        const {
          path = [],
          branch = [value],
          coerce = false,
          mask = false
        } = options;
        const ctx = {
          path,
          branch
        };
        if (coerce) {
          value = struct.coercer(value, ctx);
          if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
            for (const key in value) {
              if (struct.schema[key] === undefined) {
                delete value[key];
              }
            }
          }
        }
        let status = 'valid';
        for (const failure of struct.validator(value, ctx)) {
          failure.explanation = options.message;
          status = 'not_valid';
          yield [failure, undefined];
        }
        for (let [k, v, s] of struct.entries(value, ctx)) {
          const ts = run(v, s, {
            path: k === undefined ? path : [...path, k],
            branch: k === undefined ? branch : [...branch, v],
            coerce,
            mask,
            message: options.message
          });
          for (const t of ts) {
            if (t[0]) {
              status = t[0].refinement != null ? 'not_refined' : 'not_valid';
              yield [t[0], undefined];
            } else if (coerce) {
              v = t[1];
              if (k === undefined) {
                value = v;
              } else if (value instanceof Map) {
                value.set(k, v);
              } else if (value instanceof Set) {
                value.add(v);
              } else if (isObject(value)) {
                if (v !== undefined || k in value) value[k] = v;
              }
            }
          }
        }
        if (status !== 'not_valid') {
          for (const failure of struct.refiner(value, ctx)) {
            failure.explanation = options.message;
            status = 'not_refined';
            yield [failure, undefined];
          }
        }
        if (status === 'valid') {
          yield [undefined, value];
        }
      }
      class Struct {
        constructor(props) {
          const {
            type,
            schema,
            validator,
            refiner,
            coercer = value => value,
            entries = function* () {}
          } = props;
          this.type = type;
          this.schema = schema;
          this.entries = entries;
          this.coercer = coercer;
          if (validator) {
            this.validator = (value, context) => {
              const result = validator(value, context);
              return toFailures(result, context, this, value);
            };
          } else {
            this.validator = () => [];
          }
          if (refiner) {
            this.refiner = (value, context) => {
              const result = refiner(value, context);
              return toFailures(result, context, this, value);
            };
          } else {
            this.refiner = () => [];
          }
        }
        assert(value, message) {
          return assert(value, this, message);
        }
        create(value, message) {
          return create(value, this, message);
        }
        is(value) {
          return is(value, this);
        }
        mask(value, message) {
          return mask(value, this, message);
        }
        validate(value, options = {}) {
          return validate(value, this, options);
        }
      }
      function assert(value, struct, message) {
        const result = validate(value, struct, {
          message
        });
        if (result[0]) {
          throw result[0];
        }
      }
      function create(value, struct, message) {
        const result = validate(value, struct, {
          coerce: true,
          message
        });
        if (result[0]) {
          throw result[0];
        } else {
          return result[1];
        }
      }
      function mask(value, struct, message) {
        const result = validate(value, struct, {
          coerce: true,
          mask: true,
          message
        });
        if (result[0]) {
          throw result[0];
        } else {
          return result[1];
        }
      }
      function is(value, struct) {
        const result = validate(value, struct);
        return !result[0];
      }
      function validate(value, struct, options = {}) {
        const tuples = run(value, struct, options);
        const tuple = shiftIterator(tuples);
        if (tuple[0]) {
          const error = new StructError(tuple[0], function* () {
            for (const t of tuples) {
              if (t[0]) {
                yield t[0];
              }
            }
          });
          return [error, undefined];
        } else {
          const v = tuple[1];
          return [undefined, v];
        }
      }
      function assign(...Structs) {
        const isType = Structs[0].type === 'type';
        const schemas = Structs.map(s => s.schema);
        const schema = Object.assign({}, ...schemas);
        return isType ? type(schema) : object(schema);
      }
      function define(name, validator) {
        return new Struct({
          type: name,
          schema: null,
          validator
        });
      }
      function deprecated(struct, log) {
        return new Struct({
          ...struct,
          refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
          validator(value, ctx) {
            if (value === undefined) {
              return true;
            } else {
              log(value, ctx);
              return struct.validator(value, ctx);
            }
          }
        });
      }
      function dynamic(fn) {
        return new Struct({
          type: 'dynamic',
          schema: null,
          *entries(value, ctx) {
            const struct = fn(value, ctx);
            yield* struct.entries(value, ctx);
          },
          validator(value, ctx) {
            const struct = fn(value, ctx);
            return struct.validator(value, ctx);
          },
          coercer(value, ctx) {
            const struct = fn(value, ctx);
            return struct.coercer(value, ctx);
          },
          refiner(value, ctx) {
            const struct = fn(value, ctx);
            return struct.refiner(value, ctx);
          }
        });
      }
      function lazy(fn) {
        let struct;
        return new Struct({
          type: 'lazy',
          schema: null,
          *entries(value, ctx) {
            struct ?? (struct = fn());
            yield* struct.entries(value, ctx);
          },
          validator(value, ctx) {
            struct ?? (struct = fn());
            return struct.validator(value, ctx);
          },
          coercer(value, ctx) {
            struct ?? (struct = fn());
            return struct.coercer(value, ctx);
          },
          refiner(value, ctx) {
            struct ?? (struct = fn());
            return struct.refiner(value, ctx);
          }
        });
      }
      function omit(struct, keys) {
        const {
          schema
        } = struct;
        const subschema = {
          ...schema
        };
        for (const key of keys) {
          delete subschema[key];
        }
        switch (struct.type) {
          case 'type':
            return type(subschema);
          default:
            return object(subschema);
        }
      }
      function partial(struct) {
        const schema = struct instanceof Struct ? {
          ...struct.schema
        } : {
          ...struct
        };
        for (const key in schema) {
          schema[key] = optional(schema[key]);
        }
        return object(schema);
      }
      function pick(struct, keys) {
        const {
          schema
        } = struct;
        const subschema = {};
        for (const key of keys) {
          subschema[key] = schema[key];
        }
        return object(subschema);
      }
      function struct(name, validator) {
        console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
        return define(name, validator);
      }
      function any() {
        return define('any', () => true);
      }
      function array(Element) {
        return new Struct({
          type: 'array',
          schema: Element,
          *entries(value) {
            if (Element && Array.isArray(value)) {
              for (const [i, v] of value.entries()) {
                yield [i, v, Element];
              }
            }
          },
          coercer(value) {
            return Array.isArray(value) ? value.slice() : value;
          },
          validator(value) {
            return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
          }
        });
      }
      function bigint() {
        return define('bigint', value => {
          return typeof value === 'bigint';
        });
      }
      function boolean() {
        return define('boolean', value => {
          return typeof value === 'boolean';
        });
      }
      function date() {
        return define('date', value => {
          return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print(value)}`;
        });
      }
      function enums(values) {
        const schema = {};
        const description = values.map(v => print(v)).join();
        for (const key of values) {
          schema[key] = key;
        }
        return new Struct({
          type: 'enums',
          schema,
          validator(value) {
            return values.includes(value) || `Expected one of \`${description}\`, but received: ${print(value)}`;
          }
        });
      }
      function func() {
        return define('func', value => {
          return typeof value === 'function' || `Expected a function, but received: ${print(value)}`;
        });
      }
      function instance(Class) {
        return define('instance', value => {
          return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
        });
      }
      function integer() {
        return define('integer', value => {
          return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
        });
      }
      function intersection(Structs) {
        return new Struct({
          type: 'intersection',
          schema: null,
          *entries(value, ctx) {
            for (const S of Structs) {
              yield* S.entries(value, ctx);
            }
          },
          *validator(value, ctx) {
            for (const S of Structs) {
              yield* S.validator(value, ctx);
            }
          },
          *refiner(value, ctx) {
            for (const S of Structs) {
              yield* S.refiner(value, ctx);
            }
          }
        });
      }
      function literal(constant) {
        const description = print(constant);
        const t = typeof constant;
        return new Struct({
          type: 'literal',
          schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,
          validator(value) {
            return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
          }
        });
      }
      function map(Key, Value) {
        return new Struct({
          type: 'map',
          schema: null,
          *entries(value) {
            if (Key && Value && value instanceof Map) {
              for (const [k, v] of value.entries()) {
                yield [k, k, Key];
                yield [k, v, Value];
              }
            }
          },
          coercer(value) {
            return value instanceof Map ? new Map(value) : value;
          },
          validator(value) {
            return value instanceof Map || `Expected a \`Map\` object, but received: ${print(value)}`;
          }
        });
      }
      function never() {
        return define('never', () => false);
      }
      function nullable(struct) {
        return new Struct({
          ...struct,
          validator: (value, ctx) => value === null || struct.validator(value, ctx),
          refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
        });
      }
      function number() {
        return define('number', value => {
          return typeof value === 'number' && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
        });
      }
      function object(schema) {
        const knowns = schema ? Object.keys(schema) : [];
        const Never = never();
        return new Struct({
          type: 'object',
          schema: schema ? schema : null,
          *entries(value) {
            if (schema && isObject(value)) {
              const unknowns = new Set(Object.keys(value));
              for (const key of knowns) {
                unknowns.delete(key);
                yield [key, value[key], schema[key]];
              }
              for (const key of unknowns) {
                yield [key, value[key], Never];
              }
            }
          },
          validator(value) {
            return isObject(value) || `Expected an object, but received: ${print(value)}`;
          },
          coercer(value) {
            return isObject(value) ? {
              ...value
            } : value;
          }
        });
      }
      function optional(struct) {
        return new Struct({
          ...struct,
          validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
          refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)
        });
      }
      function record(Key, Value) {
        return new Struct({
          type: 'record',
          schema: null,
          *entries(value) {
            if (isObject(value)) {
              for (const k in value) {
                const v = value[k];
                yield [k, k, Key];
                yield [k, v, Value];
              }
            }
          },
          validator(value) {
            return isObject(value) || `Expected an object, but received: ${print(value)}`;
          }
        });
      }
      function regexp() {
        return define('regexp', value => {
          return value instanceof RegExp;
        });
      }
      function set(Element) {
        return new Struct({
          type: 'set',
          schema: null,
          *entries(value) {
            if (Element && value instanceof Set) {
              for (const v of value) {
                yield [v, v, Element];
              }
            }
          },
          coercer(value) {
            return value instanceof Set ? new Set(value) : value;
          },
          validator(value) {
            return value instanceof Set || `Expected a \`Set\` object, but received: ${print(value)}`;
          }
        });
      }
      function string() {
        return define('string', value => {
          return typeof value === 'string' || `Expected a string, but received: ${print(value)}`;
        });
      }
      function tuple(Structs) {
        const Never = never();
        return new Struct({
          type: 'tuple',
          schema: null,
          *entries(value) {
            if (Array.isArray(value)) {
              const length = Math.max(Structs.length, value.length);
              for (let i = 0; i < length; i++) {
                yield [i, value[i], Structs[i] || Never];
              }
            }
          },
          validator(value) {
            return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
          }
        });
      }
      function type(schema) {
        const keys = Object.keys(schema);
        return new Struct({
          type: 'type',
          schema,
          *entries(value) {
            if (isObject(value)) {
              for (const k of keys) {
                yield [k, value[k], schema[k]];
              }
            }
          },
          validator(value) {
            return isObject(value) || `Expected an object, but received: ${print(value)}`;
          },
          coercer(value) {
            return isObject(value) ? {
              ...value
            } : value;
          }
        });
      }
      function union(Structs) {
        const description = Structs.map(s => s.type).join(' | ');
        return new Struct({
          type: 'union',
          schema: null,
          coercer(value) {
            for (const S of Structs) {
              const [error, coerced] = S.validate(value, {
                coerce: true
              });
              if (!error) {
                return coerced;
              }
            }
            return value;
          },
          validator(value, ctx) {
            const failures = [];
            for (const S of Structs) {
              const [...tuples] = run(value, S, ctx);
              const [first] = tuples;
              if (!first[0]) {
                return [];
              } else {
                for (const [failure] of tuples) {
                  if (failure) {
                    failures.push(failure);
                  }
                }
              }
            }
            return [`Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`, ...failures];
          }
        });
      }
      function unknown() {
        return define('unknown', () => true);
      }
      function coerce(struct, condition, coercer) {
        return new Struct({
          ...struct,
          coercer: (value, ctx) => {
            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
          }
        });
      }
      function defaulted(struct, fallback, options = {}) {
        return coerce(struct, unknown(), x => {
          const f = typeof fallback === 'function' ? fallback() : fallback;
          if (x === undefined) {
            return f;
          }
          if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
            const ret = {
              ...x
            };
            let changed = false;
            for (const key in f) {
              if (ret[key] === undefined) {
                ret[key] = f[key];
                changed = true;
              }
            }
            if (changed) {
              return ret;
            }
          }
          return x;
        });
      }
      function trimmed(struct) {
        return coerce(struct, string(), x => x.trim());
      }
      function empty(struct) {
        return refine(struct, 'empty', value => {
          const size = getSize(value);
          return size === 0 || `Expected an empty ${struct.type} but received one with a size of \`${size}\``;
        });
      }
      function getSize(value) {
        if (value instanceof Map || value instanceof Set) {
          return value.size;
        } else {
          return value.length;
        }
      }
      function max(struct, threshold, options = {}) {
        const {
          exclusive
        } = options;
        return refine(struct, 'max', value => {
          return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
      }
      function min(struct, threshold, options = {}) {
        const {
          exclusive
        } = options;
        return refine(struct, 'min', value => {
          return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
      }
      function nonempty(struct) {
        return refine(struct, 'nonempty', value => {
          const size = getSize(value);
          return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;
        });
      }
      function pattern(struct, regexp) {
        return refine(struct, 'pattern', value => {
          return regexp.test(value) || `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`;
        });
      }
      function size(struct, min, max = min) {
        const expected = `Expected a ${struct.type}`;
        const of = min === max ? `of \`${min}\`` : `between \`${min}\` and \`${max}\``;
        return refine(struct, 'size', value => {
          if (typeof value === 'number' || value instanceof Date) {
            return min <= value && value <= max || `${expected} ${of} but received \`${value}\``;
          } else if (value instanceof Map || value instanceof Set) {
            const {
              size
            } = value;
            return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \`${size}\``;
          } else {
            const {
              length
            } = value;
            return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \`${length}\``;
          }
        });
      }
      function refine(struct, name, refiner) {
        return new Struct({
          ...struct,
          *refiner(value, ctx) {
            yield* struct.refiner(value, ctx);
            const result = refiner(value, ctx);
            const failures = toFailures(result, ctx, struct, value);
            for (const failure of failures) {
              yield {
                ...failure,
                refinement: name
              };
            }
          }
        });
      }
    },
    3817: module => {
      "use strict";

      module.exports = JSON.parse('{"Dev-CubeSignerStack":{"ClientId":"405mhvv13llufju1ruvnq42rdc","LongLivedClientId":"6he1bnm17s0dv8bb4hjim6fs6i","Region":"us-east-1","UserPoolId":"us-east-1_79ljlRRfX","SignerApiRoot":"https://beta.signer.cubist.dev"}}');
    },
    2987: module => {
      "use strict";

      module.exports = JSON.parse('{"Dev-CubeSignerStack":{"ClientId":"1tiou9ecj058khiidmhj4ds4rj","LongLivedClientId":"4jiuai7mtl5164of3drmvej234","Region":"us-east-1","UserPoolId":"us-east-1_RU7HEslOW","SignerApiRoot":"https://gamma.signer.cubist.dev"}}');
    },
    1174: module => {
      "use strict";

      module.exports = JSON.parse('{"Dev-CubeSignerStack":{"ClientId":"2saesgbmeu8p981sk33sr6nq1j","LongLivedClientId":"79qoe43lbiphd7jv0emqadtoia","Region":"us-east-1","UserPoolId":"us-east-1_lLLal8vGd","SignerApiRoot":"https://prod.signer.cubist.dev"}}');
    }
  };
  var __webpack_module_cache__ = {};
  function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = __webpack_module_cache__[moduleId] = {
      exports: {}
    };
    __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    return module.exports;
  }
  (() => {
    __webpack_require__.n = module => {
      var getter = module && module.__esModule ? () => module['default'] : () => module;
      __webpack_require__.d(getter, {
        a: getter
      });
      return getter;
    };
  })();
  (() => {
    __webpack_require__.d = (exports, definition) => {
      for (var key in definition) {
        if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
        }
      }
    };
  })();
  (() => {
    __webpack_require__.g = function () {
      if (typeof globalThis === 'object') return globalThis;
      try {
        return this || new Function('return this')();
      } catch (e) {
        if (typeof window === 'object') return window;
      }
    }();
  })();
  (() => {
    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
  })();
  (() => {
    __webpack_require__.r = exports => {
      if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
      }
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    };
  })();
  var __webpack_exports__ = {};
  (() => {
    "use strict";

    var exports = __webpack_exports__;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "onRpcRequest", {
      enumerable: true,
      get: function () {
        return onRpcRequest;
      }
    });
    const _session = __webpack_require__(2686);
    const _keys = __webpack_require__(3626);
    const _sign = __webpack_require__(6173);
    const onRpcRequest = async rpc => {
      switch (rpc.request.method) {
        case "login":
          return await (0, _session.login)(rpc);
        case "logout":
          return await (0, _session.logout)(rpc);
        case "get_keys":
          return await (0, _keys.getKeys)();
        case "sign_blob":
          return await (0, _sign.signBlob)(rpc);
        case "sign_evm":
          return await (0, _sign.signEvm)(rpc);
        case "sign_solana":
          return await (0, _sign.signSolana)(rpc);
        case "sign_btc":
          return await (0, _sign.signBtc)(rpc);
        default:
          throw new Error(`Method not found: ${rpc.request.method}`);
      }
    };
  })();
  var __webpack_export_target__ = exports;
  for (var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
  if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", {
    value: true
  });
})();
//# sourceMappingURL=bundle.js.map